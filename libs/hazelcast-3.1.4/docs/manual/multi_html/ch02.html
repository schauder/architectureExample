<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;2.&nbsp;Distributed Data Structures</title><link rel="stylesheet" type="text/css" href="./docbook.css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"><meta name="keywords" content="hazelcast, distributed, cache, distributed cache, cluster, data grid, in-memory data grid"><link rel="home" href="index.html" title="In-Memory Data Grid - Hazelcast | Documentation"><link rel="up" href="index.html" title="In-Memory Data Grid - Hazelcast | Documentation"><link rel="prev" href="ch01s04.html" title="1.4.&nbsp;Getting Started (Tutorial)"><link rel="next" href="ch02s02.html" title="2.2.&nbsp;Distributed Queue"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;2.&nbsp;Distributed Data Structures</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch01s04.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="ch02s02.html">Next</a></td></tr></table><hr></div><div class="chapter" title="Chapter&nbsp;2.&nbsp;Distributed Data Structures"><div class="titlepage"><div><div><h2 class="title"><a name="DDS"></a>Chapter&nbsp;2.&nbsp;Distributed Data Structures</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="ch02.html#Map">2.1. Distributed Map</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch02.html#MapBackup">2.1.1. Backups</a></span></dt><dt><span class="sect2"><a href="ch02.html#MapEviction">2.1.2. Eviction</a></span></dt><dt><span class="sect2"><a href="ch02.html#MapPersistence">2.1.3. Persistence</a></span></dt><dt><span class="sect2"><a href="ch02.html#MapQuery">2.1.4. Query</a></span></dt><dt><span class="sect2"><a href="ch02.html#MapIndex">2.1.5. Indexing</a></span></dt><dt><span class="sect2"><a href="ch02.html#MapContinuousQuery">2.1.6. Continuous Query</a></span></dt><dt><span class="sect2"><a href="ch02.html#MapEntryProcessor">2.1.7. Entry Processor</a></span></dt><dt><span class="sect2"><a href="ch02.html#MapInterceptor">2.1.8. Interceptors</a></span></dt><dt><span class="sect2"><a href="ch02.html#MapNearCache">2.1.9. Near Cache</a></span></dt><dt><span class="sect2"><a href="ch02.html#MapEntry">2.1.10. Entry Statistics</a></span></dt><dt><span class="sect2"><a href="ch02.html#MapInMemoryFormat">2.1.11. In Memory Format</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch02s02.html">2.2. Distributed Queue</a></span></dt><dd><dl><dt><span class="sect2"><a href="ch02s02.html#QueuePersistence">2.2.1. Persistence</a></span></dt></dl></dd><dt><span class="sect1"><a href="ch02s03.html">2.3. Distributed MultiMap</a></span></dt><dt><span class="sect1"><a href="ch02s04.html">2.4. Distributed Topic</a></span></dt><dt><span class="sect1"><a href="ch02s05.html">2.5. Distributed Set</a></span></dt><dt><span class="sect1"><a href="ch02s06.html">2.6. Distributed List</a></span></dt><dt><span class="sect1"><a href="ch02s07.html">2.7. Distributed Lock</a></span></dt><dt><span class="sect1"><a href="ch02s08.html">2.8. Distributed Events</a></span></dt></dl></div><p>
    Common Features of all Hazelcast Data Structures:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Data in the cluster is almost evenly distributed (partitioned) across all nodes.
                So each node carries ~ (1/n
                <code class="literal">*</code>
                total-data) + backups , n being the
                number of nodes in the cluster.
            </p></li><li class="listitem"><p>If a member goes down, its backup replica that also holds the same data, will
                dynamically redistribute the data including the ownership and locks on them to
                remaining live nodes. As a result, no data will get lost.
            </p></li><li class="listitem"><p>When a new node joins the cluster, new node takes ownership(responsibility) and
                load of -some- of the entire data in the cluster. Eventually the new node will carry
                almost (1/n
                <code class="literal">*</code>
                total-data) + backups and becomes the new partition
                reducing the load on others.
            </p></li><li class="listitem"><p>There is no single cluster master or something that can cause single point of
                failure. Every node in the cluster has equal rights and responsibilities. No-one is
                superior. And no dependency on external 'server' or 'master' kind of concept.
            </p></li><li class="listitem"><p>Hazelcast will synchronize the state of Distributed Data Structures, but not the content of it.
                Example: if you have an IMap &lt; String, Employee &gt; and one node fires an employee by calling
                employees.get(&#8220;John&#8221;).setFired(true);
                then the state of Employee will not be synchronized. This is because employees.get("John") will create a
                copy of the existing employee.
                You need to put it back by calling employees.put("John", employee) in order for the state to be
                reflected in Hazelcast.
                As a rule of thumb you should treat everything stored in Hazelcast as immutable objects.
            </p></li></ul></div><p>
    Here is how you can retrieve existing data structure instances (map, queue, set,
    lock, topic, etc.) and how you can listen for instance events to get notified when an instance
    is created or destroyed.
    </p><pre class="programlisting"><strong class="hl-keyword">import</strong> java.util.Collection;
<strong class="hl-keyword">import</strong> com.hazelcast.config.Config;
<strong class="hl-keyword">import</strong> com.hazelcast.core.*;

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Sample <strong class="hl-keyword">implements</strong> DistributedObjectListener {
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">static</strong> <strong class="hl-keyword">void</strong> main(String[] args) {
        Sample sample = <strong class="hl-keyword">new</strong> Sample();

        Config cfg = <strong class="hl-keyword">new</strong> Config();
        HazelcastInstance hz = Hazelcast.newHazelcastInstance(cfg);
        hz.addDistributedObjectListener(sample);

        Collection&lt;DistributedObject&gt; distributedObjects = hz.getDistributedObjects();

        <strong class="hl-keyword">for</strong> (DistributedObject distributedObject : distributedObjects) {
            System.out.println(distributedObject.getName() + <font font-style="normal" color="#008000">","</font> + distributedObject.getId());
        }
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> distributedObjectCreated(DistributedObjectEvent event) {
        DistributedObject instance = event.getDistributedObject();
        System.out.println(<font font-style="normal" color="#008000">"Created "</font> + instance.getName() + <font font-style="normal" color="#008000">","</font> + instance.getId());
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> distributedObjectDestroyed(DistributedObjectEvent event) {
        DistributedObject instance = event.getDistributedObject();
        System.out.println(<font font-style="normal" color="#008000">"Destroyed "</font> + instance.getName() + <font font-style="normal" color="#008000">","</font> + instance.getId());

    }
}</pre><p>
</p><div class="sect1" title="2.1.&nbsp;Distributed Map"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Map"></a>2.1.&nbsp;Distributed Map</h2></div></div></div><p>Hazelcast will partition your map entries; and almost evenly
        distribute onto all Hazelcast members. Distributed maps have 1 backup by
        default so that if a member goes down, we don't lose data. Backup operations are synchronous
        so when a
        <code class="literal">map.put(key, value)</code>
        returns, it is guaranteed that the entry is
        replicated to one other node. For the reads, it is also guaranteed that
        <code class="literal">map.get(key)</code>
        returns the latest value of the entry. Consistency is
        strictly enforced.
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> java.util.Map;
<strong class="hl-keyword">import</strong> java.util.Collection;
<strong class="hl-keyword">import</strong> com.hazelcast.config.Config;

Config cfg = <strong class="hl-keyword">new</strong> Config();
HazelcastInstance hz = Hazelcast.newHazelcastInstance(cfg);
Map&lt;String, Customer&gt; mapCustomers = hz.getMap(<font font-style="normal" color="#008000">"customers"</font>);
mapCustomers.put(<font font-style="normal" color="#008000">"1"</font>, <strong class="hl-keyword">new</strong> Customer(<font font-style="normal" color="#008000">"Joe"</font>, <font font-style="normal" color="#008000">"Smith"</font>));
mapCustomers.put(<font font-style="normal" color="#008000">"2"</font>, <strong class="hl-keyword">new</strong> Customer(<font font-style="normal" color="#008000">"Ali"</font>, <font font-style="normal" color="#008000">"Selam"</font>));
mapCustomers.put(<font font-style="normal" color="#008000">"3"</font>, <strong class="hl-keyword">new</strong> Customer(<font font-style="normal" color="#008000">"Avi"</font>, <font font-style="normal" color="#008000">"Noyan"</font>));

Collection&lt;Customer&gt; colCustomers = mapCustomers.values();
<strong class="hl-keyword">for</strong> (Customer customer : colCustomers) {
    <em class="hl-comment" style="color: silver">// process customer</em>
}
</pre><p>
        <code class="literal">HazelcastInstance.getMap()</code>
        actually returns
        <code class="literal">com.hazelcast.core.IMap</code>
        which extends
        <code class="literal">java.util.concurrent.ConcurrentMap</code>
        interface. So methods like
        <code class="literal">ConcurrentMap.putIfAbsent(key,value)</code>
        and
        <code class="literal">ConcurrentMap.replace(key,value)</code>
        can be used on distributed map as
        shown in the example below.
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> java.util.concurrent.ConcurrentMap;

Customer getCustomer (String id) {
    ConcurrentMap&lt;String, Customer&gt; map = hz.getMap(<font font-style="normal" color="#008000">"customers"</font>);
    Customer customer = map.get(id);
    <strong class="hl-keyword">if</strong> (customer == null) {
        customer = <strong class="hl-keyword">new</strong> Customer (id);
        customer = map.putIfAbsent(id, customer);
    }
    <strong class="hl-keyword">return</strong> customer;
}               

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">boolean</strong> updateCustomer (Customer customer) {
    ConcurrentMap&lt;String, Customer&gt; map = hz.getMap(<font font-style="normal" color="#008000">"customers"</font>);
    <strong class="hl-keyword">return</strong> (map.replace(customer.getId(), customer) != null);            
}
                
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">boolean</strong> removeCustomer (Customer customer) {
    ConcurrentMap&lt;String, Customer&gt; map = hz.getMap(<font font-style="normal" color="#008000">"customers"</font>);
    <strong class="hl-keyword">return</strong> map.remove(customer.getId(), customer) );           
}                                  
        
</pre><p>
        All
        <code class="literal">ConcurrentMap</code>
        operations such as
        <code class="literal">put</code>
        and
        <code class="literal">remove</code>
        might wait if the key is locked by another thread in the local
        or remote JVM, but they will eventually return with success.
        <code class="literal">ConcurrentMap</code>
        operations never
        throw<code class="literal">java.util.ConcurrentModificationException</code>.
    </p><p>Also see:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Distributed Map internals.</p></li><li class="listitem"><p><a class="link" href="ch06.html" title="Chapter&nbsp;6.&nbsp;Data Affinity">Data Affinity</a>.</p></li><li class="listitem"><p><a class="link" href="ch14s05.html" title="14.5.&nbsp;Wildcard Configuration">Map Configuration with wildcards.</a>.</p></li></ul></div><p>
    </p><div class="sect2" title="2.1.1.&nbsp;Backups"><div class="titlepage"><div><div><h3 class="title"><a name="MapBackup"></a>2.1.1.&nbsp;Backups</h3></div></div></div><p>Hazelcast will distribute map entries onto multiple JVMs (cluster members). Each JVM
        holds some portion of the data but we don't want to lose data when a member JVM crashes.
        To provide data-safety, Hazelcast allows you to specify the number of backup copies you
        want to have. That way data on a JVM will be copied onto other JVM(s). Hazelcast supports both
        <code class="literal">sync</code> and <code class="literal">async</code> backups.
        <code class="literal">Sync</code> backups block operations until backups are successfully copied to
        backups nodes (or deleted from backup nodes in case of remove)
        and acknowledgements are received. In contrast, <code class="literal">async</code> backups do not block
        operations, they are fire &amp; forget and do not require acknowledgements.
        By default, Hazelcast will have one sync backup copy.
        If backup count &gt;= 1, then each member will carry both owned entries and backup copies of other
        member(s). So for the <code class="literal">map.get(key)</code> call, it is possible that calling member has backup
        copy of that key but by default, <code class="literal">map.get(key)</code> will always read the
        value from the actual owner of the key for consistency. It is possible to enable backup
        reads by changing the configuration. Enabling backup reads will give you greater performance.
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <em class="hl-comment" style="color: silver">&lt;!--
            Number of sync-backups. If 1 is set as the backup-count for example,
            then all entries of the map will be copied to another JVM for
            fail-safety. Valid numbers are 0 (no backup), 1, 2, 3.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;backup-count&gt;</font>1<font font-style="bold" color="#0A1777">&lt;/backup-count&gt;</font>

        <em class="hl-comment" style="color: silver">&lt;!--
            Number of async-backups. If 1 is set as the backup-count for example,
            then all entries of the map will be copied to another JVM for
            fail-safety. Valid numbers are 0 (no backup), 1, 2, 3.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;async-backup-count&gt;</font>1<font font-style="bold" color="#0A1777">&lt;/async-backup-count&gt;</font>

        <em class="hl-comment" style="color: silver">&lt;!--
            Can we read the local backup entries? Default value is false for
            strong consistency. Being able to read backup data will give you
            greater performance.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;read-backup-data&gt;</font>false<font font-style="bold" color="#0A1777">&lt;/read-backup-data&gt;</font>

        ...
    <font font-style="bold" color="#0A1777">&lt;/map&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>
    </p></div><div class="sect2" title="2.1.2.&nbsp;Eviction"><div class="titlepage"><div><div><h3 class="title"><a name="MapEviction"></a>2.1.2.&nbsp;Eviction</h3></div></div></div><p>Hazelcast also supports policy based eviction for distributed map. Currently supported
        eviction policies are LRU (Least Recently Used) and LFU (Least Frequently Used). This
        feature enables Hazelcast to be used as a distributed cache. If
        <code class="literal">time-to-live-seconds</code>
        is not 0 then entries older than
        <code class="literal">time-to-live-seconds</code>
        value will get evicted, regardless of the
        eviction policy set. Here is a sample configuration for eviction:
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <em class="hl-comment" style="color: silver">&lt;!--
            Number of backups. If 1 is set as the backup-count for example,
            then all entries of the map will be copied to another JVM for
            fail-safety. Valid numbers are 0 (no backup), 1, 2, 3.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;backup-count&gt;</font>1<font font-style="bold" color="#0A1777">&lt;/backup-count&gt;</font>

        <em class="hl-comment" style="color: silver">&lt;!--
            Maximum number of seconds for each entry to stay in the map. Entries that are
            older than &lt;time-to-live-seconds&gt; and not updated for &lt;time-to-live-seconds&gt;
            will get automatically evicted from the map.
            Any integer between 0 and Integer.MAX_VALUE. 0 means infinite. Default is 0.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;time-to-live-seconds&gt;</font>0<font font-style="bold" color="#0A1777">&lt;/time-to-live-seconds&gt;</font>

        <em class="hl-comment" style="color: silver">&lt;!--
            Maximum number of seconds for each entry to stay idle in the map. Entries that are
            idle(not touched) for more than &lt;max-idle-seconds&gt; will get
            automatically evicted from the map.
            Entry is touched if get, put or containsKey is called.
            Any integer between 0 and Integer.MAX_VALUE.
            0 means infinite. Default is 0.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;max-idle-seconds&gt;</font>0<font font-style="bold" color="#0A1777">&lt;/max-idle-seconds&gt;</font>

        <em class="hl-comment" style="color: silver">&lt;!--
            Valid values are:
            NONE (no extra eviction, &lt;time-to-live-seconds&gt; may still apply),
            LRU  (Least Recently Used),
            LFU  (Least Frequently Used).
            NONE is the default.
            Regardless of the eviction policy used, &lt;time-to-live-seconds&gt; will still apply. 
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;eviction-policy&gt;</font>LRU<font font-style="bold" color="#0A1777">&lt;/eviction-policy&gt;</font>

        <em class="hl-comment" style="color: silver">&lt;!--
            Maximum size of the map. When max size is reached,
            map is evicted based on the policy defined.
            Any integer between 0 and Integer.MAX_VALUE. 0 means
            Integer.MAX_VALUE. Default is 0.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;max-size</font> <font font-style="bold" color="#0A1777">policy</font>=<font font-style="bold" color="#008000">"PER_NODE"</font><font font-style="bold" color="#0A1777">&gt;</font>5000<font font-style="bold" color="#0A1777">&lt;/max-size&gt;</font>

        <em class="hl-comment" style="color: silver">&lt;!--
            When max. size is reached, specified percentage of
            the map will be evicted. Any integer between 0 and 100.
            If 25 is set for example, 25% of the entries will
            get evicted.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;eviction-percentage&gt;</font>25<font font-style="bold" color="#0A1777">&lt;/eviction-percentage&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/map&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>
    </p><p>
        <span class="bold"><strong>Max-Size Policies</strong></span>
    </p><p>
        There are 4 defined policies can be used in max-size configuration.
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                    <span class="bold"><strong>PER_NODE:</strong></span>  Max map size per instance.
                    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;max-size</font> <font font-style="bold" color="#0A1777">policy</font>=<font font-style="bold" color="#008000">"PER_NODE"</font><font font-style="bold" color="#0A1777">&gt;</font>5000<font font-style="bold" color="#0A1777">&lt;/max-size&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>PER_PARTITION:</strong></span> Max map size per each partition.
                    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;max-size</font> <font font-style="bold" color="#0A1777">policy</font>=<font font-style="bold" color="#008000">"PER_PARTITION"</font><font font-style="bold" color="#0A1777">&gt;</font>27100<font font-style="bold" color="#0A1777">&lt;/max-size&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>USED_HEAP_SIZE:</strong></span> Max used heap size in MB (mega-bytes) per JVM.
                    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;max-size</font> <font font-style="bold" color="#0A1777">policy</font>=<font font-style="bold" color="#008000">"USED_HEAP_SIZE"</font><font font-style="bold" color="#0A1777">&gt;</font>4096<font font-style="bold" color="#0A1777">&lt;/max-size&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>USED_HEAP_PERCENTAGE:</strong></span> Max used heap size percentage per JVM.
                    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;max-size</font> <font font-style="bold" color="#0A1777">policy</font>=<font font-style="bold" color="#008000">"USED_HEAP_PERCENTAGE"</font><font font-style="bold" color="#0A1777">&gt;</font>75<font font-style="bold" color="#0A1777">&lt;/max-size&gt;</font></pre><p>
                </p></li></ol></div><p>
    </p></div><div class="sect2" title="2.1.3.&nbsp;Persistence"><div class="titlepage"><div><div><h3 class="title"><a name="MapPersistence"></a>2.1.3.&nbsp;Persistence</h3></div></div></div><p>Hazelcast allows you to load and store the distributed map entries from/to a
        persistent datastore such as relational database. If a loader implementation is
        provided, when
        <code class="literal">get(key)</code>
        is called, if the map entry doesn't exist
        in-memory then Hazelcast will call your loader implementation to load the entry from a
        datastore. If a store implementation is provided, when
        <code class="literal">put(key,value)</code>
        is called, Hazelcast will call your store implementation to store the entry into a
        datastore. Hazelcast can call your implementation to store the entries synchronously
        (write-through) with no-delay or asynchronously (write-behind) with delay and it is
        defined by the
        <code class="literal">write-delay-seconds</code>
        value in the configuration.
    </p><p>If it is write-through, when the
        <code class="literal">map.put(key,value)</code>
        call returns,
        you can be sure that
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    <code class="literal">MapStore.store(key,value)</code>
                    is successfully called so the
                    entry is persisted.
                </p></li><li class="listitem"><p>In-Memory entry is updated</p></li><li class="listitem"><p>In-Memory backup copies are successfully created on other JVMs (if
                    backup-count is greater than 0)
                </p></li></ul></div><p>
        If it is write-behind, when the
        <code class="literal">map.put(key,value)</code>
        call returns, you can be sure that
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>In-Memory entry is updated</p></li><li class="listitem"><p>In-Memory backup copies are successfully created on other JVMs (if
                    backup-count is greater than 0)
                </p></li><li class="listitem"><p>The entry is marked as
                    <code class="literal">dirty</code>
                    so that after
                    <code class="literal">write-delay-seconds</code>, it can be persisted.
                </p></li></ul></div><p>
        Same behavior goes for the
        <code class="literal">remove(key</code>
        and
        <code class="literal">MapStore.delete(key)</code>. If
        <code class="literal">MapStore</code>
        throws an
        exception then the exception will be propagated back to the original
        <code class="literal">put</code>
        or
        <code class="literal">remove</code>
        call in the form of
        <code class="literal">RuntimeException</code>. When write-through is used, Hazelcast will call
        <code class="literal">MapStore.store(key,value)</code>
        and
        <code class="literal">MapStore.delete(key)</code>
        for each entry update. When write-behind is
        used, Hazelcast will call<code class="literal">MapStore.store(map)</code>, and
        <code class="literal">MapStore.delete(collection)</code>
        to do all writes in a single call.
        Also note that your MapStore or MapLoader implementation should not use Hazelcast
        Map/Queue/MultiMap/List/Set operations. Your implementation should only work with your
        data store. Otherwise you may get into deadlock situations.
    </p><p>Here is a sample configuration:
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
        ...
        <font font-style="bold" color="#0A1777">&lt;map-store</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <em class="hl-comment" style="color: silver">&lt;!--
               Name of the class implementing MapLoader and/or MapStore.
               The class should implement at least of these interfaces and
               contain no-argument constructor. Note that the inner classes are not supported.
            --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;class-name&gt;</font>com.hazelcast.examples.DummyStore<font font-style="bold" color="#0A1777">&lt;/class-name&gt;</font>
            <em class="hl-comment" style="color: silver">&lt;!--
               Number of seconds to delay to call the MapStore.store(key, value).
               If the value is zero then it is write-through so MapStore.store(key, value)
               will be called as soon as the entry is updated.
               Otherwise it is write-behind so updates will be stored after write-delay-seconds
               value by calling Hazelcast.storeAll(map). Default value is 0.
            --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;write-delay-seconds&gt;</font>0<font font-style="bold" color="#0A1777">&lt;/write-delay-seconds&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/map-store&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/map&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>
    </p><p>
        <span class="italic">
            <span class="bold"><strong>Initialization on
                startup:
            </strong></span>
        </span>
    </p><p>
        <code class="literal">MapLoader.loadAllKeys</code>
        API is used for pre-populating the
        in-memory map when the map is first touched/used. If
        <code class="literal">MapLoader.loadAllKeys</code>
        returns NULL then nothing will be loaded.
        Your
        <code class="literal">MapLoader.loadAllKeys</code>
        implementation can return all or some of the keys. You may
        select and return only the
        <code class="literal">hot</code>
        keys, for instance. Also note that
        this is the fastest way of pre-populating the map as Hazelcast will optimize the loading
        process by having each node loading owned portion of the entries.
    </p><p>Here is MapLoader initialization flow;
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>When
                    <code class="code">getMap()</code>
                    first called from any node, initialization starts
                </p></li><li class="listitem"><p>Hazelcast will call
                    <code class="code">MapLoader.loadAllKeys()</code>
                    to get all your keys on each
                    node
                </p></li><li class="listitem"><p>Each node will figure out the list of keys it owns</p></li><li class="listitem"><p>Each node will load all its owned keys by calling
                    <code class="code">MapLoader.loadAll(keys)</code>
                </p></li><li class="listitem"><p>Each node puts its owned entries into the map by
                    calling
                    <code class="code">IMap.putTransient(key,value)</code>
                </p></li></ol></div><p>
    </p></div><div class="sect2" title="2.1.4.&nbsp;Query"><div class="titlepage"><div><div><h3 class="title"><a name="MapQuery"></a>2.1.4.&nbsp;Query</h3></div></div></div><p>Hazelcast partitions your data and spreads across cluster of servers. You can surely
        iterate over the map entries and look for certain entries you are interested in but this
        is not very efficient as you will have to bring entire entry set and iterate locally.
        Instead, Hazelcast allows you to run distributed queries on your distributed map.
    </p><p>Let's say you have a "employee" map containing values of
        <code class="literal">Employee</code>
        objects:</p><pre class="programlisting"><strong class="hl-keyword">import</strong> java.io.Serializable;

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Employee <strong class="hl-keyword">implements</strong> Serializable {
<strong class="hl-keyword">private</strong> String name;
<strong class="hl-keyword">private</strong> <strong class="hl-keyword">int</strong> age;
<strong class="hl-keyword">private</strong> <strong class="hl-keyword">boolean</strong> active;
<strong class="hl-keyword">private</strong> <strong class="hl-keyword">double</strong> salary;

<strong class="hl-keyword">public</strong> Employee(String name, <strong class="hl-keyword">int</strong> age, <strong class="hl-keyword">boolean</strong> live, <strong class="hl-keyword">double</strong> price) {
    <strong class="hl-keyword">this</strong>.name = name;
    <strong class="hl-keyword">this</strong>.age = age;
    <strong class="hl-keyword">this</strong>.active = live;
    <strong class="hl-keyword">this</strong>.salary = price;
}

<strong class="hl-keyword">public</strong> Employee() {
}

<strong class="hl-keyword">public</strong> String getName() {
    <strong class="hl-keyword">return</strong> name;
}

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">int</strong> getAge() {
    <strong class="hl-keyword">return</strong> age;
}

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">double</strong> getSalary() {
    <strong class="hl-keyword">return</strong> salary;
}

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">boolean</strong> isActive() {
    <strong class="hl-keyword">return</strong> active;
}
}
</pre><p>Now you are looking for the employees who are active and with age less than 30.
        Hazelcast allows you to find these entries in two different ways:
    </p><p>
        <span class="bold"><strong>Distributed SQL Query</strong></span>
    </p><p>
        <code class="literal">SqlPredicate</code>
        takes regular SQL where clause. Here is an example:
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.IMap;
<strong class="hl-keyword">import</strong> com.hazelcast.query.SqlPredicate;

Config cfg = <strong class="hl-keyword">new</strong> Config();
HazelcastInstance hz = Hazelcast.newHazelcastInstance(cfg);
IMap map = hz.getMap(<font font-style="normal" color="#008000">"employee"</font>);

Set&lt;Employee&gt; employees = (Set&lt;Employee&gt;) map.values(<strong class="hl-keyword">new</strong> SqlPredicate(<font font-style="normal" color="#008000">"active AND age &lt; 30"</font>));
</pre><p>
        Supported SQL syntax:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>AND/OR
                    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>
                                <code class="literal">&lt;expression&gt; AND &lt;expression&gt; AND
                                    &lt;expression&gt;...
                                </code>
                                </p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem"><p>
                                            <code class="literal">active AND age&gt;30</code>
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">active=false OR age = 45 OR name =
                                                'Joe'
                                            </code>
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">active AND (age &gt;20 OR salary &lt;
                                                60000)
                                            </code>
                                        </p></li></ul></div><p>
                            </p></li></ul></div><p>
                </p></li><li class="listitem"><p>
                    <code class="literal">=, !=, &lt;, &lt;=, &gt;, &gt;=</code>
                    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>
                                <code class="literal">&lt;expression&gt; = value</code>
                                </p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem"><p>
                                            <code class="literal">age &lt;= 30</code>
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">name ='Joe'</code>
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">salary != 50000</code>
                                        </p></li></ul></div><p>
                            </p></li></ul></div><p>
                </p></li><li class="listitem"><p>BETWEEN
                    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>
                                <code class="literal">&lt;attribute&gt; [NOT] BETWEEN &lt;value1&gt; AND
                                    &lt;value2&gt;</code>
                                </p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem"><p>
                                            <code class="literal">age BETWEEN 20 AND 33 (same as age &gt;=20
                                                AND age&lt;=33)
                                            </code>
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">age NOT BETWEEN 30 AND 40 (same as age
                                                &lt;30 OR age&gt;40)
                                            </code>
                                        </p></li></ul></div><p>
                            </p></li></ul></div><p>
                </p></li><li class="listitem"><p>LIKE
                    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>
                                <code class="literal">&lt;attribute&gt; [NOT] LIKE 'expression'</code>
                            </p><p>
                                <code class="literal">%</code>
                                (percentage sign) is placeholder for many
                                characters,
                                <code class="literal">_</code>
                                (underscore) is placeholder for
                                only one character.
                                <code class="literal">\</code>(Backslash) is used to escape these characters
                                </p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem"><p>
                                            <code class="literal">name LIKE 'Jo%'</code>
                                            (true for 'Joe',
                                            'Josh', 'Joseph' etc.)
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">name LIKE 'Jo_'</code>
                                            (true for 'Joe';
                                            false for 'Josh')
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">name NOT LIKE 'Jo_'</code>
                                            (true for
                                            'Josh'; false for 'Joe')
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">name LIKE 'J_s%'</code>
                                            (true for
                                            'Josh', 'Joseph'; false 'John', 'Joe')
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">name LIKE 'J\%'</code>
                                            (true for 'J%')
                                        </p></li></ul></div><p>
                            </p></li></ul></div><p>
                </p></li><li class="listitem"><p>IN
                    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>
                                <code class="literal">&lt;attribute&gt; [NOT] IN (val1, val2,
                                    ...)
                                </code>
                                </p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem"><p>
                                            <code class="literal">age IN (20, 30, 40)</code>
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">age NOT IN (60, 70)</code>
                                        </p></li></ul></div><p>
                            </p></li></ul></div><p>
                </p></li><li class="listitem"><p>Please note that single quote character should be escaped using two consecutive quotes in a quoted string , example: "text = 'name''s'"  ,  "adv = 'He''s brave, I''m strong'"

                </p></li></ul></div><p>
        Examples:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    <code class="literal">active AND (salary &gt;= 50000 OR (age NOT BETWEEN 20 AND
                        30))
                    </code>
                </p></li><li class="listitem"><p>
                    <code class="literal">age IN (20, 30, 40) AND salary BETWEEN (50000, 80000)</code>
                </p></li></ul></div><p>
    </p><p>
        <span class="bold"><strong>Criteria API</strong></span>
    </p><p>If SQL is not enough or programmable queries are preferred then JPA criteria like API
        can be used. Here is an example:
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.IMap;
<strong class="hl-keyword">import</strong> com.hazelcast.query.Predicate;
<strong class="hl-keyword">import</strong> com.hazelcast.query.PredicateBuilder;
<strong class="hl-keyword">import</strong> com.hazelcast.query.EntryObject;
<strong class="hl-keyword">import</strong> com.hazelcast.config.Config;


Config cfg = <strong class="hl-keyword">new</strong> Config();
HazelcastInstance hz = Hazelcast.newHazelcastInstance(cfg);
IMap map = hz.getMap(<font font-style="normal" color="#008000">"employee"</font>);

EntryObject e = <strong class="hl-keyword">new</strong> PredicateBuilder().getEntryObject();
Predicate predicate = e.is(<font font-style="normal" color="#008000">"active"</font>).and(e.get(<font font-style="normal" color="#008000">"age"</font>).lessThan(<span class="hl-number">30</span>));

Set&lt;Employee&gt; employees = (Set&lt;Employee&gt;) map.values(predicate);

</pre><p>
    </p></div><div class="sect2" title="2.1.5.&nbsp;Indexing"><div class="titlepage"><div><div><h3 class="title"><a name="MapIndex"></a>2.1.5.&nbsp;Indexing</h3></div></div></div><p>
        Hazelcast distributed queries will run on each member in parallel and only results
        will return the conn. When a query runs on a member, Hazelcast will iterate through
        the entire owned entries and find the matching ones. Can we make this even faster? Yes
        by indexing the mostly queried fields. Just like you would do for your database. Of
        course, indexing will add overhead for each
        <code class="literal">write</code>
        operation but
        queries will be a lot faster. If you are querying your map a lot then make sure to add
        indexes for most frequently queried fields. So if your
        <code class="literal">active and age &lt;
            30
        </code>
        query, for example, is used a lot then make sure you add index for
        <code class="literal">active</code>
        and
        <code class="literal">age</code>
        fields. Here is how:
        </p><pre class="programlisting">IMap imap = Hazelcast.getMap(<font font-style="normal" color="#008000">"employees"</font>);
imap.addIndex(<font font-style="normal" color="#008000">"age"</font>, true);        <em class="hl-comment" style="color: silver">// ordered, since we have ranged queries for this field</em>
imap.addIndex(<font font-style="normal" color="#008000">"active"</font>, false);    <em class="hl-comment" style="color: silver">// not ordered, because boolean field cannot have range</em>
</pre><p>
        API
        <code class="literal">IMap.addIndex(fieldName, ordered)</code>
        is used for adding
        index. For a each indexed field, if you have -ranged- queries such
        as<code class="literal">age&gt;30</code>,
        <code class="literal">age BETWEEN 40 AND 60</code>
        then
        <code class="literal">ordered</code>
        parameter should be<code class="literal">true</code>, otherwise set
        it to<code class="literal">false</code>.
    </p><p>
        Also you can define
        <code class="code">IMap</code>
        indexes in configuration.
    </p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    <span class="italic">Hazelcast XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;indexes&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;index</font> <font font-style="bold" color="#0A1777">ordered</font>=<font font-style="bold" color="#008000">"false"</font><font font-style="bold" color="#0A1777">&gt;</font>name<font font-style="bold" color="#0A1777">&lt;/index&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;index</font> <font font-style="bold" color="#0A1777">ordered</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>age<font font-style="bold" color="#0A1777">&lt;/index&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/indexes&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/map&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="italic">Config API</span>
                    </p><pre class="programlisting">
mapConfig.addMapIndexConfig(<strong class="hl-keyword">new</strong> MapIndexConfig(<font font-style="normal" color="#008000">"name"</font>, false));
mapConfig.addMapIndexConfig(<strong class="hl-keyword">new</strong> MapIndexConfig(<font font-style="normal" color="#008000">"age"</font>, true));
                    </pre><p>
                </p></li><li class="listitem"><p>
                    <span class="italic">Spring XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hz:map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:indexes&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:index</font> <font font-style="bold" color="#0A1777">attribute</font>=<font font-style="bold" color="#008000">"name"</font><font font-style="bold" color="#0A1777">/&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:index</font> <font font-style="bold" color="#0A1777">attribute</font>=<font font-style="bold" color="#008000">"age"</font> <font font-style="bold" color="#0A1777">ordered</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/hz:indexes&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hz:map&gt;</font></pre><p>
                </p></li></ul></div><p>
    </p></div><div class="sect2" title="2.1.6.&nbsp;Continuous Query"><div class="titlepage"><div><div><h3 class="title"><a name="MapContinuousQuery"></a>2.1.6.&nbsp;Continuous Query</h3></div></div></div><p>
        One of the new features of version 3.0 is the continuous query.
        You can listen map entry events providing a predicate and so event will be fired for each entry validated by your query.
        IMap has a single method for listening map providing query.
        </p><pre class="programlisting">
    <strong class="hl-tag" style="color: blue">/**
     * Adds an continuous entry listener for this map. Listener will get notified
     * for map add/remove/update/evict events filtered by given predicate.
     *
     * @param listener  entry listener
     * @param predicate predicate for filtering entries
     */</strong>
    <strong class="hl-keyword">void</strong> addEntryListener(EntryListener&lt;K, V&gt; listener, Predicate&lt;K, V&gt; predicate, K key, <strong class="hl-keyword">boolean</strong> includeValue);
                </pre><p>
    </p></div><div class="sect2" title="2.1.7.&nbsp;Entry Processor"><div class="titlepage"><div><div><h3 class="title"><a name="MapEntryProcessor"></a>2.1.7.&nbsp;Entry Processor</h3></div></div></div><p>Starting with version 3.0, Hazelcast supports entry processing. The interface EntryProcessor gives you the ability
        to execute your code on an entry in an atomic way. You do not need any explicit lock on entry.
        Practically, hazelcast locks the entry runs the EntryProcessor, then unlocks the entry.
        If entry processing is the major operation for a map and the map consists of complex objects then using Object type as in-memory-format
        is recommended to minimize serialization cost.
    </p><p>
        There are two methods in IMap interface for entry processing:
        </p><pre class="programlisting"><strong class="hl-tag" style="color: blue">/**
     * Applies the user defined EntryProcessor to the entry mapped by the key.
     * Returns the the object which is result of the process() method of EntryProcessor.
     * &lt;p/&gt;
     *
     * @return result of entry process.
     */</strong>
    Object executeOnKey(K key, EntryProcessor entryProcessor);


    <strong class="hl-tag" style="color: blue">/**
     * Applies the user defined EntryProcessor to the all entries in the map.
     * Returns the results mapped by each key in the map.
     * &lt;p/&gt;
     *
     */</strong>
    Map&lt;K,Object&gt; executeOnAllKeys(EntryProcessor entryProcessor);

</pre><p>
        Using executeOnEntries method, if the number of entries is high
        and you do need the results then returing null in process(..) method is a good practice.
    </p><p>
        Here EntryProcessor interface:
        </p><pre class="programlisting"><strong class="hl-keyword">public</strong> <strong class="hl-keyword">interface</strong> EntryProcessor&lt;K, V&gt; <strong class="hl-keyword">extends</strong> Serializable {

    Object process(Map.Entry&lt;K, V&gt; entry);

    EntryBackupProcessor&lt;K, V&gt; getBackupProcessor();
}
</pre><p>
        If your code is modifying the data then you should also provide a processor for backup entries:
        </p><pre class="programlisting"><strong class="hl-keyword">public</strong> <strong class="hl-keyword">interface</strong> EntryBackupProcessor&lt;K, V&gt; <strong class="hl-keyword">extends</strong> Serializable {

    <strong class="hl-keyword">void</strong> processBackup(Map.Entry&lt;K, V&gt; entry);
}
</pre><p>

                </p><p>
        Also you can remove entry while processing in entry processor. You should just set null for the processed entry's value.
    </p><p>
        <span class="bold"><strong>Example Usage:</strong></span>
        </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> EntryProcessorTest {

    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> testMapEntryProcessor() <strong class="hl-keyword">throws</strong> InterruptedException {
        Config cfg = <strong class="hl-keyword">new</strong> Config();
        cfg.getMapConfig(<font font-style="normal" color="#008000">"default"</font>).setInMemoryFormat(MapConfig.InMemoryFormat.OBJECT);
        HazelcastInstance instance1 = Hazelcast.newHazelcastInstance(cfg);
        HazelcastInstance instance2 = Hazelcast.newHazelcastInstance(cfg);
        IMap&lt;Integer, Integer&gt; map = instance1.getMap(<font font-style="normal" color="#008000">"testMapEntryProcessor"</font>);
        map.put(<span class="hl-number">1</span>, <span class="hl-number">1</span>);
        EntryProcessor entryProcessor = <strong class="hl-keyword">new</strong> IncrementorEntryProcessor();
        map.executeOnKey(<span class="hl-number">1</span>, entryProcessor);
        assertEquals(map.get(<span class="hl-number">1</span>), (Object) <span class="hl-number">2</span>);
        instance1.getLifecycleService().shutdown();
        instance2.getLifecycleService().shutdown();
    }


    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> testMapEntryProcessorAllKeys() <strong class="hl-keyword">throws</strong> InterruptedException {
        StaticNodeFactory nodeFactory = <strong class="hl-keyword">new</strong> StaticNodeFactory(<span class="hl-number">2</span>);
        Config cfg = <strong class="hl-keyword">new</strong> Config();
        cfg.getMapConfig(<font font-style="normal" color="#008000">"default"</font>).setInMemoryFormat(MapConfig.InMemoryFormat.OBJECT);
        HazelcastInstance instance1 = nodeFactory.newHazelcastInstance(cfg);
        HazelcastInstance instance2 = nodeFactory.newHazelcastInstance(cfg);
        IMap&lt;Integer, Integer&gt; map = instance1.getMap(<font font-style="normal" color="#008000">"testMapEntryProcessorAllKeys"</font>);
        <strong class="hl-keyword">int</strong> size = <span class="hl-number">100</span>;
        <strong class="hl-keyword">for</strong> (<strong class="hl-keyword">int</strong> i = <span class="hl-number">0</span>; i &lt; size; i++) {
            map.put(i, i);
        }
        EntryProcessor entryProcessor = <strong class="hl-keyword">new</strong> IncrementorEntryProcessor();
        Map&lt;Integer, Object&gt; res = map.executeOnAllKeys(entryProcessor);
        <strong class="hl-keyword">for</strong> (<strong class="hl-keyword">int</strong> i = <span class="hl-number">0</span>; i &lt; size; i++) {
            assertEquals(map.get(i), (Object) (i+<span class="hl-number">1</span>));
        }
        <strong class="hl-keyword">for</strong> (<strong class="hl-keyword">int</strong> i = <span class="hl-number">0</span>; i &lt; size; i++) {
            assertEquals(map.get(i)+<span class="hl-number">1</span>, res.get(i));
        }
        instance1.getLifecycleService().shutdown();
        instance2.getLifecycleService().shutdown();
    }

    <strong class="hl-keyword">static</strong> <strong class="hl-keyword">class</strong> IncrementorEntryProcessor <strong class="hl-keyword">implements</strong> EntryProcessor, EntryBackupProcessor, Serializable {
        <strong class="hl-keyword">public</strong> Object process(Map.Entry entry) {
            Integer value = (Integer) entry.getValue();
            entry.setValue(value + <span class="hl-number">1</span>);
            <strong class="hl-keyword">return</strong> value + <span class="hl-number">1</span>;
        }

        <strong class="hl-keyword">public</strong> EntryBackupProcessor getBackupProcessor() {
            <strong class="hl-keyword">return</strong> IncrementorEntryProcessor.<strong class="hl-keyword">this</strong>;
        }

        <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> processBackup(Map.Entry entry) {
            entry.setValue((Integer) entry.getValue() + <span class="hl-number">1</span>);
        }
    }


}

</pre><p>
    </p></div><div class="sect2" title="2.1.8.&nbsp;Interceptors"><div class="titlepage"><div><div><h3 class="title"><a name="MapInterceptor"></a>2.1.8.&nbsp;Interceptors</h3></div></div></div><p>
        Another new feature with version 3.0 is the interceptors.
        You can add intercept operations and execute your own business logic synchronously blocking the operation.
        You can change the returned value from a get operation, change the value to be put or cancel operations by throwing exception.
    </p><p>
        Interceptors are different from listeners as with listeners you just take an action after the operation has been completed.
        Interceptor actions are synchronous and you can alter the behaviour of operation, change the values or totally cancel it.
    </p><p>
        IMap API has two method for adding and removing interceptor to the map.
        </p><pre class="programlisting">
    <strong class="hl-tag" style="color: blue">/**
     * Adds an interceptor for this map. Added interceptor will intercept operations
     * and execute user defined methods and will cancel operations if user defined method throw exception.
     * &lt;p/&gt;
     *
     * @param interceptor map interceptor
     * @return id of registered interceptor
     */</strong>
    String addInterceptor(MapInterceptor interceptor);

    <strong class="hl-tag" style="color: blue">/**
     * Removes the given interceptor for this map. So it will not intercept operations anymore.
     * &lt;p/&gt;
     *
     * @param id registration id of map interceptor
     */</strong>
    <strong class="hl-keyword">void</strong> removeInterceptor(String id);

</pre><p>

    </p><p>
        Here MapInterceptor interface:
        </p><pre class="programlisting">

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">interface</strong> MapInterceptor <strong class="hl-keyword">extends</strong> Serializable {

    <strong class="hl-tag" style="color: blue">/**
     * Intercept get operation before returning value.
     * Return another object to change the return value of get(..)
     * Returning null will cause the get(..) operation return original value, namely return null if you do not want to change anything.
     * &lt;p/&gt;
     *
     * @param value the original value to be returned as the result of get(..) operation
     * @return the new value that will be returned by get(..) operation
     */</strong>
    Object interceptGet(Object value);

    <strong class="hl-tag" style="color: blue">/**
     * Called after get(..) operation is completed.
     * &lt;p/&gt;
     *
     * @param value the value returned as the result of get(..) operation
     */</strong>
    <strong class="hl-keyword">void</strong> afterGet(Object value);

    <strong class="hl-tag" style="color: blue">/**
     * Intercept put operation before modifying map data.
     * Return the object to be put into the map.
     * Returning null will cause the put(..) operation to operate as expected, namely no interception.
     * Throwing an exception will cancel the put operation.
     * &lt;p/&gt;
     *
     * @param oldValue the value currently in map
     * @param newValue the new value to be put
     * @return new value after intercept operation
     */</strong>
    Object interceptPut(Object oldValue, Object newValue);

    <strong class="hl-tag" style="color: blue">/**
     * Called after put(..) operation is completed.
     * &lt;p/&gt;
     *
     * @param value the value returned as the result of put(..) operation
     */</strong>
    <strong class="hl-keyword">void</strong> afterPut(Object value);

    <strong class="hl-tag" style="color: blue">/**
     * Intercept remove operation before removing the data.
     * Return the object to be returned as the result of remove operation.
     * Throwing an exception will cancel the remove operation.
     * &lt;p/&gt;
     *
     * @param removedValue the existing value to be removed
     * @return the value to be returned as the result of remove operation
     */</strong>
    Object interceptRemove(Object removedValue);

    <strong class="hl-tag" style="color: blue">/**
     * Called after remove(..) operation is completed.
     * &lt;p/&gt;
     *
     * @param value the value returned as the result of remove(..) operation
     */</strong>
    <strong class="hl-keyword">void</strong> afterRemove(Object value);

}
</pre><p>
                </p><p>
        <span class="bold"><strong>Example Usage:</strong></span>
        </p><pre class="programlisting">

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> InterceptorTest {
    <strong class="hl-keyword">final</strong> String mapName = <font font-style="normal" color="#008000">"map"</font>;


    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> testMapInterceptor() <strong class="hl-keyword">throws</strong> InterruptedException {
        Config cfg = <strong class="hl-keyword">new</strong> Config();
        HazelcastInstance instance1 = Hazelcast.newHazelcastInstance(cfg);
        HazelcastInstance instance2 = Hazelcast.newHazelcastInstance(cfg);
        <strong class="hl-keyword">final</strong> IMap&lt;Object, Object&gt; map = instance1.getMap(<font font-style="normal" color="#008000">"testMapInterceptor"</font>);
        SimpleInterceptor interceptor = <strong class="hl-keyword">new</strong> SimpleInterceptor();
        map.addInterceptor(interceptor);
        map.put(<span class="hl-number">1</span>, <font font-style="normal" color="#008000">"New York"</font>);
        map.put(<span class="hl-number">2</span>, <font font-style="normal" color="#008000">"Istanbul"</font>);
        map.put(<span class="hl-number">3</span>, <font font-style="normal" color="#008000">"Tokyo"</font>);
        map.put(<span class="hl-number">4</span>, <font font-style="normal" color="#008000">"London"</font>);
        map.put(<span class="hl-number">5</span>, <font font-style="normal" color="#008000">"Paris"</font>);
        map.put(<span class="hl-number">6</span>, <font font-style="normal" color="#008000">"Cairo"</font>);
        map.put(<span class="hl-number">7</span>, <font font-style="normal" color="#008000">"Hong Kong"</font>);

        <strong class="hl-keyword">try</strong> {
            map.remove(<span class="hl-number">1</span>);
        } <strong class="hl-keyword">catch</strong> (Exception ignore) {
        }
        <strong class="hl-keyword">try</strong> {
            map.remove(<span class="hl-number">2</span>);
        } <strong class="hl-keyword">catch</strong> (Exception ignore) {
        }

        assertEquals(map.size(), <span class="hl-number">6</span>);

        assertEquals(map.get(<span class="hl-number">1</span>), null);
        assertEquals(map.get(<span class="hl-number">2</span>), <font font-style="normal" color="#008000">"ISTANBUL:"</font>);
        assertEquals(map.get(<span class="hl-number">3</span>), <font font-style="normal" color="#008000">"TOKYO:"</font>);
        assertEquals(map.get(<span class="hl-number">4</span>), <font font-style="normal" color="#008000">"LONDON:"</font>);
        assertEquals(map.get(<span class="hl-number">5</span>), <font font-style="normal" color="#008000">"PARIS:"</font>);
        assertEquals(map.get(<span class="hl-number">6</span>), <font font-style="normal" color="#008000">"CAIRO:"</font>);
        assertEquals(map.get(<span class="hl-number">7</span>), <font font-style="normal" color="#008000">"HONG KONG:"</font>);

        map.removeInterceptor(interceptor);
        map.put(<span class="hl-number">8</span>, <font font-style="normal" color="#008000">"Moscow"</font>);

        assertEquals(map.get(<span class="hl-number">8</span>), <font font-style="normal" color="#008000">"Moscow"</font>);
        assertEquals(map.get(<span class="hl-number">1</span>), null);
        assertEquals(map.get(<span class="hl-number">2</span>), <font font-style="normal" color="#008000">"ISTANBUL"</font>);
        assertEquals(map.get(<span class="hl-number">3</span>), <font font-style="normal" color="#008000">"TOKYO"</font>);
        assertEquals(map.get(<span class="hl-number">4</span>), <font font-style="normal" color="#008000">"LONDON"</font>);
        assertEquals(map.get(<span class="hl-number">5</span>), <font font-style="normal" color="#008000">"PARIS"</font>);
        assertEquals(map.get(<span class="hl-number">6</span>), <font font-style="normal" color="#008000">"CAIRO"</font>);
        assertEquals(map.get(<span class="hl-number">7</span>), <font font-style="normal" color="#008000">"HONG KONG"</font>);

    }

    <strong class="hl-keyword">static</strong> <strong class="hl-keyword">class</strong> SimpleInterceptor <strong class="hl-keyword">implements</strong> MapInterceptor, Serializable {

        <em><span class="hl-annotation" style="color: gray">@Override</span></em>
        <strong class="hl-keyword">public</strong> Object interceptGet(Object value) {
            <strong class="hl-keyword">if</strong>(value == null)
                <strong class="hl-keyword">return</strong> null;
            <strong class="hl-keyword">return</strong> value + <font font-style="normal" color="#008000">":"</font>;
        }

        <em><span class="hl-annotation" style="color: gray">@Override</span></em>
        <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> afterGet(Object value) {
        }

        <em><span class="hl-annotation" style="color: gray">@Override</span></em>
        <strong class="hl-keyword">public</strong> Object interceptPut(Object oldValue, Object newValue) {
            <strong class="hl-keyword">return</strong> newValue.toString().toUpperCase();
        }

        <em><span class="hl-annotation" style="color: gray">@Override</span></em>
        <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> afterPut(Object value) {
        }

        <em><span class="hl-annotation" style="color: gray">@Override</span></em>
        <strong class="hl-keyword">public</strong> Object interceptRemove(Object removedValue) {
            <strong class="hl-keyword">if</strong>(removedValue.equals(<font font-style="normal" color="#008000">"ISTANBUL"</font>))
                <strong class="hl-keyword">throw</strong> <strong class="hl-keyword">new</strong> RuntimeException(<font font-style="normal" color="#008000">"you can not remove this"</font>);
            <strong class="hl-keyword">return</strong> removedValue;
        }

        <em><span class="hl-annotation" style="color: gray">@Override</span></em>
        <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> afterRemove(Object value) {
            <em class="hl-comment" style="color: silver">// do something</em>
        }
    }
}

</pre><p>
    </p></div><div class="sect2" title="2.1.9.&nbsp;Near Cache"><div class="titlepage"><div><div><h3 class="title"><a name="MapNearCache"></a>2.1.9.&nbsp;Near Cache</h3></div></div></div><p>Map entries in Hazelcast are partitioned across the cluster. Imagine that you are
        reading key
        <code class="literal">k</code>
        so many times and
        <code class="literal">k</code>
        is owned by another member in your cluster. Each
        <code class="literal">map.get(k)</code>
        will
        be a remote operation; lots of network trips.
        If you have a map that is read-mostly then you should consider creating a
        <code class="literal">Near Cache</code>
        for the map so that reads can be much faster and consume less network traffic.
        All these benefits don't come free. When using near cache, you should consider the following issues:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>JVM will have to hold extra cached data so it will increase the memory consumption.
                </p></li><li class="listitem"><p>If invalidation is turned on and entries are updated frequently, then invalidations will be
                    costly.
                </p></li><li class="listitem"><p>Near cache breaks the strong consistency guarantees; you might be reading stale data.
                </p></li></ul></div><p>
        Near cache is highly recommended for the maps that are read-mostly.
        Here is a near-cache configuration for a map :
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"my-read-mostly-map"</font><font font-style="bold" color="#0A1777">&gt;</font>
        ...
        <font font-style="bold" color="#0A1777">&lt;near-cache&gt;</font>
            <em class="hl-comment" style="color: silver">&lt;!--
                Maximum size of the near cache. When max size is reached,
                cache is evicted based on the policy defined.
                Any integer between 0 and Integer.MAX_VALUE. 0 means
                Integer.MAX_VALUE. Default is 0.
            --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;max-size&gt;</font>5000<font font-style="bold" color="#0A1777">&lt;/max-size&gt;</font>
            <em class="hl-comment" style="color: silver">&lt;!--
                Maximum number of seconds for each entry to stay in the near cache. Entries that are
                older than &lt;time-to-live-seconds&gt; will get automatically evicted from the near cache.
                Any integer between 0 and Integer.MAX_VALUE. 0 means infinite. Default is 0.
            --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;time-to-live-seconds&gt;</font>0<font font-style="bold" color="#0A1777">&lt;/time-to-live-seconds&gt;</font>

            <em class="hl-comment" style="color: silver">&lt;!--
                Maximum number of seconds each entry can stay in the near cache as untouched (not-read).
                Entries that are not read (touched) more than &lt;max-idle-seconds&gt; value will get removed
                from the near cache.
                Any integer between 0 and Integer.MAX_VALUE. 0 means
                Integer.MAX_VALUE. Default is 0.
            --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;max-idle-seconds&gt;</font>60<font font-style="bold" color="#0A1777">&lt;/max-idle-seconds&gt;</font>

            <em class="hl-comment" style="color: silver">&lt;!--
                Valid values are:
                NONE (no extra eviction, &lt;time-to-live-seconds&gt; may still apply),
                LRU  (Least Recently Used),
                LFU  (Least Frequently Used).
                NONE is the default.
                Regardless of the eviction policy used, &lt;time-to-live-seconds&gt; will still apply.
            --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;eviction-policy&gt;</font>LRU<font font-style="bold" color="#0A1777">&lt;/eviction-policy&gt;</font>

            <em class="hl-comment" style="color: silver">&lt;!--
                Should the cached entries get evicted if the entries are changed (updated or removed).
                true of false. Default is true.
            --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;invalidate-on-change&gt;</font>true<font font-style="bold" color="#0A1777">&lt;/invalidate-on-change&gt;</font>

        <font font-style="bold" color="#0A1777">&lt;/near-cache&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/map&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>

    </p></div><div class="sect2" title="2.1.10.&nbsp;Entry Statistics"><div class="titlepage"><div><div><h3 class="title"><a name="MapEntry"></a>2.1.10.&nbsp;Entry Statistics</h3></div></div></div><p>
        Hazelcast keeps extra information about each map entry such as creationTime, lastUpdateTime, lastAccessTime,
        number of hits, version, and this information is exposed to the developer via
        <code class="literal">IMap.getMapEntry(key)</code>
        call. Here is
        an example:
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> com.hazelcast.core.EntryView;

Config cfg = <strong class="hl-keyword">new</strong> Config();
HazelcastInstance hz = Hazelcast.newHazelcastInstance(cfg);
EntryView entry = hz.getMap(<font font-style="normal" color="#008000">"quotes"</font>).getEntryView(<font font-style="normal" color="#008000">"1"</font>);
System.out.println (<font font-style="normal" color="#008000">"size in memory  : "</font> + entry.getCost();
System.out.println (<font font-style="normal" color="#008000">"creationTime    : "</font> + entry.getCreationTime();
System.out.println (<font font-style="normal" color="#008000">"expirationTime  : "</font> + entry.getExpirationTime();
System.out.println (<font font-style="normal" color="#008000">"number of hits  : "</font> + entry.getHits();
System.out.println (<font font-style="normal" color="#008000">"lastAccessedTime: "</font> + entry.getLastAccessTime();
System.out.println (<font font-style="normal" color="#008000">"lastUpdateTime  : "</font> + entry.getLastUpdateTime();
System.out.println (<font font-style="normal" color="#008000">"version         : "</font> + entry.getVersion();
System.out.println (<font font-style="normal" color="#008000">"key             : "</font> + entry.getKey();
System.out.println (<font font-style="normal" color="#008000">"value           : "</font> + entry.getValue();
</pre><p>
    </p></div><div class="sect2" title="2.1.11.&nbsp;In Memory Format"><div class="titlepage"><div><div><h3 class="title"><a name="MapInMemoryFormat"></a>2.1.11.&nbsp;In Memory Format</h3></div></div></div><p>
        With version 3.0, in-memory-format configuration option has been added to distributed map.
        By default Hazelcast stores data into memory in binary (serialized) format.
        But sometimes it can be efficient to store the entries in their objects form especially in cases of local processing like entry processor and queries.
        Setting in-memory-format in map's configuration, you can decide how the data will be store in memory.
        There are three options.
    </p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    <span class="bold"><strong>BINARY (default):</strong></span>This is the default option. Data will be stored in serialized binary format.
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>OBJECT:</strong></span>Data will be stored in de-serialized form.
                        This configuration is good for maps where entry processing and queries form the majority of all operations
                        and the objects are complex ones so serialization cost is respectively high.
                        By storing objects, entry processing will not contain the de-serialization cost.
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>OFFHEAP:</strong></span>Data will be stored in non-heap region of JVM to avoid GC pauses.
                    This option is available for only Hazelcast Enterprise Edition.
                </p></li></ul></div><p>
    </p></div><p>
    <span class="bold"><strong>To learn about wildcard configuration feature, see
        <a class="link" href="ch14s05.html" title="14.5.&nbsp;Wildcard Configuration">Wildcard Configuration
        </a>
        page.
    </strong></span>
</p></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch01s04.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a accesskey="n" href="ch02s02.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">1.4.&nbsp;Getting Started (Tutorial)&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;2.2.&nbsp;Distributed Queue</td></tr></table></div></body></html>