<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>In-Memory Data Grid - Hazelcast | Documentation</title><link rel="stylesheet" type="text/css" href="./docbook.css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"><meta name="keywords" content="hazelcast, distributed, cache, distributed cache, cluster, data grid, in-memory data grid"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="book" title="In-Memory Data Grid - Hazelcast | Documentation"><div class="titlepage"><div><div><h1 class="title"><a name="d0e2"></a>In-Memory Data Grid - Hazelcast | Documentation</h1></div><div><h2 class="subtitle">version 3.1.4</h2></div><div><p class="copyright">Copyright &copy; 2013 Hazelcast, Inc.</p></div><div><div class="legalnotice" title="Legal Notice"><a name="d0e15"></a><p>Permission to use, copy, modify and distribute
                this document for any purpose and
                without fee is hereby granted in perpetuity, provided that the above
                copyright notice and this paragraph appear in all copies.
            </p></div></div><div><p class="pubdate">10 January 2014 </p></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="chapter"><a href="#Introduction">1. Introduction</a></span></dt><dd><dl><dt><span class="sect1"><a href="#WhatsNew31">1.1. What's new in 3.1?</a></span></dt><dt><span class="sect1"><a href="#WhatsNew3">1.2. What's new in 3.0?</a></span></dt><dt><span class="sect1"><a href="#MigratingTo3">1.3. Upgrading from 2.x versions</a></span></dt><dt><span class="sect1"><a href="#GettingStarted">1.4. Getting Started (Tutorial)</a></span></dt></dl></dd><dt><span class="chapter"><a href="#DDS">2. Distributed Data Structures</a></span></dt><dd><dl><dt><span class="sect1"><a href="#Map">2.1. Distributed Map</a></span></dt><dd><dl><dt><span class="sect2"><a href="#MapBackup">2.1.1. Backups</a></span></dt><dt><span class="sect2"><a href="#MapEviction">2.1.2. Eviction</a></span></dt><dt><span class="sect2"><a href="#MapPersistence">2.1.3. Persistence</a></span></dt><dt><span class="sect2"><a href="#MapQuery">2.1.4. Query</a></span></dt><dt><span class="sect2"><a href="#MapIndex">2.1.5. Indexing</a></span></dt><dt><span class="sect2"><a href="#MapContinuousQuery">2.1.6. Continuous Query</a></span></dt><dt><span class="sect2"><a href="#MapEntryProcessor">2.1.7. Entry Processor</a></span></dt><dt><span class="sect2"><a href="#MapInterceptor">2.1.8. Interceptors</a></span></dt><dt><span class="sect2"><a href="#MapNearCache">2.1.9. Near Cache</a></span></dt><dt><span class="sect2"><a href="#MapEntry">2.1.10. Entry Statistics</a></span></dt><dt><span class="sect2"><a href="#MapInMemoryFormat">2.1.11. In Memory Format</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Queue">2.2. Distributed Queue</a></span></dt><dd><dl><dt><span class="sect2"><a href="#QueuePersistence">2.2.1. Persistence</a></span></dt></dl></dd><dt><span class="sect1"><a href="#MultiMap">2.3. Distributed MultiMap</a></span></dt><dt><span class="sect1"><a href="#Topic">2.4. Distributed Topic</a></span></dt><dt><span class="sect1"><a href="#Set">2.5. Distributed Set</a></span></dt><dt><span class="sect1"><a href="#List">2.6. Distributed List</a></span></dt><dt><span class="sect1"><a href="#Lock">2.7. Distributed Lock</a></span></dt><dt><span class="sect1"><a href="#Events">2.8. Distributed Events</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Serialization">3. Serialization</a></span></dt><dd><dl><dt><span class="sect1"><a href="#DataSerializable">3.1. Data Serializable</a></span></dt><dt><span class="sect1"><a href="#PortableSerialization">3.2. Portable Serialization</a></span></dt><dt><span class="sect1"><a href="#CustomSerialization">3.3. Custom Serialization</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ElasticMemory">4. Elastic Memory
            <sup>(Enterprise Edition Only)</sup>
        </a></span></dt><dt><span class="chapter"><a href="#Security">5. Security
            <sup>(Enterprise Edition Only)</sup>
        </a></span></dt><dd><dl><dt><span class="sect1"><a href="#Credentials">5.1. Credentials</a></span></dt><dt><span class="sect1"><a href="#ClusterLoginModule">5.2. ClusterLoginModule</a></span></dt><dt><span class="sect1"><a href="#MemberSecurity">5.3. Cluster Member Security</a></span></dt><dt><span class="sect1"><a href="#ClientSecurity">5.4. Native Client Security</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e2217">5.4.1. Authentication</a></span></dt><dt><span class="sect2"><a href="#d0e2253">5.4.2. Authorization</a></span></dt><dt><span class="sect2"><a href="#d0e2312">5.4.3. Permissions</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#DataAffinity">6. Data Affinity</a></span></dt><dt><span class="chapter"><a href="#JMX">7. Monitoring with JMX</a></span></dt><dt><span class="chapter"><a href="#ClusterUtilities">8. Cluster Utilities</a></span></dt><dd><dl><dt><span class="sect1"><a href="#ClusterInterface">8.1. Cluster Interface</a></span></dt><dt><span class="sect1"><a href="#IdGenerator">8.2. Cluster-wide Id Generator</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Transactions">9. Transactions</a></span></dt><dd><dl><dt><span class="sect1"><a href="#TransactionInterface">9.1. Transaction Interface</a></span></dt><dt><span class="sect1"><a href="#JEEIntegration">9.2. J2EE Integration</a></span></dt><dd><dl><dt><span class="sect2"><a href="#JEEIntegrationConfig">9.2.1. Resource Adapter Configuration</a></span></dt><dt><span class="sect2"><a href="#JEEIntegrationGlassfishSample">9.2.2. Sample Glassfish v3 Web Application Configuration</a></span></dt><dt><span class="sect2"><a href="#JEEIntegrationJBossSample">9.2.3. Sample JBoss Web Application Configuration</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#ExecutorService">10. Distributed Executor Service</a></span></dt><dd><dl><dt><span class="sect1"><a href="#DistributedExecution">10.1. Distributed Execution</a></span></dt><dt><span class="sect1"><a href="#ExecutionCancellation">10.2. Execution Cancellation</a></span></dt><dt><span class="sect1"><a href="#ExecutionCallback">10.3. Execution Callback</a></span></dt></dl></dd><dt><span class="chapter"><a href="#HttpSessionClustering">11. Http Session Clustering with HazelcastWM</a></span></dt><dt><span class="chapter"><a href="#WanReplication">12. WAN Replication</a></span></dt><dt><span class="chapter"><a href="#SPI">13. Service Provider Interface</a></span></dt><dt><span class="chapter"><a href="#Config">14. Configuration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#ConfigGroup">14.1. Creating Separate Clusters</a></span></dt><dt><span class="sect1"><a href="#NetworkConfig">14.2. Network Configuration</a></span></dt><dd><dl><dt><span class="sect2"><a href="#ConfigTcpIp">14.2.1. Configuring TCP/IP Cluster</a></span></dt><dt><span class="sect2"><a href="#ConfigSpecifyInterfaces">14.2.2. Specifying Network Interfaces</a></span></dt><dt><span class="sect2"><a href="#EC2AutoDiscovery">14.2.3. EC2 Auto Discovery</a></span></dt><dt><span class="sect2"><a href="#NetworkPartitioning">14.2.4. Network Partitioning (Split-Brain Syndrome)</a></span></dt><dt><span class="sect2"><a href="#SSL">14.2.5. SSL</a></span></dt><dt><span class="sect2"><a href="#Encryption">14.2.6. Encryption</a></span></dt><dt><span class="sect2"><a href="#SocketInterceptor">14.2.7. Socket Interceptor</a></span></dt><dt><span class="sect2"><a href="#IPv6">14.2.8. IPv6 Support</a></span></dt><dt><span class="sect2"><a href="#OutboundPorts">14.2.9. Restricting Outbound Ports</a></span></dt></dl></dd><dt><span class="sect1"><a href="#PartitionGroupConfig">14.3. Partition Group Configuration</a></span></dt><dt><span class="sect1"><a href="#ListenerConfig">14.4. Listener Configurations</a></span></dt><dt><span class="sect1"><a href="#WildcardConfiguration">14.5. Wildcard Configuration</a></span></dt><dt><span class="sect1"><a href="#ConfigurationProperties">14.6. Advanced Configuration Properties</a></span></dt><dt><span class="sect1"><a href="#Logging">14.7. Logging Configuration</a></span></dt><dt><span class="sect1"><a href="#EnterpriseConfig">14.8. Setting License Key <sup>(Enterprise Edition Only)</sup></a></span></dt></dl></dd><dt><span class="chapter"><a href="#HibernateSecondLevelCache">15. Hibernate Second Level Cache</a></span></dt><dt><span class="chapter"><a href="#SpringIntegration">16. Spring Integration</a></span></dt><dd><dl><dt><span class="sect1"><a href="#SpringConfiguration">16.1. Configuration</a></span></dt><dt><span class="sect1"><a href="#SpringContext">16.2. Spring Managed Context</a></span></dt><dt><span class="sect1"><a href="#SpringCache">16.3. Spring Cache</a></span></dt><dt><span class="sect1"><a href="#SpringHibernate">16.4. Hibernate 2nd Level Cache Config</a></span></dt><dt><span class="sect1"><a href="#SpringJPA">16.5. Spring Data - JPA</a></span></dt><dt><span class="sect1"><a href="#SpringMongoDB">16.6. Spring Data - MongoDB</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Clients">17. Clients</a></span></dt><dd><dl><dt><span class="sect1"><a href="#NativeClient">17.1. Native Client</a></span></dt><dd><dl><dt><span class="sect2"><a href="#JavaClient">17.1.1. Java Client</a></span></dt><dt><span class="sect2"><a href="#CSharpClient">17.1.2. CSharp Client <sup>(Enterprise Edition Only)</sup></a></span></dt></dl></dd><dt><span class="sect1"><a href="#MemcacheClient">17.2. Memcache Client</a></span></dt><dt><span class="sect1"><a href="#RestClient">17.3. Rest Client</a></span></dt></dl></dd><dt><span class="chapter"><a href="#ManagementCenter">18. Management Center</a></span></dt><dd><dl><dt><span class="sect1"><a href="#MC_Intro">18.1. Introduction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#MC_Installation">18.1.1. Installation</a></span></dt><dt><span class="sect2"><a href="#MC_UserAdministration">18.1.2. User Administration</a></span></dt><dt><span class="sect2"><a href="#MC_ToolOverview">18.1.3. Tool Overview</a></span></dt></dl></dd><dt><span class="sect1"><a href="#MC_Maps">18.2. Maps</a></span></dt><dd><dl><dt><span class="sect2"><a href="#MC_MapMonitoring">18.2.1. Monitoring Maps</a></span></dt><dt><span class="sect2"><a href="#MC_MapBrowser">18.2.2. Map Browser</a></span></dt><dt><span class="sect2"><a href="#MC_MapConfiguration">18.2.3. Map Configuration</a></span></dt></dl></dd><dt><span class="sect1"><a href="#MC_Queues">18.3. Queues</a></span></dt><dt><span class="sect1"><a href="#MC_Topics">18.4. Topics</a></span></dt><dt><span class="sect1"><a href="#MC_Members">18.5. Members</a></span></dt><dd><dl><dt><span class="sect2"><a href="#MC_MemberMonitoring">18.5.1. Monitoring</a></span></dt><dt><span class="sect2"><a href="#MC_MemberOperations">18.5.2. Operations</a></span></dt></dl></dd><dt><span class="sect1"><a href="#MC_Logs">18.6. System Logs</a></span></dt><dt><span class="sect1"><a href="#MC_Scripting">18.7. Scripting</a></span></dt><dt><span class="sect1"><a href="#MC_TimeTravel">18.8. Time Travel</a></span></dt><dt><span class="sect1"><a href="#MC_Console">18.9. Console</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Miscellaneous">19. Miscellaneous</a></span></dt><dd><dl><dt><span class="sect1"><a href="#CommonGotchas">19.1. Common Gotchas</a></span></dt><dt><span class="sect1"><a href="#ClusterTestHowTo">19.2. Testing Cluster</a></span></dt><dt><span class="sect1"><a href="#Todo">19.3. Planned Features</a></span></dt></dl></dd></dl></div><div class="list-of-tables"><p><b>List of Tables</b></p><dl><dt>14.1. <a href="#d0e4250">Properties Table</a></dt></dl></div><div class="chapter" title="Chapter&nbsp;1.&nbsp;Introduction"><div class="titlepage"><div><div><h2 class="title"><a name="Introduction"></a>Chapter&nbsp;1.&nbsp;Introduction</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#WhatsNew31">1.1. What's new in 3.1?</a></span></dt><dt><span class="sect1"><a href="#WhatsNew3">1.2. What's new in 3.0?</a></span></dt><dt><span class="sect1"><a href="#MigratingTo3">1.3. Upgrading from 2.x versions</a></span></dt><dt><span class="sect1"><a href="#GettingStarted">1.4. Getting Started (Tutorial)</a></span></dt></dl></div><p>
    Hazelcast is a clustering and highly scalable data distribution platform for Java. Hazelcast helps architects and
    developers to easily design and develop faster, highly scalable and reliable applications for their businesses.
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Distributed implementations of
                <code class="literal">java.util.{Queue, Set, List, Map}</code>
            </p></li><li class="listitem"><p>Distributed implementation of
                <code class="literal">java.util.concurrent.ExecutorService</code>
            </p></li><li class="listitem"><p>Distributed implementation of
                <code class="literal">java.util.concurrency.locks.Lock</code>
            </p></li><li class="listitem"><p>Distributed
                <code class="literal">Topic</code>
                for publish/subscribe messaging
            </p></li><li class="listitem"><p>Transaction support and J2EE container integration via JCA
            </p></li><li class="listitem"><p>Distributed listeners and events
            </p></li><li class="listitem"><p>Support for cluster info and membership events
            </p></li><li class="listitem"><p>Dynamic HTTP session clustering
            </p></li><li class="listitem"><p>Dynamic clustering
            </p></li><li class="listitem"><p>Dynamic scaling to hundreds of servers
            </p></li><li class="listitem"><p>Dynamic partitioning with backups
            </p></li><li class="listitem"><p>Dynamic fail-over
            </p></li></ul></div><p>
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Super simple to use; include a single jar
            </p></li><li class="listitem"><p>Super fast; thousands of operations per sec.
            </p></li><li class="listitem"><p>Super small; less than a MB
            </p></li><li class="listitem"><p>Super efficient; very nice to CPU and RAM
            </p></li></ul></div><p>
    To install Hazelcast:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Download hazelcast-_version_.zip from
                <a class="link" href="http://www.hazelcast.com" target="_top">www.hazelcast.com</a>
            </p></li><li class="listitem"><p>Unzip hazelcast-_version_.zip file
            </p></li><li class="listitem"><p>Add hazelcast-_version_.jar file into your classpath
            </p></li></ul></div><p>
    Hazelcast is pure Java. JVMs that are running Hazelcast will dynamically cluster. Although by default Hazelcast will
    use multicast for discovery, it can also be configured to only use TCP/IP for environments where multicast is not
    available or preferred (<a class="link" href="#ConfigTcpIp" title="14.2.1.&nbsp;Configuring TCP/IP Cluster">Click here for more info</a>). Communication among
    cluster members is always
    TCP/IP with Java NIO beauty. Default configuration comes with 1 backup so if one node fails, no data will be lost.
    It is as simple as using<code class="literal">java.util.{Queue, Set, List, Map}</code>. Just add the hazelcast.jar into your
    classpath and start coding.
</p><div class="sect1" title="1.1.&nbsp;What's new in 3.1?"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="WhatsNew31"></a>1.1.&nbsp;What's new in 3.1?</h2></div></div></div><p>
        <span class="bold"><strong>Elastic Memory<sup>(Enterprise Edition Only)</sup></strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                Elastic Memory is now available.
                For additional info see <a class="link" href="#ElasticMemory" title="Chapter&nbsp;4.&nbsp;Elastic Memory (Enterprise Edition Only)">Elastic Memory</a> section.
            </li></ul></div><p>
    </p><p>
        <span class="bold"><strong>Security<sup>(Enterprise Edition Only)</sup></strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                Hazelcast Security is now available.
                For additional info see <a class="link" href="#Security" title="Chapter&nbsp;5.&nbsp;Security (Enterprise Edition Only)">Security</a> section.
            </li></ul></div><p>
    </p><p>
        <span class="bold"><strong>JCA</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                Hazelcast JCA integration is back. For additional info see <a class="link" href="#JEEIntegration" title="9.2.&nbsp;J2EE Integration">J2EE Integration</a> section.
            </li></ul></div><p>
    </p><p>
        <span class="bold"><strong>Controlled Partitioning</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                Controlled Partitioning is the ability to control the partition of certain DistributedObjects like the IQueue,
                IAtomicLong or ILock. This will make collocating related data easier.

                For additional info see our blog post:
                <a class="link" href="http://blog.hazelcast.com/blog/2013/08/25/controlled-partitioning/" target="_top">Controlled Partitioning</a></li><li class="listitem">
                Hazelcast map also supports custom partitioning strategies. A <code class="code">PartitioningStrategy</code> can be defined
                in map configuration.
            </li></ul></div><p>
    </p><p>
        <span class="bold"><strong>Map</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><code class="code">TransactionalMap</code> now supports <code class="code">keySet()</code>, <code class="code">keySet(predicate)</code>,
                <code class="code">values()</code> and <code class="code">values(predicate)</code> methods.
            </li><li class="listitem">
                Eviction based on <code class="code">USED_HEAP_PERCENTAGE</code> or <code class="code">USED_HEAP_SIZE</code> now takes account
                real heap memory size consumed by map.
            </li><li class="listitem"><code class="code">SqlPredicate</code> now supports '\' as escape character. See <a class="link" href="#MapQuery" title="2.1.4.&nbsp;Query">MapQuery</a> section for more info.
            </li><li class="listitem"><code class="code">SqlPredicate</code> now supports regular expressions using <code class="code">REGEX</code> keyword.
                For example; <code class="code">map.values(new SqlPredicate("name REGEX .*earl$"))</code>
                See <a class="link" href="#MapQuery" title="2.1.4.&nbsp;Query">MapQuery</a> section for more info.
            </li></ul></div><p>
    </p><p>
        <span class="bold"><strong>Queue</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                Hazelcast queue now supports <code class="code">QueueStoreFactory</code> that will be used to create custom <code class="code">QueueStore</code>s
                for persistent queues. <code class="code">QueueStoreFactory</code> is similar to map's <code class="code">MapStoreFactory</code>.
            </li><li class="listitem"><code class="code">TransactionalQueue</code> now supports <code class="code">peek()</code> and <code class="code">peek(timeout, timeunit)</code> methods.
            </li></ul></div><p>
    </p><p>
        <span class="bold"><strong>Client</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                Client now has SSL support. See <a class="link" href="#SSL" title="14.2.5.&nbsp;SSL">SSL</a> section.
            </li><li class="listitem">
                Client also supports custom socket implementations using <code class="code">SocketFactory</code> API.
                A custom socket factory can be defined in <code class="code">ClientConfig</code>;
                <code class="code">clientConfig.getSocketOptions().setSocketFactory(socketFactory)</code>.
            </li></ul></div><p>
    </p><p>
        <span class="bold"><strong>Other Features</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                Hazelcast <code class="code">IList</code> and <code class="code">ISet</code> now have their own configurations. They can be configured
                using config API, xml and Spring. See <code class="code">ListConfig</code> and <code class="code">SetConfig</code> classes.
            </li><li class="listitem"><code class="code">HazelcastInstance.shutdown()</code> method added back.
            </li><li class="listitem">
                OSGI compatibility is improved significantly.
            </li></ul></div><p>
    </p><p>
        <span class="bold"><strong>Fixed Issues</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><a class="link" href="https://github.com/hazelcast/hazelcast/issues?milestone=23&amp;state=closed" target="_top">Version 3.1</a></li></ul></div><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><a class="link" href="https://github.com/hazelcast/hazelcast/issues?milestone=30&amp;state=closed" target="_top">Version 3.1.1</a></li></ul></div><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><a class="link" href="https://github.com/hazelcast/hazelcast/issues?milestone=33&amp;state=closed" target="_top">Version 3.1.2</a></li></ul></div><p>
    </p></div><div class="sect1" title="1.2.&nbsp;What's new in 3.0?"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="WhatsNew3"></a>1.2.&nbsp;What's new in 3.0?</h2></div></div></div><p>
        <span class="bold"><strong>Core architecture:</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                Multi-thread execution: Operations are now executed by multiple threads (by factor of processor cores).
                With Hazelcast 2, there was a only single thread.
            </li><li class="listitem"><a class="link" href="#SPI" title="Chapter&nbsp;13.&nbsp;Service Provider Interface">SPI</a>: Service Programming Interface for developing new partitioned
                services, data structures.
                All Hazelcast data structures like Map, Queue are reimplemented with SPI.
            </li></ul></div><p>
    </p><p>
        <span class="bold"><strong>Serialization</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><a class="link" href="#DataSerializable" title="3.1.&nbsp;Data Serializable">IdentifiedDataSerializable</a>:
                A slightly optimized version of DataSerializable that doesn't
                use class name and reflection for de-serialization.
            </li><li class="listitem"><a class="link" href="#PortableSerialization" title="3.2.&nbsp;Portable Serialization">Portable Serialization</a>:
                Another Serialization interface that doesn't use reflection and
                can navigate through binary data and fetch/query/index individual field without having any reflection
                or whole object de-serialization.
            </li><li class="listitem"><a class="link" href="#CustomSerialization" title="3.3.&nbsp;Custom Serialization">Custom Serialization</a>:
                Support for custom serialization that can be plugged into Hazelcast.
            </li></ul></div><p>
    </p><p>
        <span class="bold"><strong>Map</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><a class="link" href="#MapEntryProcessor" title="2.1.7.&nbsp;Entry Processor">Entry Processor</a>
                :
                Executing an EntryProcessor on the key or on all entries. Hazelcast
                implicitly locks the entree and guarantees no migration while the execution of the Processor.
            </li><li class="listitem"><a class="link" href="#MapInMemoryFormat" title="2.1.11.&nbsp;In Memory Format">In Memory Format</a>
                : Support for storing entries in Binary, Object and Cached format.
            </li><li class="listitem"><a class="link" href="#MapContinuousQuery" title="2.1.6.&nbsp;Continuous Query">Continuous Query</a>
                : Support for listeners that register with a query and are notified when
                there is a change on the Map that matches the Query.
            </li><li class="listitem"><a class="link" href="#MapInterceptor" title="2.1.8.&nbsp;Interceptors">Interceptors</a>
                :
                Ability to intercept the Map operation before/after it is actually executed.
            </li><li class="listitem"><a class="link" href="#MapIndex" title="2.1.5.&nbsp;Indexing">Lazy Indexing</a>
                :Ability to index existing items in the map. No need to add
                indexes at the very beginning.
            </li></ul></div><p>
    </p><p>
        <span class="bold"><strong>Queue</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                No more dependency on the distributed map
            </li><li class="listitem">
                Scales really well as you have thousands of separate queues.
            </li><li class="listitem"><a class="link" href="#QueuePersistence" title="2.2.1.&nbsp;Persistence">Persistence</a>
                Support for persistence with QueueStore.
            </li></ul></div><p>
    </p><p>
        <span class="bold"><strong>Multimap</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                Values can be Set/List/Queue.
            </li></ul></div><p>
    </p><p>
        <span class="bold"><strong>Topic</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                Total Ordering
                : Support for global ordering where all Nodes receive all messages in the same order.
            </li></ul></div><p>
    </p><p>
        <span class="bold"><strong>Transactions</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><a class="link" href="#TransactionInterface" title="9.1.&nbsp;Transaction Interface">Distributed Transaction</a>
                : Support for both 1-phase (local) and 2 phase transactions with a totally new API.
            </li></ul></div><p>
    </p><p>
        <span class="bold"><strong>Client</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                New Binary Protocol: A new binary protocol based on portable serialization.
                The same protocol is used for Java/C/C# and other client
            </li><li class="listitem">
                Smart client: Support for dummy and smart client.
                Where a dummy client will maintain a connection to only one member, whereas the smart
                client can route the operations to the Node that owns the data.
            </li></ul></div><p>
    </p></div><div class="sect1" title="1.3.&nbsp;Upgrading from 2.x versions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MigratingTo3"></a>1.3.&nbsp;Upgrading from 2.x versions</h2></div></div></div><p>
        In this section, we list the changes what users should take into account before upgrading to Hazelcast 3.1 from
        earlier versions of Hazelcast.
    </p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><span class="bold"><strong>Removal of deprecated static methods:</strong></span><p>
                    The static methods of Hazelcast class reaching hazelcast data components have been removed.
                    The functionality of these methods can be reached from HazelcastInstance interface.
                    Namely you should replace following:
                    </p><pre class="programlisting">
Map&lt;Integer, String&gt; mapCustomers = Hazelcast.getMap(<font font-style="normal" color="#008000">"customers"</font>);</pre><p>
                    with
                    </p><pre class="programlisting">
HazelcastInstance instance = Hazelcast.newHazelcastInstance(cfg);
<em class="hl-comment" style="color: silver">// or if you already started an instance</em>
<em class="hl-comment" style="color: silver">// HazelcastInstance instance = Hazelcast.getHazelcastInstanceByName("instance1");</em>
Map&lt;Integer, String&gt; mapCustomers = instance.getMap(<font font-style="normal" color="#008000">"customers"</font>);</pre><p>
                </p></li><li class="listitem"><span class="bold"><strong>Removal of lite members:</strong></span><p>
                    With 3.0 there will be no member type as lite member.
                    As 3.0 clients are smart client that they know in which node the data is located, you can replace
                    your lite members with native clients.
                </p></li><li class="listitem"><span class="bold"><strong>Renaming "instance" to "distributed object":</strong></span><p>
                    Before 3.0 there was a confusion for the term "instance".
                    It was used for both the cluster members and the distributed objects (map, queue, topic etc.
                    instances).
                    Starting 3.0, the term instance will be only used for hazelcast instances, namely cluster members.
                    We will use the term "distributed object" for map, queue etc. instances.
                    So you should replace the related methods with the new renamed ones:
                    As 3.0 clients are smart client that they know in which node the data is located, you can replace
                    your lite members with native clients.
                    </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">static</strong> <strong class="hl-keyword">void</strong> main(String[] args) <strong class="hl-keyword">throws</strong> InterruptedException {
    Config cfg = <strong class="hl-keyword">new</strong> Config();
    HazelcastInstance hz = Hazelcast.newHazelcastInstance(cfg);
    IMap map = hz.getMap(<font font-style="normal" color="#008000">"test"</font>);
    Collection&lt;Instance&gt; instances = hz.getInstances();
    <strong class="hl-keyword">for</strong> (Instance instance : instances) {
        <strong class="hl-keyword">if</strong>(instance.getInstanceType() == Instance.InstanceType.MAP) {
        System.out.println(<font font-style="normal" color="#008000">"there is a map with name:"</font>+instance.getId());
        }
    }
}
    </pre><p>
                    with
                    </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">static</strong> <strong class="hl-keyword">void</strong> main(String[] args) <strong class="hl-keyword">throws</strong> InterruptedException {
    Config cfg = <strong class="hl-keyword">new</strong> Config();
    HazelcastInstance hz = Hazelcast.newHazelcastInstance(cfg);
    IMap map = hz.getMap(<font font-style="normal" color="#008000">"test"</font>);
    Collection&lt;DistributedObject&gt; distributedObjects = hz.getDistributedObjects();
        <strong class="hl-keyword">for</strong> (DistributedObject distributedObject : distributedObjects) {
            <strong class="hl-keyword">if</strong>(distributedObject <strong class="hl-keyword">instanceof</strong> IMap)
            System.out.println(<font font-style="normal" color="#008000">"there is a map with name:"</font>+distributedObject.getName());
        }
}
                            </pre><p>

                </p></li><li class="listitem"><span class="bold"><strong>Package structure change:</strong></span><p>
                    PartitionService has been moved to package "com.hazelcast.core" from "com.hazelcast.partition"
                </p></li><li class="listitem"><span class="bold"><strong>Listener API change:</strong></span><p>
                    Before 3.0, you can removeListener methods was taking the Listener object as parameter.
                    But it causes confusion as same listener object may be used as parameter for different listener
                    registrations.
                    So we have changed the listener API. Anymore, addListener methods return you an unique id and you
                    can remove listener by using this id.
                    So you should do following replacement if needed:
                    </p><pre class="programlisting">
IMap map = instance.getMap(<font font-style="normal" color="#008000">"map"</font>);
map.addEntryListener(listener,true);
map.removeEntryListener(listener);
    </pre><p>
                    with
                    </p><pre class="programlisting">
IMap map = instance.getMap(<font font-style="normal" color="#008000">"map"</font>);
String listenerId = map.addEntryListener(listener, true);
map.removeEntryListener(listenerId);
    </pre><p>
                </p></li><li class="listitem"><span class="bold"><strong>IMap changes:</strong></span><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>
                            tryRemove(K key, long timeout, TimeUnit timeunit) returns boolean indicating whether
                            operation is successful.
                        </p></li><li class="listitem"><p>
                            tryLockAndGet(K key, long time, TimeUnit timeunit) is removed.
                        </p></li><li class="listitem"><p>
                            putAndUnlock(K key, V value) is removed.
                        </p></li><li class="listitem"><p>
                            lockMap(long time, TimeUnit timeunit) and unlockMap() are removed
                        </p></li><li class="listitem"><p>
                            getMapEntry(K key) is renamed as getEntryView(K key). The returned object's type, MapEntry
                            class is renamed as EntryView.
                        </p></li><li class="listitem"><p>
                           There is no predefined names for merge policies. You just give the full class name of the merge policy implementation.
                            </p><pre class="programlisting">
&lt;merge-policy&gt;com.hazelcast.map.merge.PassThroughMergePolicy&lt;/merge-policy&gt;
    </pre><p>
                        </p>
                        Also MergePolicy interface has been renamed to MapMergePolicy and also returning null from the implemented merge() method causes the existing entry to be removed.
                    </li></ul></div></li><li class="listitem"><span class="bold"><strong>IQueue changes:</strong></span><p>There is no change on IQueue API but there are changes on how IQueue is configured. With Hazelcast
                    3.0 there will not be backing map configuration for queue.
                    Settings like backup count will be directly configured on queue config.
                    For queue configuration details, see
                    <a class="link" href="#Queue" title="2.2.&nbsp;Distributed Queue"> Distributed Queue </a>
                    page.
                </p></li><li class="listitem"><span class="bold"><strong>Transaction API change:</strong></span><p>In Hazelcast 3.0, transaction API is completely different. See transactions part for the new API:
                    <a class="link" href="#Transactions" title="Chapter&nbsp;9.&nbsp;Transactions"> Distributed Transactions </a>
                </p></li><li class="listitem"><span class="bold"><strong>ExecutorService API change:</strong></span><p>Classes MultiTask and DistributedTask have been removed. All the functionality is supported by the newly presented interface IExecutorService.
                    See distributed execution part for detailed usage example:
                    <a class="link" href="#DistributedExecution" title="10.1.&nbsp;Distributed Execution"> Distributed Execution </a>
                </p></li><li class="listitem">
                LifeCycleService API has been simplified. pause(), resume(), restart() methods have been removed.
            </li><li class="listitem">
                AtomicNumber class has been renamed to IAtomicLong.
            </li><li class="listitem">
                ICountDownLatch await() operation has been removed. We expect users to use await method with timeout parameters.
            </li><li class="listitem">
                ISemaphore API has been substantially changed. attach(), detach() methods have been removed.
            </li></ul></div><p>
    </p></div><div class="sect1" title="1.4.&nbsp;Getting Started (Tutorial)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="GettingStarted"></a>1.4.&nbsp;Getting Started (Tutorial)</h2></div></div></div><p>
        In this short tutorial, we will create simple Java application using Hazelcast distributed map and queue.
        Then we will run our application twice to have two nodes (JVMs) clustered and finalize this tutorial
        with connecting to our cluster from another Java application by using Hazelcast Native Java Client API.
    </p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Download the latest
                    <a class="link" href="http://www.hazelcast.com/downloads.jsp" target="_top">Hazelcast zip</a>.
                </p></li><li class="listitem"><p>Unzip it and add the
                    <code class="literal">lib/hazelcast.jar</code>
                    to your class path.
                </p></li><li class="listitem"><p>Create a Java class and import Hazelcast libraries.</p></li><li class="listitem"><p>Following code will start the first node and create and use
                    <code class="literal">customers</code>
                    map and queue.
                    </p><pre class="programlisting">
<strong class="hl-keyword">import</strong> com.hazelcast.config.Config;
<strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> com.hazelcast.core.HazelcastInstance;

<strong class="hl-keyword">import</strong> java.util.Map;
<strong class="hl-keyword">import</strong> java.util.Queue;

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> GettingStarted {

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">static</strong> <strong class="hl-keyword">void</strong> main(String[] args) {
        Config cfg = <strong class="hl-keyword">new</strong> Config();
        HazelcastInstance instance = Hazelcast.newHazelcastInstance(cfg);
        Map&lt;Integer, String&gt; mapCustomers = instance.getMap(<font font-style="normal" color="#008000">"customers"</font>);
        mapCustomers.put(<span class="hl-number">1</span>, <font font-style="normal" color="#008000">"Joe"</font>);
        mapCustomers.put(<span class="hl-number">2</span>, <font font-style="normal" color="#008000">"Ali"</font>);
        mapCustomers.put(<span class="hl-number">3</span>, <font font-style="normal" color="#008000">"Avi"</font>);

        System.out.println(<font font-style="normal" color="#008000">"Customer with key 1: "</font>+ mapCustomers.get(<span class="hl-number">1</span>));
        System.out.println(<font font-style="normal" color="#008000">"Map Size:"</font> + mapCustomers.size());

        Queue&lt;String&gt; queueCustomers = instance.getQueue(<font font-style="normal" color="#008000">"customers"</font>);
        queueCustomers.offer(<font font-style="normal" color="#008000">"Tom"</font>);
        queueCustomers.offer(<font font-style="normal" color="#008000">"Mary"</font>);
        queueCustomers.offer(<font font-style="normal" color="#008000">"Jane"</font>);
        System.out.println(<font font-style="normal" color="#008000">"First customer: "</font> + queueCustomers.poll());
        System.out.println(<font font-style="normal" color="#008000">"Second customer: "</font>+ queueCustomers.peek());
        System.out.println(<font font-style="normal" color="#008000">"Queue size: "</font> + queueCustomers.size());
    }
}
</pre><p>
                </p></li><li class="listitem"><p>Run this class second time to get the second node started.</p></li><li class="listitem"><p>Have you seen they formed a cluster? You should see something like this:
                    </p><pre class="programlisting">
Members [2] {
	Member [127.0.0.1:5701]
	Member [127.0.0.1:5702] this
}
                            </pre><p>
                </p></li></ul></div><p>
    </p><p>
        <span class="bold"><strong>Connecting Hazelcast Cluster with Java Client API</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Besides
                    <code class="literal">hazelcast.jar</code>
                    you should also add
                    <code class="literal">hazelcast-client.jar</code>
                    to your classpath.
                </p></li><li class="listitem"><p>Following code will start a Hazelcast Client, connect to our two node cluster
                    and print the size of our
                    <code class="literal">customers</code>
                    map.
                    </p><pre class="programlisting">
<strong class="hl-keyword">package</strong> com.hazelcast.test;

<strong class="hl-keyword">import</strong> com.hazelcast.client.config.ClientConfig;
<strong class="hl-keyword">import</strong> com.hazelcast.client.HazelcastClient;
<strong class="hl-keyword">import</strong> com.hazelcast.core.HazelcastInstance;
<strong class="hl-keyword">import</strong> com.hazelcast.core.IMap;

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> GettingStartedClient {

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">static</strong> <strong class="hl-keyword">void</strong> main(String[] args) {
        ClientConfig clientConfig = <strong class="hl-keyword">new</strong> ClientConfig();
        clientConfig.addAddress(<font font-style="normal" color="#008000">"127.0.0.1:5701"</font>);
        HazelcastInstance client = HazelcastClient.newHazelcastClient(clientConfig);
        IMap map = client.getMap(<font font-style="normal" color="#008000">"customers"</font>);
        System.out.println(<font font-style="normal" color="#008000">"Map Size:"</font> + map.size());
    }
}
</pre><p>
                </p></li><li class="listitem"><p>When you run it, you will see the client properly connects to the cluster and print the map
                    size as 3.
                </p></li></ul></div><p>
    </p><p>
        <span class="bold"><strong>What is Next?</strong></span>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>You can browse
                    <a class="link" href="http://www.hazelcast.com/docs.jsp" target="_top">documentation</a>
                    and resources for detailed features and examples.
                </p></li><li class="listitem"><p>You can email your questions to Hazelcast
                    <a class="link" href="http://groups.google.com/group/hazelcast" target="_top">mail group</a>.
                </p></li><li class="listitem"><p>You can browse Hazelcast
                    <a class="link" href="https://github.com/hazelcast/hazelcast" target="_top">source
                        code</a>.
                </p></li></ul></div><p>
    </p></div></div><div class="chapter" title="Chapter&nbsp;2.&nbsp;Distributed Data Structures"><div class="titlepage"><div><div><h2 class="title"><a name="DDS"></a>Chapter&nbsp;2.&nbsp;Distributed Data Structures</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#Map">2.1. Distributed Map</a></span></dt><dd><dl><dt><span class="sect2"><a href="#MapBackup">2.1.1. Backups</a></span></dt><dt><span class="sect2"><a href="#MapEviction">2.1.2. Eviction</a></span></dt><dt><span class="sect2"><a href="#MapPersistence">2.1.3. Persistence</a></span></dt><dt><span class="sect2"><a href="#MapQuery">2.1.4. Query</a></span></dt><dt><span class="sect2"><a href="#MapIndex">2.1.5. Indexing</a></span></dt><dt><span class="sect2"><a href="#MapContinuousQuery">2.1.6. Continuous Query</a></span></dt><dt><span class="sect2"><a href="#MapEntryProcessor">2.1.7. Entry Processor</a></span></dt><dt><span class="sect2"><a href="#MapInterceptor">2.1.8. Interceptors</a></span></dt><dt><span class="sect2"><a href="#MapNearCache">2.1.9. Near Cache</a></span></dt><dt><span class="sect2"><a href="#MapEntry">2.1.10. Entry Statistics</a></span></dt><dt><span class="sect2"><a href="#MapInMemoryFormat">2.1.11. In Memory Format</a></span></dt></dl></dd><dt><span class="sect1"><a href="#Queue">2.2. Distributed Queue</a></span></dt><dd><dl><dt><span class="sect2"><a href="#QueuePersistence">2.2.1. Persistence</a></span></dt></dl></dd><dt><span class="sect1"><a href="#MultiMap">2.3. Distributed MultiMap</a></span></dt><dt><span class="sect1"><a href="#Topic">2.4. Distributed Topic</a></span></dt><dt><span class="sect1"><a href="#Set">2.5. Distributed Set</a></span></dt><dt><span class="sect1"><a href="#List">2.6. Distributed List</a></span></dt><dt><span class="sect1"><a href="#Lock">2.7. Distributed Lock</a></span></dt><dt><span class="sect1"><a href="#Events">2.8. Distributed Events</a></span></dt></dl></div><p>
    Common Features of all Hazelcast Data Structures:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Data in the cluster is almost evenly distributed (partitioned) across all nodes.
                So each node carries ~ (1/n
                <code class="literal">*</code>
                total-data) + backups , n being the
                number of nodes in the cluster.
            </p></li><li class="listitem"><p>If a member goes down, its backup replica that also holds the same data, will
                dynamically redistribute the data including the ownership and locks on them to
                remaining live nodes. As a result, no data will get lost.
            </p></li><li class="listitem"><p>When a new node joins the cluster, new node takes ownership(responsibility) and
                load of -some- of the entire data in the cluster. Eventually the new node will carry
                almost (1/n
                <code class="literal">*</code>
                total-data) + backups and becomes the new partition
                reducing the load on others.
            </p></li><li class="listitem"><p>There is no single cluster master or something that can cause single point of
                failure. Every node in the cluster has equal rights and responsibilities. No-one is
                superior. And no dependency on external 'server' or 'master' kind of concept.
            </p></li><li class="listitem"><p>Hazelcast will synchronize the state of Distributed Data Structures, but not the content of it.
                Example: if you have an IMap &lt; String, Employee &gt; and one node fires an employee by calling
                employees.get(&#8220;John&#8221;).setFired(true);
                then the state of Employee will not be synchronized. This is because employees.get("John") will create a
                copy of the existing employee.
                You need to put it back by calling employees.put("John", employee) in order for the state to be
                reflected in Hazelcast.
                As a rule of thumb you should treat everything stored in Hazelcast as immutable objects.
            </p></li></ul></div><p>
    Here is how you can retrieve existing data structure instances (map, queue, set,
    lock, topic, etc.) and how you can listen for instance events to get notified when an instance
    is created or destroyed.
    </p><pre class="programlisting"><strong class="hl-keyword">import</strong> java.util.Collection;
<strong class="hl-keyword">import</strong> com.hazelcast.config.Config;
<strong class="hl-keyword">import</strong> com.hazelcast.core.*;

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Sample <strong class="hl-keyword">implements</strong> DistributedObjectListener {
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">static</strong> <strong class="hl-keyword">void</strong> main(String[] args) {
        Sample sample = <strong class="hl-keyword">new</strong> Sample();

        Config cfg = <strong class="hl-keyword">new</strong> Config();
        HazelcastInstance hz = Hazelcast.newHazelcastInstance(cfg);
        hz.addDistributedObjectListener(sample);

        Collection&lt;DistributedObject&gt; distributedObjects = hz.getDistributedObjects();

        <strong class="hl-keyword">for</strong> (DistributedObject distributedObject : distributedObjects) {
            System.out.println(distributedObject.getName() + <font font-style="normal" color="#008000">","</font> + distributedObject.getId());
        }
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> distributedObjectCreated(DistributedObjectEvent event) {
        DistributedObject instance = event.getDistributedObject();
        System.out.println(<font font-style="normal" color="#008000">"Created "</font> + instance.getName() + <font font-style="normal" color="#008000">","</font> + instance.getId());
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> distributedObjectDestroyed(DistributedObjectEvent event) {
        DistributedObject instance = event.getDistributedObject();
        System.out.println(<font font-style="normal" color="#008000">"Destroyed "</font> + instance.getName() + <font font-style="normal" color="#008000">","</font> + instance.getId());

    }
}</pre><p>
</p><div class="sect1" title="2.1.&nbsp;Distributed Map"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Map"></a>2.1.&nbsp;Distributed Map</h2></div></div></div><p>Hazelcast will partition your map entries; and almost evenly
        distribute onto all Hazelcast members. Distributed maps have 1 backup by
        default so that if a member goes down, we don't lose data. Backup operations are synchronous
        so when a
        <code class="literal">map.put(key, value)</code>
        returns, it is guaranteed that the entry is
        replicated to one other node. For the reads, it is also guaranteed that
        <code class="literal">map.get(key)</code>
        returns the latest value of the entry. Consistency is
        strictly enforced.
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> java.util.Map;
<strong class="hl-keyword">import</strong> java.util.Collection;
<strong class="hl-keyword">import</strong> com.hazelcast.config.Config;

Config cfg = <strong class="hl-keyword">new</strong> Config();
HazelcastInstance hz = Hazelcast.newHazelcastInstance(cfg);
Map&lt;String, Customer&gt; mapCustomers = hz.getMap(<font font-style="normal" color="#008000">"customers"</font>);
mapCustomers.put(<font font-style="normal" color="#008000">"1"</font>, <strong class="hl-keyword">new</strong> Customer(<font font-style="normal" color="#008000">"Joe"</font>, <font font-style="normal" color="#008000">"Smith"</font>));
mapCustomers.put(<font font-style="normal" color="#008000">"2"</font>, <strong class="hl-keyword">new</strong> Customer(<font font-style="normal" color="#008000">"Ali"</font>, <font font-style="normal" color="#008000">"Selam"</font>));
mapCustomers.put(<font font-style="normal" color="#008000">"3"</font>, <strong class="hl-keyword">new</strong> Customer(<font font-style="normal" color="#008000">"Avi"</font>, <font font-style="normal" color="#008000">"Noyan"</font>));

Collection&lt;Customer&gt; colCustomers = mapCustomers.values();
<strong class="hl-keyword">for</strong> (Customer customer : colCustomers) {
    <em class="hl-comment" style="color: silver">// process customer</em>
}
</pre><p>
        <code class="literal">HazelcastInstance.getMap()</code>
        actually returns
        <code class="literal">com.hazelcast.core.IMap</code>
        which extends
        <code class="literal">java.util.concurrent.ConcurrentMap</code>
        interface. So methods like
        <code class="literal">ConcurrentMap.putIfAbsent(key,value)</code>
        and
        <code class="literal">ConcurrentMap.replace(key,value)</code>
        can be used on distributed map as
        shown in the example below.
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> java.util.concurrent.ConcurrentMap;

Customer getCustomer (String id) {
    ConcurrentMap&lt;String, Customer&gt; map = hz.getMap(<font font-style="normal" color="#008000">"customers"</font>);
    Customer customer = map.get(id);
    <strong class="hl-keyword">if</strong> (customer == null) {
        customer = <strong class="hl-keyword">new</strong> Customer (id);
        customer = map.putIfAbsent(id, customer);
    }
    <strong class="hl-keyword">return</strong> customer;
}               

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">boolean</strong> updateCustomer (Customer customer) {
    ConcurrentMap&lt;String, Customer&gt; map = hz.getMap(<font font-style="normal" color="#008000">"customers"</font>);
    <strong class="hl-keyword">return</strong> (map.replace(customer.getId(), customer) != null);            
}
                
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">boolean</strong> removeCustomer (Customer customer) {
    ConcurrentMap&lt;String, Customer&gt; map = hz.getMap(<font font-style="normal" color="#008000">"customers"</font>);
    <strong class="hl-keyword">return</strong> map.remove(customer.getId(), customer) );           
}                                  
        
</pre><p>
        All
        <code class="literal">ConcurrentMap</code>
        operations such as
        <code class="literal">put</code>
        and
        <code class="literal">remove</code>
        might wait if the key is locked by another thread in the local
        or remote JVM, but they will eventually return with success.
        <code class="literal">ConcurrentMap</code>
        operations never
        throw<code class="literal">java.util.ConcurrentModificationException</code>.
    </p><p>Also see:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Distributed Map internals.</p></li><li class="listitem"><p><a class="link" href="#DataAffinity" title="Chapter&nbsp;6.&nbsp;Data Affinity">Data Affinity</a>.</p></li><li class="listitem"><p><a class="link" href="#WildcardConfiguration" title="14.5.&nbsp;Wildcard Configuration">Map Configuration with wildcards.</a>.</p></li></ul></div><p>
    </p><div class="sect2" title="2.1.1.&nbsp;Backups"><div class="titlepage"><div><div><h3 class="title"><a name="MapBackup"></a>2.1.1.&nbsp;Backups</h3></div></div></div><p>Hazelcast will distribute map entries onto multiple JVMs (cluster members). Each JVM
        holds some portion of the data but we don't want to lose data when a member JVM crashes.
        To provide data-safety, Hazelcast allows you to specify the number of backup copies you
        want to have. That way data on a JVM will be copied onto other JVM(s). Hazelcast supports both
        <code class="literal">sync</code> and <code class="literal">async</code> backups.
        <code class="literal">Sync</code> backups block operations until backups are successfully copied to
        backups nodes (or deleted from backup nodes in case of remove)
        and acknowledgements are received. In contrast, <code class="literal">async</code> backups do not block
        operations, they are fire &amp; forget and do not require acknowledgements.
        By default, Hazelcast will have one sync backup copy.
        If backup count &gt;= 1, then each member will carry both owned entries and backup copies of other
        member(s). So for the <code class="literal">map.get(key)</code> call, it is possible that calling member has backup
        copy of that key but by default, <code class="literal">map.get(key)</code> will always read the
        value from the actual owner of the key for consistency. It is possible to enable backup
        reads by changing the configuration. Enabling backup reads will give you greater performance.
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <em class="hl-comment" style="color: silver">&lt;!--
            Number of sync-backups. If 1 is set as the backup-count for example,
            then all entries of the map will be copied to another JVM for
            fail-safety. Valid numbers are 0 (no backup), 1, 2, 3.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;backup-count&gt;</font>1<font font-style="bold" color="#0A1777">&lt;/backup-count&gt;</font>

        <em class="hl-comment" style="color: silver">&lt;!--
            Number of async-backups. If 1 is set as the backup-count for example,
            then all entries of the map will be copied to another JVM for
            fail-safety. Valid numbers are 0 (no backup), 1, 2, 3.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;async-backup-count&gt;</font>1<font font-style="bold" color="#0A1777">&lt;/async-backup-count&gt;</font>

        <em class="hl-comment" style="color: silver">&lt;!--
            Can we read the local backup entries? Default value is false for
            strong consistency. Being able to read backup data will give you
            greater performance.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;read-backup-data&gt;</font>false<font font-style="bold" color="#0A1777">&lt;/read-backup-data&gt;</font>

        ...
    <font font-style="bold" color="#0A1777">&lt;/map&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>
    </p></div><div class="sect2" title="2.1.2.&nbsp;Eviction"><div class="titlepage"><div><div><h3 class="title"><a name="MapEviction"></a>2.1.2.&nbsp;Eviction</h3></div></div></div><p>Hazelcast also supports policy based eviction for distributed map. Currently supported
        eviction policies are LRU (Least Recently Used) and LFU (Least Frequently Used). This
        feature enables Hazelcast to be used as a distributed cache. If
        <code class="literal">time-to-live-seconds</code>
        is not 0 then entries older than
        <code class="literal">time-to-live-seconds</code>
        value will get evicted, regardless of the
        eviction policy set. Here is a sample configuration for eviction:
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <em class="hl-comment" style="color: silver">&lt;!--
            Number of backups. If 1 is set as the backup-count for example,
            then all entries of the map will be copied to another JVM for
            fail-safety. Valid numbers are 0 (no backup), 1, 2, 3.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;backup-count&gt;</font>1<font font-style="bold" color="#0A1777">&lt;/backup-count&gt;</font>

        <em class="hl-comment" style="color: silver">&lt;!--
            Maximum number of seconds for each entry to stay in the map. Entries that are
            older than &lt;time-to-live-seconds&gt; and not updated for &lt;time-to-live-seconds&gt;
            will get automatically evicted from the map.
            Any integer between 0 and Integer.MAX_VALUE. 0 means infinite. Default is 0.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;time-to-live-seconds&gt;</font>0<font font-style="bold" color="#0A1777">&lt;/time-to-live-seconds&gt;</font>

        <em class="hl-comment" style="color: silver">&lt;!--
            Maximum number of seconds for each entry to stay idle in the map. Entries that are
            idle(not touched) for more than &lt;max-idle-seconds&gt; will get
            automatically evicted from the map.
            Entry is touched if get, put or containsKey is called.
            Any integer between 0 and Integer.MAX_VALUE.
            0 means infinite. Default is 0.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;max-idle-seconds&gt;</font>0<font font-style="bold" color="#0A1777">&lt;/max-idle-seconds&gt;</font>

        <em class="hl-comment" style="color: silver">&lt;!--
            Valid values are:
            NONE (no extra eviction, &lt;time-to-live-seconds&gt; may still apply),
            LRU  (Least Recently Used),
            LFU  (Least Frequently Used).
            NONE is the default.
            Regardless of the eviction policy used, &lt;time-to-live-seconds&gt; will still apply. 
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;eviction-policy&gt;</font>LRU<font font-style="bold" color="#0A1777">&lt;/eviction-policy&gt;</font>

        <em class="hl-comment" style="color: silver">&lt;!--
            Maximum size of the map. When max size is reached,
            map is evicted based on the policy defined.
            Any integer between 0 and Integer.MAX_VALUE. 0 means
            Integer.MAX_VALUE. Default is 0.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;max-size</font> <font font-style="bold" color="#0A1777">policy</font>=<font font-style="bold" color="#008000">"PER_NODE"</font><font font-style="bold" color="#0A1777">&gt;</font>5000<font font-style="bold" color="#0A1777">&lt;/max-size&gt;</font>

        <em class="hl-comment" style="color: silver">&lt;!--
            When max. size is reached, specified percentage of
            the map will be evicted. Any integer between 0 and 100.
            If 25 is set for example, 25% of the entries will
            get evicted.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;eviction-percentage&gt;</font>25<font font-style="bold" color="#0A1777">&lt;/eviction-percentage&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/map&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>
    </p><p>
        <span class="bold"><strong>Max-Size Policies</strong></span>
    </p><p>
        There are 4 defined policies can be used in max-size configuration.
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                    <span class="bold"><strong>PER_NODE:</strong></span>  Max map size per instance.
                    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;max-size</font> <font font-style="bold" color="#0A1777">policy</font>=<font font-style="bold" color="#008000">"PER_NODE"</font><font font-style="bold" color="#0A1777">&gt;</font>5000<font font-style="bold" color="#0A1777">&lt;/max-size&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>PER_PARTITION:</strong></span> Max map size per each partition.
                    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;max-size</font> <font font-style="bold" color="#0A1777">policy</font>=<font font-style="bold" color="#008000">"PER_PARTITION"</font><font font-style="bold" color="#0A1777">&gt;</font>27100<font font-style="bold" color="#0A1777">&lt;/max-size&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>USED_HEAP_SIZE:</strong></span> Max used heap size in MB (mega-bytes) per JVM.
                    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;max-size</font> <font font-style="bold" color="#0A1777">policy</font>=<font font-style="bold" color="#008000">"USED_HEAP_SIZE"</font><font font-style="bold" color="#0A1777">&gt;</font>4096<font font-style="bold" color="#0A1777">&lt;/max-size&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>USED_HEAP_PERCENTAGE:</strong></span> Max used heap size percentage per JVM.
                    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;max-size</font> <font font-style="bold" color="#0A1777">policy</font>=<font font-style="bold" color="#008000">"USED_HEAP_PERCENTAGE"</font><font font-style="bold" color="#0A1777">&gt;</font>75<font font-style="bold" color="#0A1777">&lt;/max-size&gt;</font></pre><p>
                </p></li></ol></div><p>
    </p></div><div class="sect2" title="2.1.3.&nbsp;Persistence"><div class="titlepage"><div><div><h3 class="title"><a name="MapPersistence"></a>2.1.3.&nbsp;Persistence</h3></div></div></div><p>Hazelcast allows you to load and store the distributed map entries from/to a
        persistent datastore such as relational database. If a loader implementation is
        provided, when
        <code class="literal">get(key)</code>
        is called, if the map entry doesn't exist
        in-memory then Hazelcast will call your loader implementation to load the entry from a
        datastore. If a store implementation is provided, when
        <code class="literal">put(key,value)</code>
        is called, Hazelcast will call your store implementation to store the entry into a
        datastore. Hazelcast can call your implementation to store the entries synchronously
        (write-through) with no-delay or asynchronously (write-behind) with delay and it is
        defined by the
        <code class="literal">write-delay-seconds</code>
        value in the configuration.
    </p><p>If it is write-through, when the
        <code class="literal">map.put(key,value)</code>
        call returns,
        you can be sure that
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    <code class="literal">MapStore.store(key,value)</code>
                    is successfully called so the
                    entry is persisted.
                </p></li><li class="listitem"><p>In-Memory entry is updated</p></li><li class="listitem"><p>In-Memory backup copies are successfully created on other JVMs (if
                    backup-count is greater than 0)
                </p></li></ul></div><p>
        If it is write-behind, when the
        <code class="literal">map.put(key,value)</code>
        call returns, you can be sure that
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>In-Memory entry is updated</p></li><li class="listitem"><p>In-Memory backup copies are successfully created on other JVMs (if
                    backup-count is greater than 0)
                </p></li><li class="listitem"><p>The entry is marked as
                    <code class="literal">dirty</code>
                    so that after
                    <code class="literal">write-delay-seconds</code>, it can be persisted.
                </p></li></ul></div><p>
        Same behavior goes for the
        <code class="literal">remove(key</code>
        and
        <code class="literal">MapStore.delete(key)</code>. If
        <code class="literal">MapStore</code>
        throws an
        exception then the exception will be propagated back to the original
        <code class="literal">put</code>
        or
        <code class="literal">remove</code>
        call in the form of
        <code class="literal">RuntimeException</code>. When write-through is used, Hazelcast will call
        <code class="literal">MapStore.store(key,value)</code>
        and
        <code class="literal">MapStore.delete(key)</code>
        for each entry update. When write-behind is
        used, Hazelcast will call<code class="literal">MapStore.store(map)</code>, and
        <code class="literal">MapStore.delete(collection)</code>
        to do all writes in a single call.
        Also note that your MapStore or MapLoader implementation should not use Hazelcast
        Map/Queue/MultiMap/List/Set operations. Your implementation should only work with your
        data store. Otherwise you may get into deadlock situations.
    </p><p>Here is a sample configuration:
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
        ...
        <font font-style="bold" color="#0A1777">&lt;map-store</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <em class="hl-comment" style="color: silver">&lt;!--
               Name of the class implementing MapLoader and/or MapStore.
               The class should implement at least of these interfaces and
               contain no-argument constructor. Note that the inner classes are not supported.
            --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;class-name&gt;</font>com.hazelcast.examples.DummyStore<font font-style="bold" color="#0A1777">&lt;/class-name&gt;</font>
            <em class="hl-comment" style="color: silver">&lt;!--
               Number of seconds to delay to call the MapStore.store(key, value).
               If the value is zero then it is write-through so MapStore.store(key, value)
               will be called as soon as the entry is updated.
               Otherwise it is write-behind so updates will be stored after write-delay-seconds
               value by calling Hazelcast.storeAll(map). Default value is 0.
            --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;write-delay-seconds&gt;</font>0<font font-style="bold" color="#0A1777">&lt;/write-delay-seconds&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/map-store&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/map&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>
    </p><p>
        <span class="italic">
            <span class="bold"><strong>Initialization on
                startup:
            </strong></span>
        </span>
    </p><p>
        <code class="literal">MapLoader.loadAllKeys</code>
        API is used for pre-populating the
        in-memory map when the map is first touched/used. If
        <code class="literal">MapLoader.loadAllKeys</code>
        returns NULL then nothing will be loaded.
        Your
        <code class="literal">MapLoader.loadAllKeys</code>
        implementation can return all or some of the keys. You may
        select and return only the
        <code class="literal">hot</code>
        keys, for instance. Also note that
        this is the fastest way of pre-populating the map as Hazelcast will optimize the loading
        process by having each node loading owned portion of the entries.
    </p><p>Here is MapLoader initialization flow;
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>When
                    <code class="code">getMap()</code>
                    first called from any node, initialization starts
                </p></li><li class="listitem"><p>Hazelcast will call
                    <code class="code">MapLoader.loadAllKeys()</code>
                    to get all your keys on each
                    node
                </p></li><li class="listitem"><p>Each node will figure out the list of keys it owns</p></li><li class="listitem"><p>Each node will load all its owned keys by calling
                    <code class="code">MapLoader.loadAll(keys)</code>
                </p></li><li class="listitem"><p>Each node puts its owned entries into the map by
                    calling
                    <code class="code">IMap.putTransient(key,value)</code>
                </p></li></ol></div><p>
    </p></div><div class="sect2" title="2.1.4.&nbsp;Query"><div class="titlepage"><div><div><h3 class="title"><a name="MapQuery"></a>2.1.4.&nbsp;Query</h3></div></div></div><p>Hazelcast partitions your data and spreads across cluster of servers. You can surely
        iterate over the map entries and look for certain entries you are interested in but this
        is not very efficient as you will have to bring entire entry set and iterate locally.
        Instead, Hazelcast allows you to run distributed queries on your distributed map.
    </p><p>Let's say you have a "employee" map containing values of
        <code class="literal">Employee</code>
        objects:</p><pre class="programlisting"><strong class="hl-keyword">import</strong> java.io.Serializable;

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Employee <strong class="hl-keyword">implements</strong> Serializable {
<strong class="hl-keyword">private</strong> String name;
<strong class="hl-keyword">private</strong> <strong class="hl-keyword">int</strong> age;
<strong class="hl-keyword">private</strong> <strong class="hl-keyword">boolean</strong> active;
<strong class="hl-keyword">private</strong> <strong class="hl-keyword">double</strong> salary;

<strong class="hl-keyword">public</strong> Employee(String name, <strong class="hl-keyword">int</strong> age, <strong class="hl-keyword">boolean</strong> live, <strong class="hl-keyword">double</strong> price) {
    <strong class="hl-keyword">this</strong>.name = name;
    <strong class="hl-keyword">this</strong>.age = age;
    <strong class="hl-keyword">this</strong>.active = live;
    <strong class="hl-keyword">this</strong>.salary = price;
}

<strong class="hl-keyword">public</strong> Employee() {
}

<strong class="hl-keyword">public</strong> String getName() {
    <strong class="hl-keyword">return</strong> name;
}

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">int</strong> getAge() {
    <strong class="hl-keyword">return</strong> age;
}

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">double</strong> getSalary() {
    <strong class="hl-keyword">return</strong> salary;
}

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">boolean</strong> isActive() {
    <strong class="hl-keyword">return</strong> active;
}
}
</pre><p>Now you are looking for the employees who are active and with age less than 30.
        Hazelcast allows you to find these entries in two different ways:
    </p><p>
        <span class="bold"><strong>Distributed SQL Query</strong></span>
    </p><p>
        <code class="literal">SqlPredicate</code>
        takes regular SQL where clause. Here is an example:
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.IMap;
<strong class="hl-keyword">import</strong> com.hazelcast.query.SqlPredicate;

Config cfg = <strong class="hl-keyword">new</strong> Config();
HazelcastInstance hz = Hazelcast.newHazelcastInstance(cfg);
IMap map = hz.getMap(<font font-style="normal" color="#008000">"employee"</font>);

Set&lt;Employee&gt; employees = (Set&lt;Employee&gt;) map.values(<strong class="hl-keyword">new</strong> SqlPredicate(<font font-style="normal" color="#008000">"active AND age &lt; 30"</font>));
</pre><p>
        Supported SQL syntax:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>AND/OR
                    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>
                                <code class="literal">&lt;expression&gt; AND &lt;expression&gt; AND
                                    &lt;expression&gt;...
                                </code>
                                </p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem"><p>
                                            <code class="literal">active AND age&gt;30</code>
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">active=false OR age = 45 OR name =
                                                'Joe'
                                            </code>
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">active AND (age &gt;20 OR salary &lt;
                                                60000)
                                            </code>
                                        </p></li></ul></div><p>
                            </p></li></ul></div><p>
                </p></li><li class="listitem"><p>
                    <code class="literal">=, !=, &lt;, &lt;=, &gt;, &gt;=</code>
                    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>
                                <code class="literal">&lt;expression&gt; = value</code>
                                </p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem"><p>
                                            <code class="literal">age &lt;= 30</code>
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">name ='Joe'</code>
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">salary != 50000</code>
                                        </p></li></ul></div><p>
                            </p></li></ul></div><p>
                </p></li><li class="listitem"><p>BETWEEN
                    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>
                                <code class="literal">&lt;attribute&gt; [NOT] BETWEEN &lt;value1&gt; AND
                                    &lt;value2&gt;</code>
                                </p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem"><p>
                                            <code class="literal">age BETWEEN 20 AND 33 (same as age &gt;=20
                                                AND age&lt;=33)
                                            </code>
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">age NOT BETWEEN 30 AND 40 (same as age
                                                &lt;30 OR age&gt;40)
                                            </code>
                                        </p></li></ul></div><p>
                            </p></li></ul></div><p>
                </p></li><li class="listitem"><p>LIKE
                    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>
                                <code class="literal">&lt;attribute&gt; [NOT] LIKE 'expression'</code>
                            </p><p>
                                <code class="literal">%</code>
                                (percentage sign) is placeholder for many
                                characters,
                                <code class="literal">_</code>
                                (underscore) is placeholder for
                                only one character.
                                <code class="literal">\</code>(Backslash) is used to escape these characters
                                </p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem"><p>
                                            <code class="literal">name LIKE 'Jo%'</code>
                                            (true for 'Joe',
                                            'Josh', 'Joseph' etc.)
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">name LIKE 'Jo_'</code>
                                            (true for 'Joe';
                                            false for 'Josh')
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">name NOT LIKE 'Jo_'</code>
                                            (true for
                                            'Josh'; false for 'Joe')
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">name LIKE 'J_s%'</code>
                                            (true for
                                            'Josh', 'Joseph'; false 'John', 'Joe')
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">name LIKE 'J\%'</code>
                                            (true for 'J%')
                                        </p></li></ul></div><p>
                            </p></li></ul></div><p>
                </p></li><li class="listitem"><p>IN
                    </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>
                                <code class="literal">&lt;attribute&gt; [NOT] IN (val1, val2,
                                    ...)
                                </code>
                                </p><div class="itemizedlist"><ul class="itemizedlist" type="square"><li class="listitem"><p>
                                            <code class="literal">age IN (20, 30, 40)</code>
                                        </p></li><li class="listitem"><p>
                                            <code class="literal">age NOT IN (60, 70)</code>
                                        </p></li></ul></div><p>
                            </p></li></ul></div><p>
                </p></li><li class="listitem"><p>Please note that single quote character should be escaped using two consecutive quotes in a quoted string , example: "text = 'name''s'"  ,  "adv = 'He''s brave, I''m strong'"

                </p></li></ul></div><p>
        Examples:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    <code class="literal">active AND (salary &gt;= 50000 OR (age NOT BETWEEN 20 AND
                        30))
                    </code>
                </p></li><li class="listitem"><p>
                    <code class="literal">age IN (20, 30, 40) AND salary BETWEEN (50000, 80000)</code>
                </p></li></ul></div><p>
    </p><p>
        <span class="bold"><strong>Criteria API</strong></span>
    </p><p>If SQL is not enough or programmable queries are preferred then JPA criteria like API
        can be used. Here is an example:
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.IMap;
<strong class="hl-keyword">import</strong> com.hazelcast.query.Predicate;
<strong class="hl-keyword">import</strong> com.hazelcast.query.PredicateBuilder;
<strong class="hl-keyword">import</strong> com.hazelcast.query.EntryObject;
<strong class="hl-keyword">import</strong> com.hazelcast.config.Config;


Config cfg = <strong class="hl-keyword">new</strong> Config();
HazelcastInstance hz = Hazelcast.newHazelcastInstance(cfg);
IMap map = hz.getMap(<font font-style="normal" color="#008000">"employee"</font>);

EntryObject e = <strong class="hl-keyword">new</strong> PredicateBuilder().getEntryObject();
Predicate predicate = e.is(<font font-style="normal" color="#008000">"active"</font>).and(e.get(<font font-style="normal" color="#008000">"age"</font>).lessThan(<span class="hl-number">30</span>));

Set&lt;Employee&gt; employees = (Set&lt;Employee&gt;) map.values(predicate);

</pre><p>
    </p></div><div class="sect2" title="2.1.5.&nbsp;Indexing"><div class="titlepage"><div><div><h3 class="title"><a name="MapIndex"></a>2.1.5.&nbsp;Indexing</h3></div></div></div><p>
        Hazelcast distributed queries will run on each member in parallel and only results
        will return the conn. When a query runs on a member, Hazelcast will iterate through
        the entire owned entries and find the matching ones. Can we make this even faster? Yes
        by indexing the mostly queried fields. Just like you would do for your database. Of
        course, indexing will add overhead for each
        <code class="literal">write</code>
        operation but
        queries will be a lot faster. If you are querying your map a lot then make sure to add
        indexes for most frequently queried fields. So if your
        <code class="literal">active and age &lt;
            30
        </code>
        query, for example, is used a lot then make sure you add index for
        <code class="literal">active</code>
        and
        <code class="literal">age</code>
        fields. Here is how:
        </p><pre class="programlisting">IMap imap = Hazelcast.getMap(<font font-style="normal" color="#008000">"employees"</font>);
imap.addIndex(<font font-style="normal" color="#008000">"age"</font>, true);        <em class="hl-comment" style="color: silver">// ordered, since we have ranged queries for this field</em>
imap.addIndex(<font font-style="normal" color="#008000">"active"</font>, false);    <em class="hl-comment" style="color: silver">// not ordered, because boolean field cannot have range</em>
</pre><p>
        API
        <code class="literal">IMap.addIndex(fieldName, ordered)</code>
        is used for adding
        index. For a each indexed field, if you have -ranged- queries such
        as<code class="literal">age&gt;30</code>,
        <code class="literal">age BETWEEN 40 AND 60</code>
        then
        <code class="literal">ordered</code>
        parameter should be<code class="literal">true</code>, otherwise set
        it to<code class="literal">false</code>.
    </p><p>
        Also you can define
        <code class="code">IMap</code>
        indexes in configuration.
    </p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    <span class="italic">Hazelcast XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;indexes&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;index</font> <font font-style="bold" color="#0A1777">ordered</font>=<font font-style="bold" color="#008000">"false"</font><font font-style="bold" color="#0A1777">&gt;</font>name<font font-style="bold" color="#0A1777">&lt;/index&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;index</font> <font font-style="bold" color="#0A1777">ordered</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>age<font font-style="bold" color="#0A1777">&lt;/index&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/indexes&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/map&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="italic">Config API</span>
                    </p><pre class="programlisting">
mapConfig.addMapIndexConfig(<strong class="hl-keyword">new</strong> MapIndexConfig(<font font-style="normal" color="#008000">"name"</font>, false));
mapConfig.addMapIndexConfig(<strong class="hl-keyword">new</strong> MapIndexConfig(<font font-style="normal" color="#008000">"age"</font>, true));
                    </pre><p>
                </p></li><li class="listitem"><p>
                    <span class="italic">Spring XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hz:map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:indexes&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:index</font> <font font-style="bold" color="#0A1777">attribute</font>=<font font-style="bold" color="#008000">"name"</font><font font-style="bold" color="#0A1777">/&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:index</font> <font font-style="bold" color="#0A1777">attribute</font>=<font font-style="bold" color="#008000">"age"</font> <font font-style="bold" color="#0A1777">ordered</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/hz:indexes&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hz:map&gt;</font></pre><p>
                </p></li></ul></div><p>
    </p></div><div class="sect2" title="2.1.6.&nbsp;Continuous Query"><div class="titlepage"><div><div><h3 class="title"><a name="MapContinuousQuery"></a>2.1.6.&nbsp;Continuous Query</h3></div></div></div><p>
        One of the new features of version 3.0 is the continuous query.
        You can listen map entry events providing a predicate and so event will be fired for each entry validated by your query.
        IMap has a single method for listening map providing query.
        </p><pre class="programlisting">
    <strong class="hl-tag" style="color: blue">/**
     * Adds an continuous entry listener for this map. Listener will get notified
     * for map add/remove/update/evict events filtered by given predicate.
     *
     * @param listener  entry listener
     * @param predicate predicate for filtering entries
     */</strong>
    <strong class="hl-keyword">void</strong> addEntryListener(EntryListener&lt;K, V&gt; listener, Predicate&lt;K, V&gt; predicate, K key, <strong class="hl-keyword">boolean</strong> includeValue);
                </pre><p>
    </p></div><div class="sect2" title="2.1.7.&nbsp;Entry Processor"><div class="titlepage"><div><div><h3 class="title"><a name="MapEntryProcessor"></a>2.1.7.&nbsp;Entry Processor</h3></div></div></div><p>Starting with version 3.0, Hazelcast supports entry processing. The interface EntryProcessor gives you the ability
        to execute your code on an entry in an atomic way. You do not need any explicit lock on entry.
        Practically, hazelcast locks the entry runs the EntryProcessor, then unlocks the entry.
        If entry processing is the major operation for a map and the map consists of complex objects then using Object type as in-memory-format
        is recommended to minimize serialization cost.
    </p><p>
        There are two methods in IMap interface for entry processing:
        </p><pre class="programlisting"><strong class="hl-tag" style="color: blue">/**
     * Applies the user defined EntryProcessor to the entry mapped by the key.
     * Returns the the object which is result of the process() method of EntryProcessor.
     * &lt;p/&gt;
     *
     * @return result of entry process.
     */</strong>
    Object executeOnKey(K key, EntryProcessor entryProcessor);


    <strong class="hl-tag" style="color: blue">/**
     * Applies the user defined EntryProcessor to the all entries in the map.
     * Returns the results mapped by each key in the map.
     * &lt;p/&gt;
     *
     */</strong>
    Map&lt;K,Object&gt; executeOnAllKeys(EntryProcessor entryProcessor);

</pre><p>
        Using executeOnEntries method, if the number of entries is high
        and you do need the results then returing null in process(..) method is a good practice.
    </p><p>
        Here EntryProcessor interface:
        </p><pre class="programlisting"><strong class="hl-keyword">public</strong> <strong class="hl-keyword">interface</strong> EntryProcessor&lt;K, V&gt; <strong class="hl-keyword">extends</strong> Serializable {

    Object process(Map.Entry&lt;K, V&gt; entry);

    EntryBackupProcessor&lt;K, V&gt; getBackupProcessor();
}
</pre><p>
        If your code is modifying the data then you should also provide a processor for backup entries:
        </p><pre class="programlisting"><strong class="hl-keyword">public</strong> <strong class="hl-keyword">interface</strong> EntryBackupProcessor&lt;K, V&gt; <strong class="hl-keyword">extends</strong> Serializable {

    <strong class="hl-keyword">void</strong> processBackup(Map.Entry&lt;K, V&gt; entry);
}
</pre><p>

                </p><p>
        Also you can remove entry while processing in entry processor. You should just set null for the processed entry's value.
    </p><p>
        <span class="bold"><strong>Example Usage:</strong></span>
        </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> EntryProcessorTest {

    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> testMapEntryProcessor() <strong class="hl-keyword">throws</strong> InterruptedException {
        Config cfg = <strong class="hl-keyword">new</strong> Config();
        cfg.getMapConfig(<font font-style="normal" color="#008000">"default"</font>).setInMemoryFormat(MapConfig.InMemoryFormat.OBJECT);
        HazelcastInstance instance1 = Hazelcast.newHazelcastInstance(cfg);
        HazelcastInstance instance2 = Hazelcast.newHazelcastInstance(cfg);
        IMap&lt;Integer, Integer&gt; map = instance1.getMap(<font font-style="normal" color="#008000">"testMapEntryProcessor"</font>);
        map.put(<span class="hl-number">1</span>, <span class="hl-number">1</span>);
        EntryProcessor entryProcessor = <strong class="hl-keyword">new</strong> IncrementorEntryProcessor();
        map.executeOnKey(<span class="hl-number">1</span>, entryProcessor);
        assertEquals(map.get(<span class="hl-number">1</span>), (Object) <span class="hl-number">2</span>);
        instance1.getLifecycleService().shutdown();
        instance2.getLifecycleService().shutdown();
    }


    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> testMapEntryProcessorAllKeys() <strong class="hl-keyword">throws</strong> InterruptedException {
        StaticNodeFactory nodeFactory = <strong class="hl-keyword">new</strong> StaticNodeFactory(<span class="hl-number">2</span>);
        Config cfg = <strong class="hl-keyword">new</strong> Config();
        cfg.getMapConfig(<font font-style="normal" color="#008000">"default"</font>).setInMemoryFormat(MapConfig.InMemoryFormat.OBJECT);
        HazelcastInstance instance1 = nodeFactory.newHazelcastInstance(cfg);
        HazelcastInstance instance2 = nodeFactory.newHazelcastInstance(cfg);
        IMap&lt;Integer, Integer&gt; map = instance1.getMap(<font font-style="normal" color="#008000">"testMapEntryProcessorAllKeys"</font>);
        <strong class="hl-keyword">int</strong> size = <span class="hl-number">100</span>;
        <strong class="hl-keyword">for</strong> (<strong class="hl-keyword">int</strong> i = <span class="hl-number">0</span>; i &lt; size; i++) {
            map.put(i, i);
        }
        EntryProcessor entryProcessor = <strong class="hl-keyword">new</strong> IncrementorEntryProcessor();
        Map&lt;Integer, Object&gt; res = map.executeOnAllKeys(entryProcessor);
        <strong class="hl-keyword">for</strong> (<strong class="hl-keyword">int</strong> i = <span class="hl-number">0</span>; i &lt; size; i++) {
            assertEquals(map.get(i), (Object) (i+<span class="hl-number">1</span>));
        }
        <strong class="hl-keyword">for</strong> (<strong class="hl-keyword">int</strong> i = <span class="hl-number">0</span>; i &lt; size; i++) {
            assertEquals(map.get(i)+<span class="hl-number">1</span>, res.get(i));
        }
        instance1.getLifecycleService().shutdown();
        instance2.getLifecycleService().shutdown();
    }

    <strong class="hl-keyword">static</strong> <strong class="hl-keyword">class</strong> IncrementorEntryProcessor <strong class="hl-keyword">implements</strong> EntryProcessor, EntryBackupProcessor, Serializable {
        <strong class="hl-keyword">public</strong> Object process(Map.Entry entry) {
            Integer value = (Integer) entry.getValue();
            entry.setValue(value + <span class="hl-number">1</span>);
            <strong class="hl-keyword">return</strong> value + <span class="hl-number">1</span>;
        }

        <strong class="hl-keyword">public</strong> EntryBackupProcessor getBackupProcessor() {
            <strong class="hl-keyword">return</strong> IncrementorEntryProcessor.<strong class="hl-keyword">this</strong>;
        }

        <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> processBackup(Map.Entry entry) {
            entry.setValue((Integer) entry.getValue() + <span class="hl-number">1</span>);
        }
    }


}

</pre><p>
    </p></div><div class="sect2" title="2.1.8.&nbsp;Interceptors"><div class="titlepage"><div><div><h3 class="title"><a name="MapInterceptor"></a>2.1.8.&nbsp;Interceptors</h3></div></div></div><p>
        Another new feature with version 3.0 is the interceptors.
        You can add intercept operations and execute your own business logic synchronously blocking the operation.
        You can change the returned value from a get operation, change the value to be put or cancel operations by throwing exception.
    </p><p>
        Interceptors are different from listeners as with listeners you just take an action after the operation has been completed.
        Interceptor actions are synchronous and you can alter the behaviour of operation, change the values or totally cancel it.
    </p><p>
        IMap API has two method for adding and removing interceptor to the map.
        </p><pre class="programlisting">
    <strong class="hl-tag" style="color: blue">/**
     * Adds an interceptor for this map. Added interceptor will intercept operations
     * and execute user defined methods and will cancel operations if user defined method throw exception.
     * &lt;p/&gt;
     *
     * @param interceptor map interceptor
     * @return id of registered interceptor
     */</strong>
    String addInterceptor(MapInterceptor interceptor);

    <strong class="hl-tag" style="color: blue">/**
     * Removes the given interceptor for this map. So it will not intercept operations anymore.
     * &lt;p/&gt;
     *
     * @param id registration id of map interceptor
     */</strong>
    <strong class="hl-keyword">void</strong> removeInterceptor(String id);

</pre><p>

    </p><p>
        Here MapInterceptor interface:
        </p><pre class="programlisting">

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">interface</strong> MapInterceptor <strong class="hl-keyword">extends</strong> Serializable {

    <strong class="hl-tag" style="color: blue">/**
     * Intercept get operation before returning value.
     * Return another object to change the return value of get(..)
     * Returning null will cause the get(..) operation return original value, namely return null if you do not want to change anything.
     * &lt;p/&gt;
     *
     * @param value the original value to be returned as the result of get(..) operation
     * @return the new value that will be returned by get(..) operation
     */</strong>
    Object interceptGet(Object value);

    <strong class="hl-tag" style="color: blue">/**
     * Called after get(..) operation is completed.
     * &lt;p/&gt;
     *
     * @param value the value returned as the result of get(..) operation
     */</strong>
    <strong class="hl-keyword">void</strong> afterGet(Object value);

    <strong class="hl-tag" style="color: blue">/**
     * Intercept put operation before modifying map data.
     * Return the object to be put into the map.
     * Returning null will cause the put(..) operation to operate as expected, namely no interception.
     * Throwing an exception will cancel the put operation.
     * &lt;p/&gt;
     *
     * @param oldValue the value currently in map
     * @param newValue the new value to be put
     * @return new value after intercept operation
     */</strong>
    Object interceptPut(Object oldValue, Object newValue);

    <strong class="hl-tag" style="color: blue">/**
     * Called after put(..) operation is completed.
     * &lt;p/&gt;
     *
     * @param value the value returned as the result of put(..) operation
     */</strong>
    <strong class="hl-keyword">void</strong> afterPut(Object value);

    <strong class="hl-tag" style="color: blue">/**
     * Intercept remove operation before removing the data.
     * Return the object to be returned as the result of remove operation.
     * Throwing an exception will cancel the remove operation.
     * &lt;p/&gt;
     *
     * @param removedValue the existing value to be removed
     * @return the value to be returned as the result of remove operation
     */</strong>
    Object interceptRemove(Object removedValue);

    <strong class="hl-tag" style="color: blue">/**
     * Called after remove(..) operation is completed.
     * &lt;p/&gt;
     *
     * @param value the value returned as the result of remove(..) operation
     */</strong>
    <strong class="hl-keyword">void</strong> afterRemove(Object value);

}
</pre><p>
                </p><p>
        <span class="bold"><strong>Example Usage:</strong></span>
        </p><pre class="programlisting">

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> InterceptorTest {
    <strong class="hl-keyword">final</strong> String mapName = <font font-style="normal" color="#008000">"map"</font>;


    <em><span class="hl-annotation" style="color: gray">@Test</span></em>
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> testMapInterceptor() <strong class="hl-keyword">throws</strong> InterruptedException {
        Config cfg = <strong class="hl-keyword">new</strong> Config();
        HazelcastInstance instance1 = Hazelcast.newHazelcastInstance(cfg);
        HazelcastInstance instance2 = Hazelcast.newHazelcastInstance(cfg);
        <strong class="hl-keyword">final</strong> IMap&lt;Object, Object&gt; map = instance1.getMap(<font font-style="normal" color="#008000">"testMapInterceptor"</font>);
        SimpleInterceptor interceptor = <strong class="hl-keyword">new</strong> SimpleInterceptor();
        map.addInterceptor(interceptor);
        map.put(<span class="hl-number">1</span>, <font font-style="normal" color="#008000">"New York"</font>);
        map.put(<span class="hl-number">2</span>, <font font-style="normal" color="#008000">"Istanbul"</font>);
        map.put(<span class="hl-number">3</span>, <font font-style="normal" color="#008000">"Tokyo"</font>);
        map.put(<span class="hl-number">4</span>, <font font-style="normal" color="#008000">"London"</font>);
        map.put(<span class="hl-number">5</span>, <font font-style="normal" color="#008000">"Paris"</font>);
        map.put(<span class="hl-number">6</span>, <font font-style="normal" color="#008000">"Cairo"</font>);
        map.put(<span class="hl-number">7</span>, <font font-style="normal" color="#008000">"Hong Kong"</font>);

        <strong class="hl-keyword">try</strong> {
            map.remove(<span class="hl-number">1</span>);
        } <strong class="hl-keyword">catch</strong> (Exception ignore) {
        }
        <strong class="hl-keyword">try</strong> {
            map.remove(<span class="hl-number">2</span>);
        } <strong class="hl-keyword">catch</strong> (Exception ignore) {
        }

        assertEquals(map.size(), <span class="hl-number">6</span>);

        assertEquals(map.get(<span class="hl-number">1</span>), null);
        assertEquals(map.get(<span class="hl-number">2</span>), <font font-style="normal" color="#008000">"ISTANBUL:"</font>);
        assertEquals(map.get(<span class="hl-number">3</span>), <font font-style="normal" color="#008000">"TOKYO:"</font>);
        assertEquals(map.get(<span class="hl-number">4</span>), <font font-style="normal" color="#008000">"LONDON:"</font>);
        assertEquals(map.get(<span class="hl-number">5</span>), <font font-style="normal" color="#008000">"PARIS:"</font>);
        assertEquals(map.get(<span class="hl-number">6</span>), <font font-style="normal" color="#008000">"CAIRO:"</font>);
        assertEquals(map.get(<span class="hl-number">7</span>), <font font-style="normal" color="#008000">"HONG KONG:"</font>);

        map.removeInterceptor(interceptor);
        map.put(<span class="hl-number">8</span>, <font font-style="normal" color="#008000">"Moscow"</font>);

        assertEquals(map.get(<span class="hl-number">8</span>), <font font-style="normal" color="#008000">"Moscow"</font>);
        assertEquals(map.get(<span class="hl-number">1</span>), null);
        assertEquals(map.get(<span class="hl-number">2</span>), <font font-style="normal" color="#008000">"ISTANBUL"</font>);
        assertEquals(map.get(<span class="hl-number">3</span>), <font font-style="normal" color="#008000">"TOKYO"</font>);
        assertEquals(map.get(<span class="hl-number">4</span>), <font font-style="normal" color="#008000">"LONDON"</font>);
        assertEquals(map.get(<span class="hl-number">5</span>), <font font-style="normal" color="#008000">"PARIS"</font>);
        assertEquals(map.get(<span class="hl-number">6</span>), <font font-style="normal" color="#008000">"CAIRO"</font>);
        assertEquals(map.get(<span class="hl-number">7</span>), <font font-style="normal" color="#008000">"HONG KONG"</font>);

    }

    <strong class="hl-keyword">static</strong> <strong class="hl-keyword">class</strong> SimpleInterceptor <strong class="hl-keyword">implements</strong> MapInterceptor, Serializable {

        <em><span class="hl-annotation" style="color: gray">@Override</span></em>
        <strong class="hl-keyword">public</strong> Object interceptGet(Object value) {
            <strong class="hl-keyword">if</strong>(value == null)
                <strong class="hl-keyword">return</strong> null;
            <strong class="hl-keyword">return</strong> value + <font font-style="normal" color="#008000">":"</font>;
        }

        <em><span class="hl-annotation" style="color: gray">@Override</span></em>
        <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> afterGet(Object value) {
        }

        <em><span class="hl-annotation" style="color: gray">@Override</span></em>
        <strong class="hl-keyword">public</strong> Object interceptPut(Object oldValue, Object newValue) {
            <strong class="hl-keyword">return</strong> newValue.toString().toUpperCase();
        }

        <em><span class="hl-annotation" style="color: gray">@Override</span></em>
        <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> afterPut(Object value) {
        }

        <em><span class="hl-annotation" style="color: gray">@Override</span></em>
        <strong class="hl-keyword">public</strong> Object interceptRemove(Object removedValue) {
            <strong class="hl-keyword">if</strong>(removedValue.equals(<font font-style="normal" color="#008000">"ISTANBUL"</font>))
                <strong class="hl-keyword">throw</strong> <strong class="hl-keyword">new</strong> RuntimeException(<font font-style="normal" color="#008000">"you can not remove this"</font>);
            <strong class="hl-keyword">return</strong> removedValue;
        }

        <em><span class="hl-annotation" style="color: gray">@Override</span></em>
        <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> afterRemove(Object value) {
            <em class="hl-comment" style="color: silver">// do something</em>
        }
    }
}

</pre><p>
    </p></div><div class="sect2" title="2.1.9.&nbsp;Near Cache"><div class="titlepage"><div><div><h3 class="title"><a name="MapNearCache"></a>2.1.9.&nbsp;Near Cache</h3></div></div></div><p>Map entries in Hazelcast are partitioned across the cluster. Imagine that you are
        reading key
        <code class="literal">k</code>
        so many times and
        <code class="literal">k</code>
        is owned by another member in your cluster. Each
        <code class="literal">map.get(k)</code>
        will
        be a remote operation; lots of network trips.
        If you have a map that is read-mostly then you should consider creating a
        <code class="literal">Near Cache</code>
        for the map so that reads can be much faster and consume less network traffic.
        All these benefits don't come free. When using near cache, you should consider the following issues:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>JVM will have to hold extra cached data so it will increase the memory consumption.
                </p></li><li class="listitem"><p>If invalidation is turned on and entries are updated frequently, then invalidations will be
                    costly.
                </p></li><li class="listitem"><p>Near cache breaks the strong consistency guarantees; you might be reading stale data.
                </p></li></ul></div><p>
        Near cache is highly recommended for the maps that are read-mostly.
        Here is a near-cache configuration for a map :
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"my-read-mostly-map"</font><font font-style="bold" color="#0A1777">&gt;</font>
        ...
        <font font-style="bold" color="#0A1777">&lt;near-cache&gt;</font>
            <em class="hl-comment" style="color: silver">&lt;!--
                Maximum size of the near cache. When max size is reached,
                cache is evicted based on the policy defined.
                Any integer between 0 and Integer.MAX_VALUE. 0 means
                Integer.MAX_VALUE. Default is 0.
            --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;max-size&gt;</font>5000<font font-style="bold" color="#0A1777">&lt;/max-size&gt;</font>
            <em class="hl-comment" style="color: silver">&lt;!--
                Maximum number of seconds for each entry to stay in the near cache. Entries that are
                older than &lt;time-to-live-seconds&gt; will get automatically evicted from the near cache.
                Any integer between 0 and Integer.MAX_VALUE. 0 means infinite. Default is 0.
            --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;time-to-live-seconds&gt;</font>0<font font-style="bold" color="#0A1777">&lt;/time-to-live-seconds&gt;</font>

            <em class="hl-comment" style="color: silver">&lt;!--
                Maximum number of seconds each entry can stay in the near cache as untouched (not-read).
                Entries that are not read (touched) more than &lt;max-idle-seconds&gt; value will get removed
                from the near cache.
                Any integer between 0 and Integer.MAX_VALUE. 0 means
                Integer.MAX_VALUE. Default is 0.
            --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;max-idle-seconds&gt;</font>60<font font-style="bold" color="#0A1777">&lt;/max-idle-seconds&gt;</font>

            <em class="hl-comment" style="color: silver">&lt;!--
                Valid values are:
                NONE (no extra eviction, &lt;time-to-live-seconds&gt; may still apply),
                LRU  (Least Recently Used),
                LFU  (Least Frequently Used).
                NONE is the default.
                Regardless of the eviction policy used, &lt;time-to-live-seconds&gt; will still apply.
            --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;eviction-policy&gt;</font>LRU<font font-style="bold" color="#0A1777">&lt;/eviction-policy&gt;</font>

            <em class="hl-comment" style="color: silver">&lt;!--
                Should the cached entries get evicted if the entries are changed (updated or removed).
                true of false. Default is true.
            --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;invalidate-on-change&gt;</font>true<font font-style="bold" color="#0A1777">&lt;/invalidate-on-change&gt;</font>

        <font font-style="bold" color="#0A1777">&lt;/near-cache&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/map&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>

    </p></div><div class="sect2" title="2.1.10.&nbsp;Entry Statistics"><div class="titlepage"><div><div><h3 class="title"><a name="MapEntry"></a>2.1.10.&nbsp;Entry Statistics</h3></div></div></div><p>
        Hazelcast keeps extra information about each map entry such as creationTime, lastUpdateTime, lastAccessTime,
        number of hits, version, and this information is exposed to the developer via
        <code class="literal">IMap.getMapEntry(key)</code>
        call. Here is
        an example:
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> com.hazelcast.core.EntryView;

Config cfg = <strong class="hl-keyword">new</strong> Config();
HazelcastInstance hz = Hazelcast.newHazelcastInstance(cfg);
EntryView entry = hz.getMap(<font font-style="normal" color="#008000">"quotes"</font>).getEntryView(<font font-style="normal" color="#008000">"1"</font>);
System.out.println (<font font-style="normal" color="#008000">"size in memory  : "</font> + entry.getCost();
System.out.println (<font font-style="normal" color="#008000">"creationTime    : "</font> + entry.getCreationTime();
System.out.println (<font font-style="normal" color="#008000">"expirationTime  : "</font> + entry.getExpirationTime();
System.out.println (<font font-style="normal" color="#008000">"number of hits  : "</font> + entry.getHits();
System.out.println (<font font-style="normal" color="#008000">"lastAccessedTime: "</font> + entry.getLastAccessTime();
System.out.println (<font font-style="normal" color="#008000">"lastUpdateTime  : "</font> + entry.getLastUpdateTime();
System.out.println (<font font-style="normal" color="#008000">"version         : "</font> + entry.getVersion();
System.out.println (<font font-style="normal" color="#008000">"key             : "</font> + entry.getKey();
System.out.println (<font font-style="normal" color="#008000">"value           : "</font> + entry.getValue();
</pre><p>
    </p></div><div class="sect2" title="2.1.11.&nbsp;In Memory Format"><div class="titlepage"><div><div><h3 class="title"><a name="MapInMemoryFormat"></a>2.1.11.&nbsp;In Memory Format</h3></div></div></div><p>
        With version 3.0, in-memory-format configuration option has been added to distributed map.
        By default Hazelcast stores data into memory in binary (serialized) format.
        But sometimes it can be efficient to store the entries in their objects form especially in cases of local processing like entry processor and queries.
        Setting in-memory-format in map's configuration, you can decide how the data will be store in memory.
        There are three options.
    </p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    <span class="bold"><strong>BINARY (default):</strong></span>This is the default option. Data will be stored in serialized binary format.
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>OBJECT:</strong></span>Data will be stored in de-serialized form.
                        This configuration is good for maps where entry processing and queries form the majority of all operations
                        and the objects are complex ones so serialization cost is respectively high.
                        By storing objects, entry processing will not contain the de-serialization cost.
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>OFFHEAP:</strong></span>Data will be stored in non-heap region of JVM to avoid GC pauses.
                    This option is available for only Hazelcast Enterprise Edition.
                </p></li></ul></div><p>
    </p></div><p>
    <span class="bold"><strong>To learn about wildcard configuration feature, see
        <a class="link" href="#WildcardConfiguration" title="14.5.&nbsp;Wildcard Configuration">Wildcard Configuration
        </a>
        page.
    </strong></span>
</p></div><div class="sect1" title="2.2.&nbsp;Distributed Queue"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Queue"></a>2.2.&nbsp;Distributed Queue</h2></div></div></div><p>Hazelcast distributed queue is an implementation
        of<code class="literal">java.util.concurrent.BlockingQueue</code>.
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> java.util.concurrent.BlockingQueue;
<strong class="hl-keyword">import</strong> java.util.concurrent.TimeUnit;
<strong class="hl-keyword">import</strong> com.hazelcast.config.Config;

Config cfg = <strong class="hl-keyword">new</strong> Config();
HazelcastInstance hz = Hazelcast.newHazelcastInstance(cfg);
BlockingQueue&lt;MyTask&gt; q = hz.getQueue(<font font-style="normal" color="#008000">"tasks"</font>);
q.put(<strong class="hl-keyword">new</strong> MyTask());
MyTask task = q.take();

<strong class="hl-keyword">boolean</strong> offered = q.offer(<strong class="hl-keyword">new</strong> MyTask(), <span class="hl-number">10</span>, TimeUnit.SECONDS);
task = q.poll (<span class="hl-number">5</span>, TimeUnit.SECONDS);
<strong class="hl-keyword">if</strong> (task != null) {
    <em class="hl-comment" style="color: silver">//process task</em>
}
</pre><p>
        FIFO ordering will apply to all queue operations cluster-wide. User objects (such
        as
        <code class="literal">MyTask</code>
        in the example above), that are (en/de)queued have to
        be <code class="literal">Serializable</code>.
        By configuring max-size for queue one can obtain a bounded queue.

    </p><p>
        Sample configuration:
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;queue</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"tasks"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <em class="hl-comment" style="color: silver">&lt;!--
            Maximum size of the queue. When queue size reaches the maximum,
            all put operations will get blocked until the queue size
            goes down below the maximum.
            Any integer between 0 and Integer.MAX_VALUE. 0 means Integer.MAX_VALUE. Default is 0.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;max-size&gt;</font>10000<font font-style="bold" color="#0A1777">&lt;/max-size&gt;</font>

        <em class="hl-comment" style="color: silver">&lt;!--
        Number of backups. If 1 is set as the backup-count for example,
        then all entries of the map will be copied to another JVM for
        fail-safety. Valid numbers are 0 (no backup), 1, 2 ... 6.
        Default is 1.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;backup-count&gt;</font>1<font font-style="bold" color="#0A1777">&lt;/backup-count&gt;</font>

        <em class="hl-comment" style="color: silver">&lt;!--
            Number of async backups. 0 means no backup.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;async-backup-count&gt;</font>0<font font-style="bold" color="#0A1777">&lt;/async-backup-count&gt;</font>

        <em class="hl-comment" style="color: silver">&lt;!--
            QueueStore implementation to persist items.
            'binary' property indicates that storing items will be in binary format
            'memory-limit' property enables 'overflow to store' after reaching limit
            'bulk-load' property enables bulk-loading from store
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;queue-store&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;class-name&gt;</font>com.hazelcast.QueueStore<font font-style="bold" color="#0A1777">&lt;/class-name&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;properties&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"binary"</font><font font-style="bold" color="#0A1777">&gt;</font>false<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"memory-limit"</font><font font-style="bold" color="#0A1777">&gt;</font>1000<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"bulk-load"</font><font font-style="bold" color="#0A1777">&gt;</font>250<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/properties&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/queue-store&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/queue&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>
    </p><div class="sect2" title="2.2.1.&nbsp;Persistence"><div class="titlepage"><div><div><h3 class="title"><a name="QueuePersistence"></a>2.2.1.&nbsp;Persistence</h3></div></div></div><p>Hazelcast allows you to load and store the distributed queue entries from/to a
            persistent datastore such as relational database via a queue-store.
            If queue store is enabled then each entry added to queue will also be stored to configured queue store.
            When the number of items in queue exceed the memory limit, items will only persisted to queue store,
            they will not stored in queue memory.
            Here the queue store configuration options:
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><span class="bold"><strong>Binary:</strong></span>
                    By default Hazelcast stores queue items in serialized form in memory and before inserting into datastore deserializes them.
                    But if you will not reach the queue store from an external application you can prefer the items to be inserted in binary form.
                    So you get rid of de-serialization step that is a performance optimization. By default binary feature is not enabled.
                </li><li class="listitem"><span class="bold"><strong>Memory Limit:</strong></span>
                    This is the number of items after which Hazelcast will just store items to datastore.
                    For example if memory limit is 1000, then 1001st item will be just put into datastore.
                    This feature is useful when you want to avoid out-of-memory conditions. Default number for memory limit is 1000.
                    If you want to always use memory you can set it to Integer.MAX_VALUE.
                </li><li class="listitem"><span class="bold"><strong>Bulk Load:</strong></span>
                    At initialization of queue, items are loaded from QueueStore in bulks. Bulk load is the size these bulks.
                    By default it is 250.
                </li></ul></div><p>

            </p><p>
                Here an example queue store configuration:
                </p><pre class="programlisting">
        <font font-style="bold" color="#0A1777">&lt;queue-store&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;class-name&gt;</font>com.hazelcast.QueueStoreImpl<font font-style="bold" color="#0A1777">&lt;/class-name&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;properties&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"binary"</font><font font-style="bold" color="#0A1777">&gt;</font>false<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"memory-limit"</font><font font-style="bold" color="#0A1777">&gt;</font>10000<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"bulk-load"</font><font font-style="bold" color="#0A1777">&gt;</font>500<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/properties&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/queue-store&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/queue&gt;</font>


<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>
            </p><p>

        </p></div><p>
    <span class="bold"><strong>To learn about wildcard configuration feature, see
        <a class="link" href="#WildcardConfiguration" title="14.5.&nbsp;Wildcard Configuration">Wildcard Configuration
        </a>
        page.
    </strong></span>
</p></div><div class="sect1" title="2.3.&nbsp;Distributed MultiMap"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MultiMap"></a>2.3.&nbsp;Distributed MultiMap</h2></div></div></div><p>
        <code class="literal">MultiMap</code>
        is a specialized map where you can associate a key with multiple values.
        Just like any other distributed data structure implementation in Hazelcast,
        <code class="literal">MultiMap</code>
        is distributed/partitioned and thread-safe.

        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.MultiMap;
<strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> java.util.Collection;
<strong class="hl-keyword">import</strong> com.hazelcast.config.Config;

Config cfg = <strong class="hl-keyword">new</strong> Config();
HazelcastInstance hz = Hazelcast.newHazelcastInstance(cfg);

<em class="hl-comment" style="color: silver">// a multimap to hold &lt;customerId, Order&gt; pairs</em>
MultiMap&lt;String, Order&gt; mmCustomerOrders = hz.getMultiMap(<font font-style="normal" color="#008000">"customerOrders"</font>);
mmCustomerOrders.put(<font font-style="normal" color="#008000">"1"</font>, <strong class="hl-keyword">new</strong> Order (<font font-style="normal" color="#008000">"iPhone"</font>, <span class="hl-number">340</span>));
mmCustomerOrders.put(<font font-style="normal" color="#008000">"1"</font>, <strong class="hl-keyword">new</strong> Order (<font font-style="normal" color="#008000">"MacBook"</font>, <span class="hl-number">1200</span>));
mmCustomerOrders.put(<font font-style="normal" color="#008000">"1"</font>, <strong class="hl-keyword">new</strong> Order (<font font-style="normal" color="#008000">"iPod"</font>, <span class="hl-number">79</span>));

<em class="hl-comment" style="color: silver">// get orders of the customer with customerId 1.</em>
Collection&lt;Order&gt; colOrders = mmCustomerOrders.get (<font font-style="normal" color="#008000">"1"</font>);
<strong class="hl-keyword">for</strong> (Order order : colOrders) {
    <em class="hl-comment" style="color: silver">// process order</em>
}

<em class="hl-comment" style="color: silver">// remove specific key/value pair</em>
<strong class="hl-keyword">boolean</strong> removed = mmCustomerOrders.remove(<font font-style="normal" color="#008000">"1"</font>, <strong class="hl-keyword">new</strong> Order (<font font-style="normal" color="#008000">"iPhone"</font>, <span class="hl-number">340</span>));
</pre><p>

    </p></div><div class="sect1" title="2.4.&nbsp;Distributed Topic"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Topic"></a>2.4.&nbsp;Distributed Topic</h2></div></div></div><p>Hazelcast provides distribution mechanism for publishing messages that are delivered to
        multiple subscribers which is also known as publish/subscribe (pub/sub) messaging model.
        Publish and subscriptions are cluster-wide. When a member subscribes for a topic, it is
        actually registering for messages published by any member in the cluster, including the new
        members joined after you added the listener. Messages are ordered, meaning,
        listeners(subscribers) will process the messages in the order they are actually published.
        If cluster member M publishes messages m1, m2, m3...mn to a topic T, then Hazelcast makes
        sure that all of the subscribers of topic T will receive and process m1, m2, m3...mn in
        order. Therefore there is only single thread invoking onMessage.

        There is also globalOrderEnabled option in topic configuration, which is disabled by default. When
        enabled, it guarantees all nodes listening the same topic will get messages in same order.

        The user shouldn't keep the thread busy and preferably dispatch it via an Executor.
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.Topic;
<strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> com.hazelcast.core.MessageListener;
<strong class="hl-keyword">import</strong> com.hazelcast.config.Config;

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Sample <strong class="hl-keyword">implements</strong> MessageListener&lt;MyEvent&gt; {

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">static</strong> <strong class="hl-keyword">void</strong> main(String[] args) {
        Sample sample = <strong class="hl-keyword">new</strong> Sample();
        Config cfg = <strong class="hl-keyword">new</strong> Config();
        HazelcastInstance hz = Hazelcast.newHazelcastInstance(cfg);
        ITopic topic = hz.getTopic (<font font-style="normal" color="#008000">"default"</font>);
        topic.addMessageListener(sample);
        topic.publish (<strong class="hl-keyword">new</strong> MyEvent());
    }

   <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> onMessage(Message&lt;MyEvent&gt; message) {
        MyEvent myEvent = message.getMessageObject();
        System.out.println(<font font-style="normal" color="#008000">"Message received = "</font> + myEvent.toString());
        <strong class="hl-keyword">if</strong> (myEvent.isHeavyweight()) {
            messageExecutor.execute(<strong class="hl-keyword">new</strong> Runnable() {
                <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> run() {
                    doHeavyweightStuff(myEvent);
                }
            });
        }
    }

    <em class="hl-comment" style="color: silver">// ...</em>

    <strong class="hl-keyword">private</strong> <strong class="hl-keyword">static</strong> <strong class="hl-keyword">final</strong> Executor messageExecutor = Executors.newSingleThreadExecutor();
}

</pre><p>
    </p><p>
    <span class="bold"><strong>To learn about wildcard configuration feature, see
        <a class="link" href="#WildcardConfiguration" title="14.5.&nbsp;Wildcard Configuration">Wildcard Configuration
        </a>
        page.
    </strong></span>
</p></div><div class="sect1" title="2.5.&nbsp;Distributed Set"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Set"></a>2.5.&nbsp;Distributed Set</h2></div></div></div><p>Distributed Set is distributed and concurrent implementation
        of<code class="literal">java.util.Set</code>. Set doesn't allow duplicate elements, so elements in
        the set should have proper hashCode and equals methods.
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> java.util.Set;
<strong class="hl-keyword">import</strong> java.util.Iterator;
<strong class="hl-keyword">import</strong> com.hazelcast.config.Config;

Config cfg = <strong class="hl-keyword">new</strong> Config();
HazelcastInstance hz = Hazelcast.newHazelcastInstance(cfg);

java.util.Set set = hz.getSet(<font font-style="normal" color="#008000">"IBM-Quote-History"</font>);
set.add(<strong class="hl-keyword">new</strong> Price(<span class="hl-number">10</span>, time1));
set.add(<strong class="hl-keyword">new</strong> Price(<span class="hl-number">11</span>, time2));
set.add(<strong class="hl-keyword">new</strong> Price(<span class="hl-number">12</span>, time3));
set.add(<strong class="hl-keyword">new</strong> Price(<span class="hl-number">11</span>, time4));
<em class="hl-comment" style="color: silver">//....</em>
Iterator it = set.iterator();
<strong class="hl-keyword">while</strong> (it.hasNext()) { 
    Price price = (Price) it.next(); 
    <em class="hl-comment" style="color: silver">//analyze</em>
}

</pre><p>
    </p></div><div class="sect1" title="2.6.&nbsp;Distributed List"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="List"></a>2.6.&nbsp;Distributed List</h2></div></div></div><p>Distributed List is very similar to distributed set, but it allows duplicate elements.
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> java.util.List;
<strong class="hl-keyword">import</strong> java.util.Iterator;
<strong class="hl-keyword">import</strong> com.hazelcast.config.Config;

Config cfg = <strong class="hl-keyword">new</strong> Config();
HazelcastInstance hz = Hazelcast.newHazelcastInstance(cfg);

java.util.List list = hz.getList(<font font-style="normal" color="#008000">"IBM-Quote-Frequency"</font>);
list.add(<strong class="hl-keyword">new</strong> Price(<span class="hl-number">10</span>));
list.add(<strong class="hl-keyword">new</strong> Price(<span class="hl-number">11</span>));
list.add(<strong class="hl-keyword">new</strong> Price(<span class="hl-number">12</span>));
list.add(<strong class="hl-keyword">new</strong> Price(<span class="hl-number">11</span>));
list.add(<strong class="hl-keyword">new</strong> Price(<span class="hl-number">12</span>));
        
<em class="hl-comment" style="color: silver">//....</em>
Iterator it = list.iterator();
<strong class="hl-keyword">while</strong> (it.hasNext()) { 
    Price price = (Price) it.next(); 
    <em class="hl-comment" style="color: silver">//analyze</em>
}
</pre><p>
    </p></div><div class="sect1" title="2.7.&nbsp;Distributed Lock"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Lock"></a>2.7.&nbsp;Distributed Lock</h2></div></div></div><p>
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> com.hazelcast.config.Config;
<strong class="hl-keyword">import</strong> java.util.concurrent.locks.Lock;

Config cfg = <strong class="hl-keyword">new</strong> Config();
HazelcastInstance hz = Hazelcast.newHazelcastInstance(cfg);
Lock lock = hz.getLock(myLockedObject);
lock.lock();
<strong class="hl-keyword">try</strong> {
    <em class="hl-comment" style="color: silver">// do something here</em>
} <strong class="hl-keyword">finally</strong> {
    lock.unlock();
} 
 
</pre><p>

        <code class="literal">java.util.concurrent.locks.Lock.tryLock()</code>
        with timeout is also supported. All operations on the Lock that
        <code class="literal">Hazelcast.getLock(Object obj)</code>
        returns are cluster-wide and Lock behaves just like
        <code class="literal">java.util.concurrent.lock.ReentrantLock</code>.

        </p><pre class="programlisting"><strong class="hl-keyword">if</strong> (lock.tryLock (<span class="hl-number">5000</span>, TimeUnit.MILLISECONDS)) {
    <strong class="hl-keyword">try</strong> {  
       <em class="hl-comment" style="color: silver">// do some stuff here..  </em>
    } 
    <strong class="hl-keyword">finally</strong> {  
      lock.unlock();  
    }   
} 
</pre><p>

        Locks are fail-safe. If a member holds a lock and some of the members go down, cluster will keep your locks safe
        and available. Moreover, when a member leaves the cluster, all the locks acquired by this dead member will be
        removed so that these locks can be available for live members immediately.

    </p></div><div class="sect1" title="2.8.&nbsp;Distributed Events"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Events"></a>2.8.&nbsp;Distributed Events</h2></div></div></div><p>
        Hazelcast allows you to register for entry events to get notified when entries added, updated or removed.
        Listeners are cluster-wide. When a member adds a listener, it is actually registering for events originated in
        any member in the cluster. When a new member joins, events originated at the new member will also be delivered.

        All events are ordered, meaning, listeners will receive and process the events in the order they are actually
        occurred.

        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> java.util.Queue;
<strong class="hl-keyword">import</strong> java.util.Map; 
<strong class="hl-keyword">import</strong> java.util.Set; 
<strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> com.hazelcast.core.ItemListener;
<strong class="hl-keyword">import</strong> com.hazelcast.core.EntryListener;
<strong class="hl-keyword">import</strong> com.hazelcast.core.EntryEvent; 
<strong class="hl-keyword">import</strong> com.hazelcast.config.Config;

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Sample <strong class="hl-keyword">implements</strong> ItemListener, EntryListener {

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">static</strong> <strong class="hl-keyword">void</strong> main(String[] args) { 
        Sample sample = <strong class="hl-keyword">new</strong> Sample();
        Config cfg = <strong class="hl-keyword">new</strong> Config();
        HazelcastInstance hz = Hazelcast.newHazelcastInstance(cfg);
        IQueue queue = hz.getQueue (<font font-style="normal" color="#008000">"default"</font>);
        IMap   map   = hz.getMap   (<font font-style="normal" color="#008000">"default"</font>);
        ISet   set   = hz.getSet   (<font font-style="normal" color="#008000">"default"</font>);
        <em class="hl-comment" style="color: silver">//listen for all added/updated/removed entries</em>
        queue.addItemListener(sample, true);
        set.addItemListener  (sample, true); 
        map.addEntryListener (sample, true);        
        <em class="hl-comment" style="color: silver">//listen for an entry with specific key </em>
        map.addEntryListener (sample, <font font-style="normal" color="#008000">"keyobj"</font>);        
    } 

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> entryAdded(EntryEvent event) {
        System.out.println(<font font-style="normal" color="#008000">"Entry added key="</font> + event.getKey() + <font font-style="normal" color="#008000">", value="</font> + event.getValue());
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> entryRemoved(EntryEvent event) {
        System.out.println(<font font-style="normal" color="#008000">"Entry removed key="</font> + event.getKey() + <font font-style="normal" color="#008000">", value="</font> + event.getValue());
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> entryUpdated(EntryEvent event) {
        System.out.println(<font font-style="normal" color="#008000">"Entry update key="</font> + event.getKey() + <font font-style="normal" color="#008000">", value="</font> + event.getValue());
    } 

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> entryEvicted(EntryEvent event) {
        System.out.println(<font font-style="normal" color="#008000">"Entry evicted key="</font> + event.getKey() + <font font-style="normal" color="#008000">", value="</font> + event.getValue());
    } 
    
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> itemAdded(Object item) {
        System.out.println(<font font-style="normal" color="#008000">"Item added = "</font> + item);
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> itemRemoved(Object item) {
        System.out.println(<font font-style="normal" color="#008000">"Item removed = "</font> + item);
    }     
}
       
</pre><p>

    </p></div></div><div class="chapter" title="Chapter&nbsp;3.&nbsp;Serialization"><div class="titlepage"><div><div><h2 class="title"><a name="Serialization"></a>Chapter&nbsp;3.&nbsp;Serialization</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#DataSerializable">3.1. Data Serializable</a></span></dt><dt><span class="sect1"><a href="#PortableSerialization">3.2. Portable Serialization</a></span></dt><dt><span class="sect1"><a href="#CustomSerialization">3.3. Custom Serialization</a></span></dt></dl></div><p>

    </p><p>All your distributed objects such as your key and value objects, objects you offer into
        distributed queue and your distributed callable/runnable objects have to
        be<code class="literal">Serializable</code>.
    </p><p>
    </p><p>Hazelcast serializes all your objects into an instance
        of<code class="literal">com.hazelcast.nio.serialization.Data</code>.
        <code class="literal">Data</code>
        is the binary
        representation of an object.

        When Hazelcast serializes an object into<code class="literal">Data</code>,
        it first checks whether the object is an instance of
        <code class="literal">com.hazelcast.nio.serialization.DataSerializable</code>, if not it checks if it is an instance of
        <code class="literal">com.hazelcast.nio.serialization.Portable</code>
        and serializes it accordingly.

        For the following types Hazelcast optimizes the serialization a user can not override this behaviour.


        <code class="literal">Byte</code>,
        <code class="literal">Boolean</code>,
        <code class="literal">Character</code>,
        <code class="literal">Short</code>,
        <code class="literal">Integer</code>,
        <code class="literal">Long</code>,
        <code class="literal">Float</code>,
        <code class="literal">Double</code>,
        <code class="literal">byte[]</code>,
        <code class="literal">char[]</code>,
        <code class="literal">short[]</code>,
        <code class="literal">int[]</code>,
        <code class="literal">long[]</code>,
        <code class="literal">float[]</code>,
        <code class="literal">double[]</code>,
        <code class="literal">String</code>,


        Hazelcast also optimizes the following types, however you can override them by creating a custom serializer
        and registering it.
        See
        <a class="link" href="#CustomSerialization" title="3.3.&nbsp;Custom Serialization">Custom Serialization</a>
        for more information.

        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Date</li><li class="listitem">BigInteger</li><li class="listitem">BigDecimal</li><li class="listitem">Class</li><li class="listitem">Externalizable</li><li class="listitem">Serializable</li></ul></div><p>

        Not that if the object is not instance of any explicit type, Hazelcast uses Java Serialization
        for Serializable and Externalizable objects. The default behaviour can be changed using a
        <a class="link" href="#CustomSerialization" title="3.3.&nbsp;Custom Serialization">Custom Serialization</a>.

    </p><p>
</p><div class="sect1" title="3.1.&nbsp;Data Serializable"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="DataSerializable"></a>3.1.&nbsp;Data Serializable</h2></div></div></div><p>
        For a faster serialization of objects, Hazelcast recommends to implement
        <code class="literal">com.hazelcast.nio.serialization.IdentifiedDataSerializable</code>
        which is slightly better
        version of
        <code class="literal">com.hazelcast.nio.serialization.DataSerializable</code>.
        </p><p>
            Here is an example of a class implementing
            <code class="literal">com.hazelcast.nio.serialization.DataSerializable</code>
            interface.
            </p><pre class="programlisting"><strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Address <strong class="hl-keyword">implements</strong> com.hazelcast.nio.serialization.DataSerializable {
    <strong class="hl-keyword">private</strong> String street;
    <strong class="hl-keyword">private</strong> <strong class="hl-keyword">int</strong> zipCode;
    <strong class="hl-keyword">private</strong> String city;
    <strong class="hl-keyword">private</strong> String state;

    <strong class="hl-keyword">public</strong> Address() {}

    <em class="hl-comment" style="color: silver">//getters setters..</em>

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> writeData(ObjectDataOutput out) <strong class="hl-keyword">throws</strong> IOException {
        out.writeUTF(street);
        out.writeInt(zipCode);
        out.writeUTF(city);
        out.writeUTF(state);
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> readData(ObjectDataInput in) <strong class="hl-keyword">throws</strong> IOException {
        street    = in.readUTF();
        zipCode = in.readInt();
        city    = in.readUTF();
        state    = in.readUTF();
    }
}
</pre><p>
        </p><p>
        Lets take a look at another example which is encapsulating a
        <code class="literal">DataSerializable</code>
        field.</p><pre class="programlisting"><strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Employee <strong class="hl-keyword">implements</strong> com.hazelcast.nio.serialization.DataSerializable {
    <strong class="hl-keyword">private</strong> String firstName;
    <strong class="hl-keyword">private</strong> String lastName;
    <strong class="hl-keyword">private</strong> <strong class="hl-keyword">int</strong> age;
    <strong class="hl-keyword">private</strong> <strong class="hl-keyword">double</strong> salary;
    <strong class="hl-keyword">private</strong> Address address; <em class="hl-comment" style="color: silver">//address itself is DataSerializable</em>

    <strong class="hl-keyword">public</strong> Employee() {}

    <em class="hl-comment" style="color: silver">//getters setters..</em>

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> writeData(ObjectDataOutput out) <strong class="hl-keyword">throws</strong> IOException {
        out.writeUTF(firstName);
        out.writeUTF(lastName);
        out.writeInt(age);
        out.writeDouble (salary);
        address.writeData (out);
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> readData (ObjectDataInput in) <strong class="hl-keyword">throws</strong> IOException {
        firstName = in.readUTF();
        lastName  = in.readUTF();
        age       = in.readInt();
        salary       = in.readDouble();
        address   = <strong class="hl-keyword">new</strong> Address();
        <em class="hl-comment" style="color: silver">// since Address is DataSerializable let it read its own internal state</em>
        address.readData (in);
    }
}
</pre><p>As you can see, since
        <code class="literal">address</code>
        field itself
        is<code class="literal">DataSerializable</code>, it is calling
        <code class="literal">address.writeData(out)</code>
        when writing and
        <code class="literal">address.readData(in)</code>
        when reading. Also note that the order of writing and reading fields should be the same.
        While Hazelcast serializes a DataSerializable it writes the className first and when de-serializes it,
        className is used to instantiate the object using reflection.


        <span class="bold"><strong>IdentifiedDataSerializable</strong></span>

        To avoid the reflection and long class names
        <code class="literal">IdentifiedDataSerializable</code>
        can be used instead of<code class="literal">DataSerializable</code>. Note that
        <code class="literal">IdentifiedDataSerializable</code>
        extends
        <code class="literal">DataSerializable</code>
        and introduces two new methods.

        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                int getId();
            </li><li class="listitem">
                int getFactoryId();
            </li></ul></div><p>

        IdentifiedDataSerializable uses
        <code class="literal">getId()</code>
        instead of className and uses getFactoryId()
        to load the class given the Id.
        To complete the implementation a
        <code class="literal">com.hazelcast.nio.serialization.DataSerializableFactory</code>
        should also be implemented and registered into
        <code class="literal">SerializationConfig</code>
        which can be accessed from
        <code class="literal">Config.getSerializationConfig()</code>. The Factories responsibility is to return an instance of
        the right
        <code class="literal">IdentifiedDataSerializable</code>
        object, given the id. So far this is the most efficient
        way of Serialization that Hazelcast supports of the shelf.

    </p></div><div class="sect1" title="3.2.&nbsp;Portable Serialization"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="PortableSerialization"></a>3.2.&nbsp;Portable Serialization</h2></div></div></div><p>
        As an alternative to the existing serialization methods, Hazelcast offers a Portable serialization that have
        the following advantages

        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                Support multiversion of the same object type.
            </li><li class="listitem">
                Fetching individual fields without having to rely on reflection
            </li><li class="listitem">
                Querying and indexing support without de-serialization and/or reflection
            </li></ul></div><p>

        </p><p>
            In order to support these features, a serialized Portable object contains meta information like the version
            and
            the concrete location of the each field in the binary data. This way Hazelcast is able to navigate in the
            byte[]
            and de-serialize only the required field without actually de-serializing the whole object which improves
            the Query performance.
        </p><p>
        </p><p>
            With multiversion support, you can have two nodes where each of them having different versions of the same
            Object and Hazelcast will store both meta information and use the correct one to serialize and de-serialize
            Portable objects depending on the node. This is very helpful when you are doing a rolling upgrade without
            shutting down the cluster.
        </p><p>
        </p><p>
            Also note that Portable serialization is totally language independent and is used as
            the binary protocol between Hazelcast server and clients.
        </p><p>
        </p><p>
            A sample Portable implementation of a Foo class will look like the following.

            </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Foo <strong class="hl-keyword">implements</strong> Portable{
    <strong class="hl-keyword">final</strong> <strong class="hl-keyword">static</strong> <strong class="hl-keyword">int</strong> ID = <span class="hl-number">5</span>;

    <strong class="hl-keyword">private</strong> String foo;

    <strong class="hl-keyword">public</strong> String getFoo() {
        <strong class="hl-keyword">return</strong> foo;
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> setFoo(String foo) {
        <strong class="hl-keyword">this</strong>.foo = foo;
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">int</strong> getFactoryId() {
        <strong class="hl-keyword">return</strong> <span class="hl-number">1</span>;
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">int</strong> getClassId() {
        <strong class="hl-keyword">return</strong> ID;
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> writePortable(PortableWriter writer) <strong class="hl-keyword">throws</strong> IOException {
        writer.writeUTF(<font font-style="normal" color="#008000">"foo"</font>, foo);
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> readPortable(PortableReader reader) <strong class="hl-keyword">throws</strong> IOException {
        foo = reader.readUTF(<font font-style="normal" color="#008000">"foo"</font>);
    }
}
        </pre><p>
        </p><p>
        </p><p>
            Similar to
            <code class="literal">IdentifiedDataSerializable</code>,
            a Portable Class must provide
            <code class="literal">classId</code>
            and<code class="literal">factoryId</code>. The Factory object will be used to create
            the Portable object given the <code class="literal">classId</code>.
        </p><p>

        </p><p>

            A sample
            <code class="literal">Factory</code>
            could be implemented as following:
            </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> MyPortableFactory <strong class="hl-keyword">implements</strong> PortableFactory {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <strong class="hl-keyword">public</strong> Portable create(<strong class="hl-keyword">int</strong> classId) {
        <strong class="hl-keyword">if</strong> (Foo.ID == classId)
            <strong class="hl-keyword">return</strong> <strong class="hl-keyword">new</strong> Foo();
        <strong class="hl-keyword">else</strong> <strong class="hl-keyword">return</strong> null;
     }
}
            </pre><p>

            The last step is to register the
            <code class="literal">Factory</code>
            to the <code class="literal">SerializationConfig</code>.

            </p><p>
                Programmatic Configuration
                </p><pre class="programlisting">
Config config = <strong class="hl-keyword">new</strong> Config();
config.getSerializationConfig().addPortableFactory(<span class="hl-number">1</span>, <strong class="hl-keyword">new</strong> MyPortableFactory());
                </pre><p>
            </p><p>

            </p><p>
                XML Configuration
                </p><pre class="programlisting">
&lt;hazelcast&gt;
    &lt;serialization&gt;
        &lt;portable-version&gt;<span class="hl-number">0</span>&lt;/portable-version&gt;
        &lt;portable-factories&gt;
            &lt;portable-factory factory-id=<font font-style="normal" color="#008000">"1"</font>&gt;com.hazelcast.nio.serialization.MyPortableFactory&lt;/portable-factory&gt;
        &lt;/portable-factories&gt;
    &lt;/serialization&gt;
&lt;/hazelcast&gt;
                </pre><p>
            </p><p>

            Note that the <code class="literal">id</code> that is passed to the
            <code class="literal">SerializationConfig</code>
            is same as the
            <code class="literal">factoryId</code>
            that
            <code class="literal">Foo</code>
            class returns.
        </p><p>

        </p><p>
            TODO: ClassDefinitionBuilder...
        </p><p>
    </p></div><div class="sect1" title="3.3.&nbsp;Custom Serialization"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="CustomSerialization"></a>3.3.&nbsp;Custom Serialization</h2></div></div></div><p>
        Hazelcast lets you to plug a custom serializer to be used for serialization of objects.
    </p>
    Let's say you have a class
    <code class="literal">Foo</code>
    and you would like to customize the serialization.
    The reasons could be
    <code class="literal">Foo</code>
    is not Serializable or you are not happy with the default serialization.

    <pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Foo {
    <strong class="hl-keyword">private</strong> String foo;
    <strong class="hl-keyword">public</strong> String getFoo() {
        <strong class="hl-keyword">return</strong> foo;
    }
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> setFoo(String foo) {
        <strong class="hl-keyword">this</strong>.foo = foo;
    }
}
            </pre>

    Let's say our custom serialization will serialize
    <code class="literal">Foo</code>
    into XML. First we need to implement a
    <code class="literal">com.hazelcast.nio.serialization.StreamSerializer</code>.
    A very simple one that uses XMLEncoder and XMLDecoder, would look like the following:

    <pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">static</strong> <strong class="hl-keyword">class</strong> FooXmlSerializer <strong class="hl-keyword">implements</strong> StreamSerializer&lt;Foo&gt; {

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">int</strong> getTypeId() {
        <strong class="hl-keyword">return</strong> <span class="hl-number">10</span>;
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> write(ObjectDataOutput out, Foo object) <strong class="hl-keyword">throws</strong> IOException {
        ByteArrayOutputStream bos = <strong class="hl-keyword">new</strong> ByteArrayOutputStream();
        XMLEncoder encoder = <strong class="hl-keyword">new</strong> XMLEncoder(bos);
        encoder.writeObject(object);
        encoder.close();
        out.write(bos.toByteArray());
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <strong class="hl-keyword">public</strong> Foo read(ObjectDataInput in) <strong class="hl-keyword">throws</strong> IOException {
        <strong class="hl-keyword">final</strong> InputStream inputStream = (InputStream) in;
        XMLDecoder decoder = <strong class="hl-keyword">new</strong> XMLDecoder(inputStream);
        <strong class="hl-keyword">return</strong> (Foo) decoder.readObject();
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> destroy() {
    }
}

            </pre>

    Note that the
    <code class="literal">typeId</code>
    must be unique as Hazelcast will use it to lookup the StreamSerializer while
    it de-serializes the object. Now the last required step is to register the StreamSerializer to the Configuration

    <p>Programmatic Configuration</p><pre class="programlisting">
SerializerConfig sc = <strong class="hl-keyword">new</strong> SerializerConfig().
        setImplementation(<strong class="hl-keyword">new</strong> FooXmlSerializer()).
        setTypeClass(Foo.<strong class="hl-keyword">class</strong>);
Config config = <strong class="hl-keyword">new</strong> Config();
config.getSerializationConfig().addSerializerConfig(sc);
            </pre><p>XML Configuration</p><pre class="programlisting">
&lt;hazelcast&gt;
    &lt;serialization&gt;
        &lt;serializers&gt;
            &lt;serializer type-<strong class="hl-keyword">class</strong>=<font font-style="normal" color="#008000">"com.www.Foo"</font>&gt;com.www.FooXmlSerializer&lt;/serializer&gt;
        &lt;/serializers&gt;
    &lt;/serialization&gt;
&lt;/hazelcast&gt;
    </pre>
    
    From now on, Hazelcast will use <code class="literal">FooXmlSerializer</code> to serialize Foo objects. 
    This way one can write an adapter (<code class="literal">StreamSerializer</code>) for any Serialization framework
    and plug it into Hazelcast.

</div></div><div class="chapter" title="Chapter&nbsp;4.&nbsp;Elastic Memory (Enterprise Edition Only)"><div class="titlepage"><div><div><h2 class="title"><a name="ElasticMemory"></a>Chapter&nbsp;4.&nbsp;Elastic Memory
            <sup>(Enterprise Edition Only)</sup>
        </h2></div></div></div><div class="simplesect"><div class="titlepage"></div><p>
        By default, Hazelcast stores your distributed data (map entries, queue items) into Java heap
        which is subject to garbage collection. As your heap gets bigger, garbage collection might
        cause your application to pause tens of seconds, badly effecting your application performance
        and response times. Elastic Memory is Hazelcast with off-heap (direct) memory storage to avoid GC pauses.
        Even if you have terabytes of cache in-memory with lots of updates, GC will have almost no effect;
        resulting in more predictable latency and throughput.
    </p><p>
        Here are the steps to enable Elastic Memory:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    Set the maximum direct memory JVM can allocate.
                    Example
                    <code class="literal">java -XX:MaxDirectMemorySize=60G ...</code>
                </p></li><li class="listitem"><p>
                    Enable Elastic Memory by setting
                    <code class="literal">hazelcast.elastic.memory.enabled</code>
                    <a class="link" href="#ConfigurationProperties" title="14.6.&nbsp;Advanced Configuration Properties">Hazelcast Config Property</a>
                    to
                    <code class="literal">true</code>.
                </p></li><li class="listitem"><p>
                    Set the total direct memory size for HazelcastInstance by setting
                    <code class="literal">hazelcast.elastic.memory.total.size</code>
                    <a class="link" href="#ConfigurationProperties" title="14.6.&nbsp;Advanced Configuration Properties">Hazelcast Config Property</a>. Size can be
                    in MB or GB and abbreviation can be used, such as
                    <code class="literal">60G</code>
                    and
                    <code class="literal">500M</code>.
                </p></li><li class="listitem"><p>
                    Set the chunk size by setting
                    <code class="literal">hazelcast.elastic.memory.chunk.size</code>
                    <a class="link" href="#ConfigurationProperties" title="14.6.&nbsp;Advanced Configuration Properties">Hazelcast Config Property</a>.
                    Hazelcast will partition the entire offheap memory into chunks. Default chunk size is 1K.
                </p></li><li class="listitem"><p>
                    You can enable <code class="code">sun.misc.Unsafe</code> based off-heap storage implementation
                    instead of <code class="code">java.nio.DirectByteBuffer</code> based one by setting
                    <code class="literal">hazelcast.elastic.memory.unsafe.enabled</code> property to true.
                    Default value is false.
                </p></li><li class="listitem"><p>
                    Configure maps you want them to use Elastic Memory by setting
                    <code class="literal">StorageFormat</code>
                    to<code class="code">OFFHEAP</code>.
                    Default value is<code class="code">BINARY</code>.
                </p><p>
                    Using XML configuration:
                    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
        ...
        <font font-style="bold" color="#0A1777">&lt;in-memory-format&gt;</font>OFFHEAP<font font-style="bold" color="#0A1777">&lt;/in-memory-format&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/map&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font></pre><p>
                </p><p>
                    Using Config API:
                    </p><pre class="programlisting">MapConfig mapConfig = <strong class="hl-keyword">new</strong> MapConfig();
mapConfig.setStorageFormat(StorageFormat.OFFHEAP);</pre><p>
                </p></li></ul></div><p>
    </p><p>
        <span class="italic">Also see how to <a class="link" href="#EnterpriseConfig" title="14.8.&nbsp;Setting License Key (Enterprise Edition Only)">configure license key</a>.</span>
    </p></div></div><div class="chapter" title="Chapter&nbsp;5.&nbsp;Security (Enterprise Edition Only)"><div class="titlepage"><div><div><h2 class="title"><a name="Security"></a>Chapter&nbsp;5.&nbsp;Security
            <sup>(Enterprise Edition Only)</sup>
        </h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#Credentials">5.1. Credentials</a></span></dt><dt><span class="sect1"><a href="#ClusterLoginModule">5.2. ClusterLoginModule</a></span></dt><dt><span class="sect1"><a href="#MemberSecurity">5.3. Cluster Member Security</a></span></dt><dt><span class="sect1"><a href="#ClientSecurity">5.4. Native Client Security</a></span></dt><dd><dl><dt><span class="sect2"><a href="#d0e2217">5.4.1. Authentication</a></span></dt><dt><span class="sect2"><a href="#d0e2253">5.4.2. Authorization</a></span></dt><dt><span class="sect2"><a href="#d0e2312">5.4.3. Permissions</a></span></dt></dl></dd></dl></div><p>
    Hazelcast has an extensible, JAAS based security feature
    which can be used to authenticate both cluster members and clients and to do access control checks
    on client operations. Access control can be done according to endpoint principal and/or endpoint address.
    Security can be enabled and configured either in configuration xml or using Config api.
    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast</font> <font font-style="bold" color="#0A1777">xsi:schemaLocation</font>=<font font-style="bold" color="#008000">"http://www.hazelcast.com/schema/config
    http://www.hazelcast.com/schema/config/hazelcast-config-3.1.xsd"</font>
    <font font-style="bold" color="#0A1777">xmlns</font>=<font font-style="bold" color="#008000">"http://www.hazelcast.com/schema/config"</font>
    <font font-style="bold" color="#0A1777">xmlns:xsi</font>=<font font-style="bold" color="#008000">"http://www.w3.org/2001/XMLSchema-instance"</font><font font-style="bold" color="#0A1777">&gt;</font>
    
    ...
    <font font-style="bold" color="#0A1777">&lt;security</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;/security&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>
    </p><pre class="programlisting">Config cfg = <strong class="hl-keyword">new</strong> Config();
SecurityConfig securityCfg = cfg.getSecurityConfig();
securityCfg.setEnabled(true);
</pre><p>

    <span class="italic">Also see how to <a class="link" href="#EnterpriseConfig" title="14.8.&nbsp;Setting License Key (Enterprise Edition Only)">configure license key</a>.</span>
</p><div class="sect1" title="5.1.&nbsp;Credentials"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Credentials"></a>5.1.&nbsp;Credentials</h2></div></div></div><p>One of the key elements in Hazelcast security is
        <code class="literal">Credentials</code>
        object. It
        is used to carry all credentials of an endpoint (member or client).
        <code class="literal">Credentials</code>
        is an interface which extends
        <code class="code">Serializable</code>
        and has three methods to be implemented. Users,
        according to their needs, can either implement
        <code class="literal">Credentials</code>
        interface or
        extend
        <code class="literal">AbstractCredentials</code>
        class which is an abstract implementation of
        <code class="literal">Credentials</code>.
        </p><pre class="programlisting">
<strong class="hl-keyword">package</strong> com.hazelcast.security;
...
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">interface</strong> Credentials <strong class="hl-keyword">extends</strong> Serializable {

    String getEndpoint();

    <strong class="hl-keyword">void</strong> setEndpoint(String endpoint) ;
    
    String getPrincipal() ;    
}
</pre><p>
        <code class="code">Credentials.setEndpoint()</code>
        method is called by Hazelcast when auth request arrives to node
        before authentication takes place.
        </p><pre class="programlisting">
<strong class="hl-keyword">package</strong> com.hazelcast.security;
...
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">abstract</strong> <strong class="hl-keyword">class</strong> AbstractCredentials <strong class="hl-keyword">implements</strong> Credentials, DataSerializable {
    <strong class="hl-keyword">private</strong> <strong class="hl-keyword">transient</strong> String endpoint;
    <strong class="hl-keyword">private</strong> String principal;

    ...
}
</pre><p>
        <code class="literal">UsernamePasswordCredentials</code>, a custom implementation of
        <code class="literal">Credentials</code>
        can be found in Hazelcast
        <code class="code">com.hazelcast.security</code>
        package. It is used by default configuration during
        authentication process of both members and clients.
        </p><pre class="programlisting">
<strong class="hl-keyword">package</strong> com.hazelcast.security;
...
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> UsernamePasswordCredentials <strong class="hl-keyword">extends</strong> Credentials {
    <strong class="hl-keyword">private</strong> <strong class="hl-keyword">byte</strong>[] password;
    ...
}
</pre><p>
    </p></div><div class="sect1" title="5.2.&nbsp;ClusterLoginModule"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ClusterLoginModule"></a>5.2.&nbsp;ClusterLoginModule</h2></div></div></div><p>All security attributes are carried in
        <code class="literal">Credentials</code>
        object and
        <code class="literal">Credentials</code>
        is used by
        <a class="link" href="http://download.oracle.com/javase/1.5.0/docs/api/javax/security/auth/spi/LoginModule.html" target="_top">
            <code class="literal">LoginModule</code>
        </a>
        s during authentication process. Accessing
        user supplied attributes from
        <a class="link" href="http://download.oracle.com/javase/1.5.0/docs/api/javax/security/auth/spi/LoginModule.html" target="_top">
            <code class="literal">LoginModule</code>
        </a>
        s is done by
        <a class="link" href="http://download.oracle.com/javase/1.5.0/docs/api/javax/security/auth/callback/CallbackHandler.html" target="_top">
            <code class="literal">CallbackHandler</code>
        </a>
        s. To provide access to
        <code class="literal">Credentials</code>
        object, Hazelcast uses its own specialized
        <code class="literal">CallbackHandler</code>. During initialization of
        <code class="literal">LoginModule</code>s Hazelcast will pass this special
        <code class="literal">CallbackHandler</code>into
        <code class="code">LoginModule.initialize()</code>
        method.
    </p><p>
        <code class="literal">LoginModule</code>
        implementations should create an instance of
        <code class="literal">com.hazelcast.security.CredentialsCallback</code>
        and call
        <code class="code">handle(Callback[] callbacks)</code>
        method of
        <code class="literal">CallbackHandler</code>
        during login process.
        <code class="code">CredentialsCallback.getCredentials()</code>
        will return supplied
        <code class="literal">Credentials</code>
        object.
        </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> CustomLoginModule <strong class="hl-keyword">implements</strong> LoginModule {
    CallbackHandler callbackHandler;
    Subject subject;

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">final</strong> <strong class="hl-keyword">void</strong> initialize(Subject subject, CallbackHandler callbackHandler,
        Map&lt;String, ?&gt; sharedState, Map&lt;String, ?&gt; options) {
        <strong class="hl-keyword">this</strong>.subject = subject;
        <strong class="hl-keyword">this</strong>.callbackHandler = callbackHandler;
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">final</strong> <strong class="hl-keyword">boolean</strong> login() <strong class="hl-keyword">throws</strong> LoginException {
        CredentialsCallback callback = <strong class="hl-keyword">new</strong> CredentialsCallback();
        <strong class="hl-keyword">try</strong> {
            callbackHandler.handle(<strong class="hl-keyword">new</strong> Callback[]{callback});
            credentials = cb.getCredentials();
        } <strong class="hl-keyword">catch</strong> (Exception e) {
            <strong class="hl-keyword">throw</strong> <strong class="hl-keyword">new</strong> LoginException(e.getMessage());
        }
        ...
    }
...
}
</pre><p>
    </p><p>* To use default Hazelcast permission policy, an instance of
        <code class="code">com.hazelcast.security.ClusterPrincipal</code>
        that holding
        <code class="literal">Credentials</code>
        object must be created and added to
        <code class="code">Subject.principals</code>
        on<code class="code">LoginModule.commit()</code>.
        </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> MyCustomLoginModule <strong class="hl-keyword">implements</strong> LoginModule {
...
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">boolean</strong> commit() <strong class="hl-keyword">throws</strong> LoginException {
        ...
        <strong class="hl-keyword">final</strong> Principal principal = <strong class="hl-keyword">new</strong> ClusterPrincipal(credentials);
        subject.getPrincipals().add(principal);
        
        <strong class="hl-keyword">return</strong> true;
    }
    ...
}
</pre><p>
    </p><p>Hazelcast also has an abstract implementation of
        <code class="literal">LoginModule</code>
        that does
        callback and cleanup operations and holds resulting
        <code class="literal">Credentials</code>
        instance.
        <code class="literal">LoginModule</code>s extending
        <code class="literal">ClusterLoginModule</code>
        can access<code class="literal">Credentials</code>,
        <code class="literal">Subject</code>,
        <code class="literal">LoginModule</code>
        instances and
        <code class="code">options</code>
        and
        <code class="code">sharedState</code>
        maps. Extending
        <code class="literal">ClusterLoginModule</code>
        is recommended instead of implementing all required stuff.
        </p><pre class="programlisting">
<strong class="hl-keyword">package</strong> com.hazelcast.security;
...
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">abstract</strong> <strong class="hl-keyword">class</strong> ClusterLoginModule <strong class="hl-keyword">implements</strong> LoginModule {

    <strong class="hl-keyword">protected</strong> <strong class="hl-keyword">abstract</strong> <strong class="hl-keyword">boolean</strong> onLogin() <strong class="hl-keyword">throws</strong> LoginException;
    <strong class="hl-keyword">protected</strong> <strong class="hl-keyword">abstract</strong> <strong class="hl-keyword">boolean</strong> onCommit() <strong class="hl-keyword">throws</strong> LoginException;
    <strong class="hl-keyword">protected</strong> <strong class="hl-keyword">abstract</strong> <strong class="hl-keyword">boolean</strong> onAbort() <strong class="hl-keyword">throws</strong> LoginException;
    <strong class="hl-keyword">protected</strong> <strong class="hl-keyword">abstract</strong> <strong class="hl-keyword">boolean</strong> onLogout() <strong class="hl-keyword">throws</strong> LoginException;

}
</pre><p>
    </p></div><div class="sect1" title="5.3.&nbsp;Cluster Member Security"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MemberSecurity"></a>5.3.&nbsp;Cluster Member Security</h2></div></div></div><p>Hazelcast supports standard Java Security (JAAS) based authentication between cluster
        members. You should configure one or more<code class="code">LoginModule</code>s and an instance of
        <code class="literal">com.hazelcast.security.ICredentialsFactory</code>. Although Hazelcast has
        default implementations using cluster group and group-password and
        <code class="literal">UsernamePasswordCredentials</code>
        on authentication, it is advised to
        implement these according to specific needs and environment.
        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;security</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;member-credentials-factory</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.examples.MyCredentialsFactory"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;properties&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"property1"</font><font font-style="bold" color="#0A1777">&gt;</font>value1<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"property2"</font><font font-style="bold" color="#0A1777">&gt;</font>value2<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/properties&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/member-credentials-factory&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;member-login-modules&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;login-module</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.examples.MyRequiredLoginModule"</font> <font font-style="bold" color="#0A1777">usage</font>=<font font-style="bold" color="#008000">"required"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;properties&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"property3"</font><font font-style="bold" color="#0A1777">&gt;</font>value3<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/properties&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/login-module&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;login-module</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.examples.MySufficientLoginModule"</font> <font font-style="bold" color="#0A1777">usage</font>=<font font-style="bold" color="#008000">"sufficient"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;properties&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"property4"</font><font font-style="bold" color="#0A1777">&gt;</font>value4<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/properties&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/login-module&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;login-module</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.examples.MyOptionalLoginModule"</font> <font font-style="bold" color="#0A1777">usage</font>=<font font-style="bold" color="#008000">"optional"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;properties&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"property5"</font><font font-style="bold" color="#0A1777">&gt;</font>value5<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/properties&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/login-module&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/member-login-modules&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/security&gt;</font>
</pre><p>
        You can define as many as<code class="literal">LoginModule</code>s you wanted in
        configuration. Those are executed in given order. Usage attribute has 4 values; 'required',
        'requisite', 'sufficient' and 'optional' as defined in
        <code class="code">javax.security.auth.login.AppConfigurationEntry.LoginModuleControlFlag</code>.
    </p><p>
        </p><pre class="programlisting">
<strong class="hl-keyword">package</strong> com.hazelcast.security;
<strong class="hl-tag" style="color: blue">/**
 * ICredentialsFactory is used to create Credentials objects to be used
 * during node authentication before connection accepted by master node.
 */</strong>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">interface</strong> ICredentialsFactory {

    <strong class="hl-keyword">void</strong> configure(GroupConfig groupConfig, Properties properties);

    Credentials newCredentials();

    <strong class="hl-keyword">void</strong> destroy();
}
</pre><p>
    </p><p>
        Properties defined in configuration are passed to
        <code class="code">ICredentialsFactory.configure()</code>
        method as
        <code class="code">java.util.Properties</code>
        and to
        <code class="code">LoginModule.initialize()</code>
        method as<code class="code">java.util.Map</code>.
    </p></div><div class="sect1" title="5.4.&nbsp;Native Client Security"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ClientSecurity"></a>5.4.&nbsp;Native Client Security</h2></div></div></div><p>Hazelcast's Client security includes both authentication and authorization.</p><div class="sect2" title="5.4.1.&nbsp;Authentication"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2217"></a>5.4.1.&nbsp;Authentication</h3></div></div></div><p>Authentication mechanism just works the same as cluster member authentication. Implementation of client
            authentication requires a
            <code class="literal">Credentials</code>
            and one or more
            <code class="literal">LoginModule</code>(s). Client side does not have/need a factory object to
            create
            <code class="literal">Credentials</code>
            objects like<code class="literal">ICredentialsFactory</code>.
            <code class="literal">Credentials</code>
            must be created at client side and sent to connected node
            during connection process.
            </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;security</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;client-login-modules&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;login-module</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.examples.MyRequiredClientLoginModule"</font> <font font-style="bold" color="#0A1777">usage</font>=<font font-style="bold" color="#008000">"required"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;properties&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"property3"</font><font font-style="bold" color="#0A1777">&gt;</font>value3<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/properties&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/login-module&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;login-module</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.examples.MySufficientClientLoginModule"</font> <font font-style="bold" color="#0A1777">usage</font>=<font font-style="bold" color="#008000">"sufficient"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;properties&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"property4"</font><font font-style="bold" color="#0A1777">&gt;</font>value4<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/properties&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/login-module&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;login-module</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.examples.MyOptionalClientLoginModule"</font> <font font-style="bold" color="#0A1777">usage</font>=<font font-style="bold" color="#008000">"optional"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;properties&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"property5"</font><font font-style="bold" color="#0A1777">&gt;</font>value5<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/properties&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/login-module&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/client-login-modules&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/security&gt;</font>
</pre><p>
        </p><p>You can define as many as<code class="literal">LoginModule</code>s you wanted in
            configuration. Those are executed in given order. Usage attribute has 4 values; 'required',
            'requisite', 'sufficient' and 'optional' as defined in
            <code class="code">javax.security.auth.login.AppConfigurationEntry.LoginModuleControlFlag</code>.
        </p><p>
            </p><pre class="programlisting">
<strong class="hl-keyword">final</strong> Credentials credentials = <strong class="hl-keyword">new</strong> UsernamePasswordCredentials(<font font-style="normal" color="#008000">"dev"</font>, <font font-style="normal" color="#008000">"dev-pass"</font>);
HazelcastInstance client = HazelcastClient.newHazelcastClient(credentials, <font font-style="normal" color="#008000">"localhost"</font>);
</pre><p>
        </p></div><div class="sect2" title="5.4.2.&nbsp;Authorization"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2253"></a>5.4.2.&nbsp;Authorization</h3></div></div></div><p>Hazelcast client authorization is configured by a client permission policy. Hazelcast has a default
            permission policy
            implementation that uses permission configurations defined in Hazelcast security configuration. Default
            policy permission checks are done
            against instance types (map, queue...), instance names (map, queue etc. name), instance actions (put, read,
            remove, add...),
            client endpoint addresses and client principal defined by
            <code class="literal">Credentials</code>
            object.
            <span class="italic">Instance and principal names and endpoint addresses
                can be defined as wildcards(*). Take a look at
                <a class="link" href="#WildcardConfiguration" title="14.5.&nbsp;Wildcard Configuration">Wildcard Name Configuration</a>
                and
                <a class="link" href="#ConfigSpecifyInterfaces" title="14.2.2.&nbsp;Specifying Network Interfaces">Newtwork Configuration</a>
                pages.
            </span>
        </p><p>
            </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;security</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;client-permissions&gt;</font>
        <em class="hl-comment" style="color: silver">&lt;!-- Principal 'admin' from endpoint '127.0.0.1' has all permissions. --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;all-permissions</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"admin"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;endpoint&gt;</font>127.0.0.1<font font-style="bold" color="#0A1777">&lt;/endpoint&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/all-permissions&gt;</font>
        
        <em class="hl-comment" style="color: silver">&lt;!-- Principals named 'dev' from all endpoints have 'create', 'destroy', 
            'put', 'read' permissions for map named 'default'. --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;map-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"dev"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;actions&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;action&gt;</font>create<font font-style="bold" color="#0A1777">&lt;/action&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;action&gt;</font>destroy<font font-style="bold" color="#0A1777">&lt;/action&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;action&gt;</font>put<font font-style="bold" color="#0A1777">&lt;/action&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;action&gt;</font>read<font font-style="bold" color="#0A1777">&lt;/action&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/actions&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/map-permission&gt;</font>
        
        <em class="hl-comment" style="color: silver">&lt;!-- All principals from endpoints '127.0.0.1' or matching to '10.10.*.*' 
            have 'put', 'read', 'remove' permissions for map
            whose name matches to 'com.foo.entity.*'. --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;map-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"com.foo.entity.*"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;endpoint&gt;</font>10.10.*.*<font font-style="bold" color="#0A1777">&lt;/endpoint&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;endpoint&gt;</font>127.0.0.1<font font-style="bold" color="#0A1777">&lt;/endpoint&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;actions&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;action&gt;</font>put<font font-style="bold" color="#0A1777">&lt;/action&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;action&gt;</font>read<font font-style="bold" color="#0A1777">&lt;/action&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;action&gt;</font>remove<font font-style="bold" color="#0A1777">&lt;/action&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/actions&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/map-permission&gt;</font>
        
        <em class="hl-comment" style="color: silver">&lt;!-- Principals named 'dev' from endpoints matching to either 
            '192.168.1.1-100' or '192.168.2.*' 
            have 'create', 'add', 'remove' permissions for all queues. --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;queue-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"*"</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"dev"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;endpoint&gt;</font>192.168.1.1-100<font font-style="bold" color="#0A1777">&lt;/endpoint&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;endpoint&gt;</font>192.168.2.*<font font-style="bold" color="#0A1777">&lt;/endpoint&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;actions&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;action&gt;</font>create<font font-style="bold" color="#0A1777">&lt;/action&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;action&gt;</font>add<font font-style="bold" color="#0A1777">&lt;/action&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;action&gt;</font>remove<font font-style="bold" color="#0A1777">&lt;/action&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/actions&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/queue-permission&gt;</font>
        
        <em class="hl-comment" style="color: silver">&lt;!-- All principals from all endpoints have transaction permission.--&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;transaction-permission /&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/client-permissions&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/security&gt;</font>
</pre><p>
        </p><p>Users also can define their own policy by implementing<code class="literal">
            com.hazelcast.security.IPermissionPolicy</code>.
            </p><pre class="programlisting">
<strong class="hl-keyword">package</strong> com.hazelcast.security;
<strong class="hl-tag" style="color: blue">/**
 * IPermissionPolicy is used to determine any Subject's 
 * permissions to perform a security sensitive Hazelcast operation.
 *
 */</strong>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">interface</strong> IPermissionPolicy {
    <strong class="hl-keyword">void</strong> configure(SecurityConfig securityConfig, Properties properties);
    
    PermissionCollection getPermissions(Subject subject, Class&lt;? <strong class="hl-keyword">extends</strong> Permission&gt; type);
    
    <strong class="hl-keyword">void</strong> destroy();
}</pre><p>
        </p><p>Permission policy implementations can access
            <code class="code">client-permissions</code>
            in
            configuration by using
            <code class="code">SecurityConfig.getClientPermissionConfigs()</code>
            during
            <code class="code">configure(SecurityConfig securityConfig, Properties properties)</code>
            method
            is called by Hazelcast.
            <code class="code">IPermissionPolicy.getPermissions(Subject subject,
                Class&lt;? extends Permission&gt; type)
            </code>
            method is used to determine a client
            request has been granted permission to do a security-sensitive operation. Permission
            policy should return a
            <code class="literal">PermissionCollection</code>
            containing permissions of
            given type for given<code class="literal">Subject</code>. Hazelcast access controller will call
            <code class="code">PermissionCollection.implies(Permission)</code>
            on returning
            <code class="literal">PermissionCollection</code>
            and will decide if current
            <code class="literal">Subject</code>
            has permitted to access to requested resources or
            not.
        </p></div><div class="sect2" title="5.4.3.&nbsp;Permissions"><div class="titlepage"><div><div><h3 class="title"><a name="d0e2312"></a>5.4.3.&nbsp;Permissions</h3></div></div></div><p>
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                        <span class="bold"><strong>All Permission</strong></span>
                    </p><p>
                        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;all-permissions</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"principal"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/all-permissions&gt;</font>
</pre><p>
                    </p></li><li class="listitem"><p>
                        <span class="bold"><strong>Map Permission</strong></span>
                    </p><p>
                        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;map-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"name"</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"principal"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;actions&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/actions&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/map-permission&gt;</font>
</pre><p>
                    </p><p>
                        <span class="bold"><strong>Actions:</strong></span>
                        <span class="italic">all, create, destroy,
                            put, read, remove, lock, intercept, index, listen
                        </span>
                    </p></li><li class="listitem"><p>
                        <span class="bold"><strong>Queue Permission</strong></span>
                    </p><p>
                        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;queue-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"name"</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"principal"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;actions&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/actions&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/queue-permission&gt;</font>
</pre><p>
                    </p><p>
                        <span class="bold"><strong>Actions:</strong></span>
                        <span class="italic">all, create, destroy,
                            add, remove, read, listen
                        </span>
                    </p></li><li class="listitem"><p>
                        <span class="bold"><strong>Multimap Permission</strong></span>
                    </p><p>
                        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;multimap-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"name"</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"principal"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;actions&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/actions&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/multimap-permission&gt;</font>
</pre><p>
                    </p><p>
                        <span class="bold"><strong>Actions:</strong></span>
                        <span class="italic">all, create, destroy,
                            put, read, remove, listen, lock
                        </span>
                    </p></li><li class="listitem"><p>
                        <span class="bold"><strong>Topic Permission</strong></span>
                    </p><p>
                        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;topic-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"name"</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"principal"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;actions&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/actions&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/topic-permission&gt;</font>
</pre><p>
                    </p><p>
                        <span class="bold"><strong>Actions:</strong></span>
                        <span class="italic">create, destroy,
                            publish, listen
                        </span>
                    </p></li><li class="listitem"><p>
                        <span class="bold"><strong>List Permission</strong></span>
                    </p><p>
                        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;list-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"name"</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"principal"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;actions&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/actions&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/list-permission&gt;</font>
</pre><p>
                    </p><p>
                        <span class="bold"><strong>Actions:</strong></span>
                        <span class="italic">all, create, destroy,
                            add, read, remove, listen
                        </span>
                    </p></li><li class="listitem"><p>
                        <span class="bold"><strong>Set Permission</strong></span>
                    </p><p>
                        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;set-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"name"</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"principal"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;actions&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/actions&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/set-permission&gt;</font>
</pre><p>
                    </p><p>
                        <span class="bold"><strong>Actions:</strong></span>
                        <span class="italic">all, create, destroy,
                            add, read, remove, listen
                        </span>
                    </p></li><li class="listitem"><p>
                        <span class="bold"><strong>Lock Permission</strong></span>
                    </p><p>
                        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;lock-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"name"</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"principal"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;actions&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/actions&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/lock-permission&gt;</font>
</pre><p>
                    </p><p>
                        <span class="bold"><strong>Actions:</strong></span>
                        <span class="italic">all, create, destroy,
                            lock, read
                        </span>
                    </p></li><li class="listitem"><p>
                        <span class="bold"><strong>AtomicLong Permission</strong></span>
                    </p><p>
                        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;atomic-long-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"name"</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"principal"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;actions&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/actions&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/atomic-long-permission&gt;</font>
</pre><p>
                    </p><p>
                        <span class="bold"><strong>Actions:</strong></span>
                        <span class="italic">all, create, destroy,
                            read, modify
                        </span>
                    </p></li><li class="listitem"><p>
                        <span class="bold"><strong>CountDownLatch Permission</strong></span>
                    </p><p>
                        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;countdown-latch-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"name"</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"principal"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;actions&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/actions&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/countdown-latch-permission&gt;</font>
</pre><p>
                    </p><p>
                        <span class="bold"><strong>Actions:</strong></span>
                        <span class="italic">all, create, destroy,
                            modify, read
                        </span>
                    </p></li><li class="listitem"><p>
                        <span class="bold"><strong>Semaphore Permission</strong></span>
                    </p><p>
                        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;semaphore-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"name"</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"principal"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;actions&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/actions&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/semaphore-permission&gt;</font>
</pre><p>
                    </p><p>
                        <span class="bold"><strong>Actions:</strong></span>
                        <span class="italic">all, create, destroy,
                            acquire, release, read
                        </span>
                    </p></li><li class="listitem"><p>
                        <span class="bold"><strong>Executor Service Permission</strong></span>
                    </p><p>
                        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;executor-service-permission</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"name"</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"principal"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;actions&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/actions&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/executor-service-permission&gt;</font>
</pre><p>
                    </p><p>
                        <span class="bold"><strong>Actions:</strong></span>
                        <span class="italic">all, create, destroy</span>
                    </p></li><li class="listitem"><p>
                        <span class="bold"><strong>Transaction Permission</strong></span>
                    </p><p>
                        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;transaction-permission</font> <font font-style="bold" color="#0A1777">principal</font>=<font font-style="bold" color="#008000">"principal"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;endpoints&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/endpoints&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/transaction-permission&gt;</font>
</pre><p>
                    </p></li></ol></div><p>
        </p></div></div></div><div class="chapter" title="Chapter&nbsp;6.&nbsp;Data Affinity"><div class="titlepage"><div><div><h2 class="title"><a name="DataAffinity"></a>Chapter&nbsp;6.&nbsp;Data Affinity</h2></div></div></div><div class="simplesect"><div class="titlepage"></div><p>
        <span class="emphasis"><em>Co-location of related data and computation!</em></span>
    </p><p>Hazelcast has a standard way of finding out which member owns/manages each key object.
        Following operations will be routed to the same member, since all of them are
        operating based on the same key, "key1".
    </p><pre class="programlisting">
        
Config cfg = <strong class="hl-keyword">new</strong> Config();
HazelcastInstance instance = Hazelcast.newHazelcastInstance(cfg);
Map mapa = instance.getMap(<font font-style="normal" color="#008000">"mapa"</font>);
Map mapb = instance.getMap(<font font-style="normal" color="#008000">"mapb"</font>);
Map mapc = instance.getMap(<font font-style="normal" color="#008000">"mapc"</font>);
mapa.put(<font font-style="normal" color="#008000">"key1"</font>, value);
mapb.get(<font font-style="normal" color="#008000">"key1"</font>);
mapc.remove(<font font-style="normal" color="#008000">"key1"</font>);
<em class="hl-comment" style="color: silver">// since map names are different, operation will be manipulating</em>
<em class="hl-comment" style="color: silver">// different entries, but the operation will take place on the</em>
<em class="hl-comment" style="color: silver">// same member since the keys ("key1") are the same</em>

instance.getLock (<font font-style="normal" color="#008000">"key1"</font>).lock();
<em class="hl-comment" style="color: silver">// lock operation will still execute on the same member of the cluster</em>
<em class="hl-comment" style="color: silver">// since the key ("key1") is same</em>

instance.getExecutorService().executeOnKeyOwner(runnable, <font font-style="normal" color="#008000">"key1"</font>);
<em class="hl-comment" style="color: silver">// distributed execution will execute the 'runnable' on the same member</em>
<em class="hl-comment" style="color: silver">// since "key1" is passed as the key.</em>
    </pre><p>So when the keys are the same then entries are stored on the same node. But we
        sometimes want to have related entries stored on the same node. Consider customer
        and his/her order entries. We would have customers map with customerId as the key
        and orders map with orderId as the key. Since customerId and orderIds are different
        keys, customer and his/her orders may fall into different members/nodes in your cluster.
        So how can we have them stored on the same node? The trick here is to create an affinity
        between customer and orders. If we can somehow make them part of the same partition then
        these entries will be co-located. We achieve this by making orderIds
        <code class="literal">PartitionAware</code>
    </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> OrderKey <strong class="hl-keyword">implements</strong> Serializable, PartitionAware {
    <strong class="hl-keyword">int</strong> customerId;
    <strong class="hl-keyword">int</strong> orderId;

    <strong class="hl-keyword">public</strong> OrderKey(<strong class="hl-keyword">int</strong> orderId, <strong class="hl-keyword">int</strong> customerId) {
        <strong class="hl-keyword">this</strong>.customerId = customerId;
        <strong class="hl-keyword">this</strong>.orderId = orderId;
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">int</strong> getCustomerId() {
        <strong class="hl-keyword">return</strong> customerId;
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">int</strong> getOrderId() {
        <strong class="hl-keyword">return</strong> orderId;
    }

    <strong class="hl-keyword">public</strong> Object getPartitionKey() {
        <strong class="hl-keyword">return</strong> customerId;
    }

    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <strong class="hl-keyword">public</strong> String toString() {
        <strong class="hl-keyword">return</strong> <font font-style="normal" color="#008000">"OrderKey{"</font> +
                <font font-style="normal" color="#008000">"customerId="</font> + customerId +
                <font font-style="normal" color="#008000">", orderId="</font> + orderId +
                <font font-style="normal" color="#008000">'}'</font>;
    }
}
        </pre><p>
    Notice that OrderKey implements <code class="literal">PartitionAware</code> and
    <code class="literal">getPartitionKey()</code> returns the
    <code class="literal">customerId</code>. This will make sure that <code class="literal">Customer</code>
    entry and its <code class="literal">Order</code>s are going to be stored on the same node.
    </p><pre class="programlisting">
Config cfg = <strong class="hl-keyword">new</strong> Config();
HazelcastInstance instance = Hazelcast.newHazelcastInstance(cfg);
Map mapCustomers = instance.getMap(<font font-style="normal" color="#008000">"customers"</font>)
Map mapOrders = instance.getMap(<font font-style="normal" color="#008000">"orders"</font>)
<em class="hl-comment" style="color: silver">// create the customer entry with customer id = 1</em>
mapCustomers.put(<span class="hl-number">1</span>, customer);
<em class="hl-comment" style="color: silver">// now create the orders for this customer</em>
mapOrders.put(<strong class="hl-keyword">new</strong> OrderKey(<span class="hl-number">21</span>, <span class="hl-number">1</span>), order);
mapOrders.put(<strong class="hl-keyword">new</strong> OrderKey(<span class="hl-number">22</span>, <span class="hl-number">1</span>), order);
mapOrders.put(<strong class="hl-keyword">new</strong> OrderKey(<span class="hl-number">23</span>, <span class="hl-number">1</span>), order);
    </pre><p>
        Let say you have a customers map where
        <code class="literal">customerId</code>
        is the key, the customer
        object is the value, customer object contains the customer's orders and
        you want to remove one of the orders of a customer and return the number of
        remaining orders. Here is how you would normally do it:
    </p><pre class="programlisting">
        
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">static</strong> <strong class="hl-keyword">int</strong> removeOrder(<strong class="hl-keyword">long</strong> customerId, <strong class="hl-keyword">long</strong> orderId) <strong class="hl-keyword">throws</strong> Exception {
    IMap&lt;Long, Customer&gt; mapCustomers = instance.getMap(<font font-style="normal" color="#008000">"customers"</font>);
    mapCustomers.lock (customerId);
    Customer customer = mapCustomers. get(customerId);
    customer.removeOrder (orderId);
    mapCustomers.put(customerId, customer);
    mapCustomers.unlock(customerId);
    <strong class="hl-keyword">return</strong> customer.getOrderCount();
}
</pre><p>
    There are couple of things we should consider:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>There are four distributed operations there.. lock, get, put,
                unlock.. Can we reduce the number of distributed operations?
            </p></li><li class="listitem"><p>Customer object may not be that big but can we not have to
                pass that object through the wire? Notice that, we are
                actually passing customer object through the wire twice; get
                and put.
            </p></li></ol></div><p>
    </p><p>So instead, why not moving the computation over to the member
        (JVM) where your customer data actually is.
        Here is how you can do this with distributed executor service:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                Send a
                <code class="literal">PartitionAware</code>
                <code class="literal">Callable</code>
                task.
            </p></li><li class="listitem"><p>
                <code class="literal">Callable</code>
                does the deletion of the order right there and returns with
                the remaining order count.
            </p></li><li class="listitem"><p>
            Upon completion of the
            <code class="literal">Callable</code>
            task, return the
            result (remaining order count). Plus you do not
            have to wait until the the task complete; since
            distributed executions are asynchronous, you can
            do other things in the meantime.
            </p></li></ol></div><p>
    Here is a sample code:
    </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">static</strong> <strong class="hl-keyword">int</strong> removeOrder(<strong class="hl-keyword">long</strong> customerId, <strong class="hl-keyword">long</strong> orderId) <strong class="hl-keyword">throws</strong> Exception {
    ExecutorService es = instance.getExecutorService(<font font-style="normal" color="#008000">"orderexecutor"</font>);
    OrderDeletionTask task = <strong class="hl-keyword">new</strong> OrderDeletionTask(customerId, orderId);
    Future future = es.submit(task);
    <strong class="hl-keyword">int</strong> remainingOrders = future.get();
    <strong class="hl-keyword">return</strong> remainingOrders;
}

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">static</strong> <strong class="hl-keyword">class</strong> OrderDeletionTask
   <strong class="hl-keyword">implements</strong> Callable&lt;Integer&gt;, PartitionAware, Serializable, HazelcastInstanceAware {

   <strong class="hl-keyword">private</strong> <strong class="hl-keyword">long</strong> customerId;
   <strong class="hl-keyword">private</strong> <strong class="hl-keyword">long</strong> orderId;
   <strong class="hl-keyword">private</strong> <strong class="hl-keyword">transient</strong> HazelcastInstance hz;

   <strong class="hl-keyword">public</strong> OrderDeletionTask() {
   }
   <strong class="hl-keyword">public</strong> OrderDeletionTask(<strong class="hl-keyword">long</strong> customerId, <strong class="hl-keyword">long</strong> orderId) {
       <strong class="hl-keyword">super</strong>();
       <strong class="hl-keyword">this</strong>.customerId = customerId;
       <strong class="hl-keyword">this</strong>.orderId = orderId;
   }
   <strong class="hl-keyword">public</strong> Integer call () {
       IMap&lt;Long, Customer&gt; mapCustomers = hz.getMap(<font font-style="normal" color="#008000">"customers"</font>);
       mapCustomers.lock (customerId);
       Customer customer = mapCustomers. get(customerId);
       customer.removeOrder (orderId);
       mapCustomers.put(customerId, customer);
       mapCustomers.unlock(customerId);
       <strong class="hl-keyword">return</strong> customer.getOrderCount();
   }
   <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> setHazelcastInstance(HazelcastInstance hz) {
       <strong class="hl-keyword">this</strong>.hz = hz;
   }
   <strong class="hl-keyword">public</strong> Object getPartitionKey() {
       <strong class="hl-keyword">return</strong> customerId;
   }
}
        </pre><p>
    </p><p>
    Benefits of doing the same operation with
    distributed
    <code class="literal">ExecutorService</code>
    based on the key are:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                Only one distributed execution (<code class="literal">es.submit(task)</code>), instead of four.
            </p></li><li class="listitem"><p>
                Less data is sent over the wire.
            </p></li><li class="listitem"><p>
                Since lock/update/unlock cycle is done locally (local to the customer data), lock duration for the
                <code class="literal">Customer</code>
                entry is much less so enabling higher concurrency.
            </p></li></ul></div><p>
    </p></div></div><div class="chapter" title="Chapter&nbsp;7.&nbsp;Monitoring with JMX"><div class="titlepage"><div><div><h2 class="title"><a name="JMX"></a>Chapter&nbsp;7.&nbsp;Monitoring with JMX</h2></div></div></div><div class="simplesect"><div class="titlepage"></div><p>
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Add the following system properties to enable
                <a class="link" href="http://download.oracle.com/javase/1.5.0/docs/guide/management/agent.html" target="_top">jmx agent
                </a>
            </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>-Dcom.sun.management.jmxremote</p></li><li class="listitem"><p>-Dcom.sun.management.jmxremote.port=_portNo_ (to specify jmx port)
                        <span class="emphasis"><em>optional</em></span>
                    </p></li><li class="listitem"><p>-Dcom.sun.management.jmxremote.authenticate=false (to disable jmx auth)
                        <span class="emphasis"><em>optional</em></span>
                    </p></li></ul></div></li><li class="listitem"><p>Enable Hazelcast property
                <span class="emphasis"><em>hazelcast.jmx</em></span>
                </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>using Hazelcast configuration (api, xml, spring)</p></li><li class="listitem"><p>or set system property -Dhazelcast.jmx=true</p></li></ul></div><p>
            </p></li><li class="listitem"><p>Use jconsole, jvisualvm (with mbean plugin) or another jmx-compliant monitoring
                tool.
            </p></li></ul></div><p>
    <span class="bold"><strong>Following attributes can be monitored:</strong></span>
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Cluster
                </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>config</p></li><li class="listitem"><p>group name</p></li><li class="listitem"><p>count of members and their addresses (host:port)</p></li><li class="listitem"><p>operations: restart, shutdown cluster</p></li></ul></div><p>
            </p></li><li class="listitem"><p>Member
                </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>inet address</p></li><li class="listitem"><p>port</p></li></ul></div><p>
            </p></li><li class="listitem"><p>Statistics
                </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>count of instances</p></li><li class="listitem"><p>number of instances created, destroyed since startup</p></li><li class="listitem"><p>max instances created, destroyed per second</p></li></ul></div><p>
            </p></li><li class="listitem"><p>AtomicLong
                </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>name</p></li><li class="listitem"><p>actual value</p></li><li class="listitem"><p>operations: add, set, compareAndSet, reset</p></li></ul></div><p>
            </p></li><li class="listitem"><p>List, Set
                </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>name</p></li><li class="listitem"><p>size</p></li><li class="listitem"><p>items (as strings)</p></li><li class="listitem"><p>operations: clear, reset statistics</p></li></ul></div><p>
            </p></li><li class="listitem"><p>Map
                </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>name</p></li><li class="listitem"><p>size</p></li><li class="listitem"><p>operations: clear</p></li></ul></div><p>
            </p></li><li class="listitem"><p>Queue
                </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>name</p></li><li class="listitem"><p>size</p></li><li class="listitem"><p>received and served items</p></li><li class="listitem"><p>operations: clear, reset statistics</p></li></ul></div><p>
            </p></li><li class="listitem"><p>Topic
                </p><div class="itemizedlist"><ul class="itemizedlist" type="circle"><li class="listitem"><p>name</p></li><li class="listitem"><p>number of messages dispatched since creation, in last second</p></li><li class="listitem"><p>max messages dispatched per second</p></li></ul></div><p>
            </p></li></ul></div><p>
    </p></div></div><div class="chapter" title="Chapter&nbsp;8.&nbsp;Cluster Utilities"><div class="titlepage"><div><div><h2 class="title"><a name="ClusterUtilities"></a>Chapter&nbsp;8.&nbsp;Cluster Utilities</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#ClusterInterface">8.1. Cluster Interface</a></span></dt><dt><span class="sect1"><a href="#IdGenerator">8.2. Cluster-wide Id Generator</a></span></dt></dl></div><div class="sect1" title="8.1.&nbsp;Cluster Interface"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ClusterInterface"></a>8.1.&nbsp;Cluster Interface</h2></div></div></div><p>
        Hazelcast allows you to register for membership events to get notified when members added or removed. You can
        also get the set of cluster members.

        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.*;
<strong class="hl-keyword">import</strong> com.hazelcast.config.Config;

Config cfg = <strong class="hl-keyword">new</strong> Config();
HazelcastInstance hz = Hazelcast.newHazelcastInstance(cfg);
Cluster cluster = hz.getCluster();
cluster.addMembershipListener(<strong class="hl-keyword">new</strong> MembershipListener(){
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> memberAdded(MembershipEvent membersipEvent) {
        System.out.println(<font font-style="normal" color="#008000">"MemberAdded "</font> + membersipEvent);
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> memberRemoved(MembershipEvent membersipEvent) {
        System.out.println(<font font-style="normal" color="#008000">"MemberRemoved "</font> + membersipEvent);
    }
});

Member localMember  = cluster.getLocalMember();
System.out.println (<font font-style="normal" color="#008000">"my inetAddress= "</font> + localMember.getInetAddress());

Set setMembers  = cluster.getMembers();
<strong class="hl-keyword">for</strong> (Member member : setMembers) {
    System.out.println (<font font-style="normal" color="#008000">"isLocalMember "</font> + member.localMember());
    System.out.println (<font font-style="normal" color="#008000">"member.inetaddress "</font> + member.getInetAddress());
    System.out.println (<font font-style="normal" color="#008000">"member.port "</font> + member.getPort());
}

</pre><p>

    </p></div><div class="sect1" title="8.2.&nbsp;Cluster-wide Id Generator"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="IdGenerator"></a>8.2.&nbsp;Cluster-wide Id Generator</h2></div></div></div><p>
        Hazelcast IdGenerator creates cluster-wide unique IDs. Generated IDs are long type primitive values between 0
        and
        <code class="literal">Long.MAX_VALUE</code>
        . Id generation occurs almost at the speed of
        <code class="literal">AtomicLong.incrementAndGet()</code>
        . Generated IDs are unique during the life cycle of the cluster. If the entire cluster is restarted, IDs start
        from 0 again or you can initialize to a value.

        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.IdGenerator;
<strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;

Config cfg = <strong class="hl-keyword">new</strong> Config();
HazelcastInstance hz = Hazelcast.newHazelcastInstance(cfg);
IdGenerator idGenerator = hz.getIdGenerator(<font font-style="normal" color="#008000">"customer-ids"</font>);
idGenerator.init(<span class="hl-number">123L</span>); <em class="hl-comment" style="color: silver">//Optional</em>
<strong class="hl-keyword">long</strong> id = idGenerator.newId();
</pre><p>


    </p></div></div><div class="chapter" title="Chapter&nbsp;9.&nbsp;Transactions"><div class="titlepage"><div><div><h2 class="title"><a name="Transactions"></a>Chapter&nbsp;9.&nbsp;Transactions</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#TransactionInterface">9.1. Transaction Interface</a></span></dt><dt><span class="sect1"><a href="#JEEIntegration">9.2. J2EE Integration</a></span></dt><dd><dl><dt><span class="sect2"><a href="#JEEIntegrationConfig">9.2.1. Resource Adapter Configuration</a></span></dt><dt><span class="sect2"><a href="#JEEIntegrationGlassfishSample">9.2.2. Sample Glassfish v3 Web Application Configuration</a></span></dt><dt><span class="sect2"><a href="#JEEIntegrationJBossSample">9.2.3. Sample JBoss Web Application Configuration</a></span></dt></dl></dd></dl></div><div class="sect1" title="9.1.&nbsp;Transaction Interface"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="TransactionInterface"></a>9.1.&nbsp;Transaction Interface</h2></div></div></div><p>
        Hazelcast can be used in transactional context. Basically create a <code class="literal">TransactionContext</code>
        which can be used to begin, commit, rollback transaction.
        Obtain transaction aware instances of queues, maps, sets, lists, multimaps via <code class="literal">TransactionContext</code>,
        work with them and commit/rollback in one shot. Hazelcast supports LOCAL(One Phase) and TWO_PHASE transactions.
        Default behaviour is TWO_PHASE.
    </p><p>

        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> java.util.Queue;
<strong class="hl-keyword">import</strong> java.util.Map;
<strong class="hl-keyword">import</strong> java.util.Set;
<strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> com.hazelcast.core.Transaction; 

Config cfg = <strong class="hl-keyword">new</strong> Config();
HazelcastInstance hz = Hazelcast.newHazelcastInstance(cfg);

TransactionOptions options = <strong class="hl-keyword">new</strong> TransactionOptions().setTransactionType(TransactionType.LOCAL);
TransactionContext context = hz.newTransactionContext()
context.beginTransaction();

TransactionalQueue queue = context.getQueue(<font font-style="normal" color="#008000">"myqueue"</font>);
TransactionalMap map     = context.getMap  (<font font-style="normal" color="#008000">"mymap"</font>);
TransactionalSet set     = context.getSet  (<font font-style="normal" color="#008000">"myset"</font>);

<strong class="hl-keyword">try</strong> {
    Object obj = queue.poll();
    <em class="hl-comment" style="color: silver">//process obj</em>
    map.put (<font font-style="normal" color="#008000">"1"</font>, <font font-style="normal" color="#008000">"value1"</font>);
    set.add (<font font-style="normal" color="#008000">"value"</font>);
    <em class="hl-comment" style="color: silver">//do other things..</em>
    context.commitTransaction();
}<strong class="hl-keyword">catch</strong> (Throwable t)  {
    context.rollbackTransaction();
}
</pre><p>

        Isolation is always
        <code class="literal">REPEATABLE_READ</code>
        . If you are in a transaction, you can read the data in your transaction and the data that is already committed
        and if not in a transaction, you can only read the committed data. Implementation is different for queue and
        map/set. For queue operations (offer,poll), offered and/or polled objects are copied to the owner member in order
        to safely commit/rollback. For map/set, Hazelcast first acquires the locks for the write operations (put,
        remove) and holds the differences (what is added/removed/updated) locally for each transaction. When transaction
        is set to commit, Hazelcast will release the locks and apply the differences. When rolling back, Hazelcast will
        simply releases the locks and discard the differences.
    </p></div><div class="sect1" title="9.2.&nbsp;J2EE Integration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="JEEIntegration"></a>9.2.&nbsp;J2EE Integration</h2></div></div></div><p>Hazelcast can be integrated into J2EE containers via Hazelcast Resource Adapter (
        hazelcast-ra.rar ). After proper configuration, Hazelcast can participate in standard J2EE
        transactions.
        </p><pre class="programlisting">&lt;%<em><span class="hl-annotation" style="color: gray">@page</span></em> <strong class="hl-keyword">import</strong>=<font font-style="normal" color="#008000">"javax.resource.ResourceException"</font> %&gt;
&lt;%<em><span class="hl-annotation" style="color: gray">@page</span></em> <strong class="hl-keyword">import</strong>=<font font-style="normal" color="#008000">"javax.transaction.*"</font> %&gt;
&lt;%<em><span class="hl-annotation" style="color: gray">@page</span></em> <strong class="hl-keyword">import</strong>=<font font-style="normal" color="#008000">"javax.naming.*"</font> %&gt;
&lt;%<em><span class="hl-annotation" style="color: gray">@page</span></em> <strong class="hl-keyword">import</strong>=<font font-style="normal" color="#008000">"javax.resource.cci.*"</font> %&gt;
&lt;%<em><span class="hl-annotation" style="color: gray">@page</span></em> <strong class="hl-keyword">import</strong>=<font font-style="normal" color="#008000">"java.util.*"</font> %&gt;
&lt;%<em><span class="hl-annotation" style="color: gray">@page</span></em> <strong class="hl-keyword">import</strong>=<font font-style="normal" color="#008000">"com.hazelcast.core.*"</font> %&gt;
&lt;%<em><span class="hl-annotation" style="color: gray">@page</span></em> <strong class="hl-keyword">import</strong>=<font font-style="normal" color="#008000">"com.hazelcast.jca.*"</font> %&gt;

&lt;%
UserTransaction txn = null;
HazelcastConnection conn = null;
Config cfg = <strong class="hl-keyword">new</strong> Config();
HazelcastInstance hz = Hazelcast.newHazelcastInstance(cfg);

<strong class="hl-keyword">try</strong> {
    Context context = <strong class="hl-keyword">new</strong> InitialContext();
    txn = (UserTransaction) context.lookup(<font font-style="normal" color="#008000">"java:comp/UserTransaction"</font>);
    txn.begin();

    HazelcastConnectionFactory cf = (HazelcastConnectionFactory) context.lookup (<font font-style="normal" color="#008000">"java:comp/env/HazelcastCF"</font>);
    conn = cf.getConnection();

    TransactionalMap&lt;String, String&gt; txMap = conn.getTransactionalMap(<font font-style="normal" color="#008000">"default"</font>);
    txMap.put(<font font-style="normal" color="#008000">"key"</font>, <font font-style="normal" color="#008000">"value"</font>);

    txn.commit();
} <strong class="hl-keyword">catch</strong> (Throwable e) {
    <strong class="hl-keyword">if</strong> (txn != null) {
        <strong class="hl-keyword">try</strong> {
            txn.rollback();
        } <strong class="hl-keyword">catch</strong> (Exception ix) {ix.printStackTrace();};
    }
    e.printStackTrace();
} <strong class="hl-keyword">finally</strong> {
    <strong class="hl-keyword">if</strong> (conn != null) {
        <strong class="hl-keyword">try</strong> {
            conn.close();
        } <strong class="hl-keyword">catch</strong> (Exception ignored) {};
    }
}
%&gt;
</pre><p>
    </p><div class="sect2" title="9.2.1.&nbsp;Resource Adapter Configuration"><div class="titlepage"><div><div><h3 class="title"><a name="JEEIntegrationConfig"></a>9.2.1.&nbsp;Resource Adapter Configuration</h3></div></div></div><p>Deploying and configuring Hazelcast resource adapter is no different than any other
            resource adapter since it is a standard
            <code class="literal">JCA</code>
            resource adapter but
            resource adapter installation and configuration is container specific, so please consult
            your J2EE vendor documentation for details. Most common steps are:
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Add the
                        <code class="literal">hazelcast.jar</code>
                        to container's classpath. Usually
                        there is a lib directory that is loaded automatically by the container on
                        startup.
                    </p></li><li class="listitem"><p>Deploy<code class="literal">hazelcast-ra.rar</code>. Usually there is a some kind of
                        deploy directory. Name of the directory varies by container.
                    </p></li><li class="listitem"><p>Make container specific configurations when/after
                        deploying<code class="literal">hazelcast-ra.rar</code>. Besides container specific
                        configurations,
                        <code class="literal">JNDI</code>
                        name for Hazelcast resource is
                        set.
                    </p></li><li class="listitem"><p>Configure your application to use the Hazelcast resource. Updating
                        <code class="literal">web.xml</code>
                        and/or
                        <code class="literal">ejb-jar.xml</code>
                        to let
                        container know that your application will use the Hazelcast resource and
                        define the resource reference.
                    </p></li><li class="listitem"><p>Make container specific application configuration to specify
                        <code class="literal">JNDI</code>
                        name used for the resource in the application.
                    </p></li></ol></div><p>
        </p></div><div class="sect2" title="9.2.2.&nbsp;Sample Glassfish v3 Web Application Configuration"><div class="titlepage"><div><div><h3 class="title"><a name="JEEIntegrationGlassfishSample"></a>9.2.2.&nbsp;Sample Glassfish v3 Web Application Configuration</h3></div></div></div><p>
            </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Place the
                        <code class="literal">hazelcast-&lt;version&gt;.jar</code>
                        into
                        <code class="literal">GLASSFISH_HOME/glassfish/domains/domain1/lib/ext/</code>
                        directory.
                    </p></li><li class="listitem"><p>Place the
                        <code class="literal">hazelcast-ra-&lt;version&gt;.rar</code>
                        into
                        <code class="literal">GLASSFISH_HOME/glassfish/domains/domain1/autodeploy/</code>
                        directory
                    </p></li><li class="listitem"><p>Add the following lines to the
                        <code class="literal">web.xml</code>
                        file.
                        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;resource-ref&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;res-ref-name&gt;</font>HazelcastCF<font font-style="bold" color="#0A1777">&lt;/res-ref-name&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;res-type&gt;</font>com.hazelcast.jca.ConnectionFactoryImpl<font font-style="bold" color="#0A1777">&lt;/res-type&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;res-auth&gt;</font>Container<font font-style="bold" color="#0A1777">&lt;/res-auth&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/resource-ref&gt;</font>
</pre><p>
                    </p></li></ol></div><p>
            Notice that we didn't have to put
            <code class="literal">sun-ra.xml</code>
            into the
            rar file because it comes with the
            <code class="literal">hazelcast-ra-&lt;version&gt;.rar</code>
            file already.
        </p><p>If Hazelcast resource is used from EJBs, you should configure
            <code class="literal">ejb-jar.xml</code>
            for resource reference and
            <code class="literal">JNDI</code>
            definitions, just like we did for<code class="literal">web.xml</code>.
        </p></div><div class="sect2" title="9.2.3.&nbsp;Sample JBoss Web Application Configuration"><div class="titlepage"><div><div><h3 class="title"><a name="JEEIntegrationJBossSample"></a>9.2.3.&nbsp;Sample JBoss Web Application Configuration</h3></div></div></div><p>
            </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Place the
                        <code class="literal">hazelcast-&lt;version&gt;.jar</code>
                        into
                        <code class="literal">JBOSS_HOME/server/deploy/default/lib</code>
                        directory.
                    </p></li><li class="listitem"><p>Place the
                        <code class="literal">hazelcast-ra-&lt;version&gt;.rar</code>
                        into
                        <code class="literal">JBOSS_HOME/server/deploy/default/deploy</code>
                        directory
                    </p></li><li class="listitem"><p>Create a
                        <code class="literal">hazelcast-ds.xml</code>
                        at
                        <code class="literal">JBOSS_HOME/server/deploy/default/deploy</code>
                        directory
                        containing the following content. Make sure to set the
                        <code class="literal">rar-name</code>
                        element
                        to<code class="literal">hazelcast-ra-&lt;version&gt;.rar</code>.
                        </p><pre class="programlisting"><span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<strong class="hl-tag" style="color: blue">&lt;!DOCTYPE connection-factories
  PUBLIC "-//JBoss//DTD JBOSS JCA Config 1.5//EN"
  "http://www.jboss.org/j2ee/dtd/jboss-ds_1_5.dtd"&gt;</strong>

<font font-style="bold" color="#0A1777">&lt;connection-factories&gt;</font>
 <font font-style="bold" color="#0A1777">&lt;tx-connection-factory&gt;</font>
      <font font-style="bold" color="#0A1777">&lt;local-transaction/&gt;</font>
      <font font-style="bold" color="#0A1777">&lt;track-connection-by-tx&gt;</font>true<font font-style="bold" color="#0A1777">&lt;/track-connection-by-tx&gt;</font>
      <font font-style="bold" color="#0A1777">&lt;jndi-name&gt;</font>HazelcastCF<font font-style="bold" color="#0A1777">&lt;/jndi-name&gt;</font>
      <font font-style="bold" color="#0A1777">&lt;rar-name&gt;</font>hazelcast-ra-<font font-style="bold" color="#0A1777">&lt;version&gt;</font>.rar<font font-style="bold" color="#0A1777">&lt;/rar-name&gt;</font>
      <font font-style="bold" color="#0A1777">&lt;connection-definition&gt;</font>
           javax.resource.cci.ConnectionFactory
      <font font-style="bold" color="#0A1777">&lt;/connection-definition&gt;</font>
  <font font-style="bold" color="#0A1777">&lt;/tx-connection-factory&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/connection-factories&gt;</font>
</pre><p>
                    </p></li><li class="listitem"><p>Add the following lines to the
                        <code class="literal">web.xml</code>
                        file.
                        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;resource-ref&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;res-ref-name&gt;</font>HazelcastCF<font font-style="bold" color="#0A1777">&lt;/res-ref-name&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;res-type&gt;</font>com.hazelcast.jca.ConnectionFactoryImpl<font font-style="bold" color="#0A1777">&lt;/res-type&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;res-auth&gt;</font>Container<font font-style="bold" color="#0A1777">&lt;/res-auth&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/resource-ref&gt;</font>
</pre><p>
                    </p></li><li class="listitem"><p>Add the following lines to the
                        <code class="literal">jboss-web.xml</code>
                        file.
                        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;resource-ref&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;res-ref-name&gt;</font>HazelcastCF<font font-style="bold" color="#0A1777">&lt;/res-ref-name&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;jndi-name&gt;</font>java:HazelcastCF<font font-style="bold" color="#0A1777">&lt;/jndi-name&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/resource-ref&gt;</font>
</pre><p>
                    </p></li></ul></div><p>
            If Hazelcast resource is used from EJBs, you should configure
            <code class="literal">ejb-jar.xml</code>
            and
            <code class="literal">jboss.xml</code>
            for resource
            reference and
            <code class="literal">JNDI</code>
            definitions.
        </p></div></div></div><div class="chapter" title="Chapter&nbsp;10.&nbsp;Distributed Executor Service"><div class="titlepage"><div><div><h2 class="title"><a name="ExecutorService"></a>Chapter&nbsp;10.&nbsp;Distributed Executor Service</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#DistributedExecution">10.1. Distributed Execution</a></span></dt><dt><span class="sect1"><a href="#ExecutionCancellation">10.2. Execution Cancellation</a></span></dt><dt><span class="sect1"><a href="#ExecutionCallback">10.3. Execution Callback</a></span></dt></dl></div><div class="simplesect"><div class="titlepage"></div><p>
    One of the coolest features of Java 1.5 is the Executor framework, which allows you to asynchronously execute
    your tasks, logical units of works, such as database query, complex calculation, image rendering etc. So one nice
    way of executing such tasks would be running them asynchronously and doing other things meanwhile. When ready, get
    the result and move on. If execution of the task takes longer than expected, you may consider canceling the task
    execution. In Java Executor framework, tasks are implemented as
    <code class="literal">java.util.concurrent.Callable</code> and <code class="literal">java.util.Runnable</code>.

    </p><pre class="programlisting"><strong class="hl-keyword">import</strong> java.util.concurrent.Callable;
<strong class="hl-keyword">import</strong> java.io.Serializable;

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Echo <strong class="hl-keyword">implements</strong> Callable&lt;String&gt;, Serializable {
    String input = null;

    <strong class="hl-keyword">public</strong> Echo() {
    }

    <strong class="hl-keyword">public</strong> Echo(String input) {
        <strong class="hl-keyword">this</strong>.input = input;
    }

    <strong class="hl-keyword">public</strong> String call() {
        <strong class="hl-keyword">return</strong> Hazelcast.getCluster().getLocalMember().toString() + <font font-style="normal" color="#008000">":"</font> + input;
    }
}
</pre><p>

    Echo callable above, for instance, in its
    <code class="literal">call()</code>
    method, is returning the local member and the input passed in. Remember that
    <code class="literal">Hazelcast.getCluster().getLocalMember()</code>
    returns the local member and
    <code class="literal">toString()</code>
    returns the member's address
    <code class="literal">(ip + port)</code>
    in String form, just to see which member actually executed the code for our example. Of course, call() method can do
    and return anything you like.

    Executing a task by using executor framework is very straight forward. Simply obtain a
    <code class="literal">ExecutorService</code>
    instance, generally via
    <code class="literal">Executors</code> and submit the task which returns a <code class="literal">Future</code>. After executing task, you don't have to wait for
    execution to complete, you can process other things and when ready use the future object to retrieve the result as
    show in code below.

    </p><pre class="programlisting">ExecutorService executorService = Executors.newSingleThreadExecutor();
Future&lt;String&gt; future = executorService.submit (<strong class="hl-keyword">new</strong> Echo(<font font-style="normal" color="#008000">"myinput"</font>));
<em class="hl-comment" style="color: silver">//while it is executing, do some useful stuff</em>
<em class="hl-comment" style="color: silver">//when ready, get the result of your execution</em>
String result = future.get();
</pre><p>
    </p></div><div class="sect1" title="10.1.&nbsp;Distributed Execution"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="DistributedExecution"></a>10.1.&nbsp;Distributed Execution</h2></div></div></div><p>Distributed executor service is a distributed implementation of java.util.concurrent.ExecutorService.
        It allows you to execute your code in cluster. In this chapter, all the code samples are based on the Echo class
        above.
        Please note that Echo class is
        <code class="literal">Serializable</code>
        .
        You can ask Hazelcast to execute your code (<code class="literal">Runnable, Callable</code>):
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>on a specific cluster member you choose.
                </p></li><li class="listitem"><p>on the member owning the key you choose.
                </p></li><li class="listitem"><p>on the member Hazelcast will pick.
                </p></li><li class="listitem"><p>on all or subset of the cluster members.
                </p></li></ul></div><p>
        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.Member;
<strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> com.hazelcast.core.IExecutorService;
<strong class="hl-keyword">import</strong> java.util.concurrent.Callable;
<strong class="hl-keyword">import</strong> java.util.concurrent.Future;   
<strong class="hl-keyword">import</strong> java.util.Set;
<strong class="hl-keyword">import</strong> com.hazelcast.config.Config;


<strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> echoOnTheMember(String input, Member member) <strong class="hl-keyword">throws</strong> Exception {
   Callable&lt;String&gt; task = <strong class="hl-keyword">new</strong> Echo(input);
   HazelcastInstance hz = Hazelcast.newHazelcastInstance();
   IExecutorService executorService = hz.getExecutorService(<font font-style="normal" color="#008000">"default"</font>);
   Future&lt;String&gt; future = executorService.submitToMember(task, member);
   String echoResult = future.get();
}

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> echoOnTheMemberOwningTheKey(String input, Object key) <strong class="hl-keyword">throws</strong> Exception {
   Callable&lt;String&gt; task = <strong class="hl-keyword">new</strong> Echo(input);
   HazelcastInstance hz = Hazelcast.newHazelcastInstance();
   IExecutorService executorService = hz.getExecutorService(<font font-style="normal" color="#008000">"default"</font>);
   Future&lt;String&gt; future = executorService.submitToKeyOwner(task, key);
   String echoResult = future.get();
}

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> echoOnSomewhere(String input) <strong class="hl-keyword">throws</strong> Exception { 
   HazelcastInstance hz = Hazelcast.newHazelcastInstance();
   IExecutorService executorService = hz.getExecutorService(<font font-style="normal" color="#008000">"default"</font>);
   Future&lt;String&gt; future = executorService.submit(<strong class="hl-keyword">new</strong> Echo(input));
   String echoResult = future.get();
}

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> echoOnMembers(String input, Set&lt;Member&gt; members) <strong class="hl-keyword">throws</strong> Exception {
   HazelcastInstance hz = Hazelcast.newHazelcastInstance();
   IExecutorService executorService = hz.getExecutorService(<font font-style="normal" color="#008000">"default"</font>);
   Map&lt;Member, Future&lt;String&gt;&gt; futures = executorService.submitToMembers(<strong class="hl-keyword">new</strong> Echo(input), members);
   <strong class="hl-keyword">for</strong> (Future&lt;String&gt; future : futures.values()) {
        String echoResult = future.get();
        <em class="hl-comment" style="color: silver">// ...</em>
   }
}
</pre><p>
        Note that you can obtain the set of cluster members via
        <code class="literal">Hazelcast.getCluster().getMembers()</code> call.
    </p></div><div class="sect1" title="10.2.&nbsp;Execution Cancellation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ExecutionCancellation"></a>10.2.&nbsp;Execution Cancellation</h2></div></div></div><p>What if the code you execute in cluster takes longer than acceptable. If you cannot
        stop/cancel that task it will keep eating your resources. Standard Java executor framework
        solves this problem with by introducing
        <code class="literal">cancel()</code>
        api and 'encouraging' us
        to code and design for cancellations, which is highly ignored part of software development.
        </p><pre class="programlisting"><strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Fibonacci&lt;Long&gt; <strong class="hl-keyword">implements</strong> Callable&lt;Long&gt;, Serializable {
    <strong class="hl-keyword">int</strong> input = <span class="hl-number">0</span>; 

    <strong class="hl-keyword">public</strong> Fibonacci() { 
    } 

    <strong class="hl-keyword">public</strong> Fibonacci(<strong class="hl-keyword">int</strong> input) { 
        <strong class="hl-keyword">this</strong>.input = input;
    } 

    <strong class="hl-keyword">public</strong> Long call() {
        <strong class="hl-keyword">return</strong> calculate (input);
    }

    <strong class="hl-keyword">private</strong> <strong class="hl-keyword">long</strong> calculate (<strong class="hl-keyword">int</strong> n) {
        <strong class="hl-keyword">if</strong> (Thread.currentThread().isInterrupted()) <strong class="hl-keyword">return</strong> <span class="hl-number">0</span>;
        <strong class="hl-keyword">if</strong> (n &lt;= <span class="hl-number">1</span>) <strong class="hl-keyword">return</strong> n;
        <strong class="hl-keyword">else</strong> <strong class="hl-keyword">return</strong> calculate(n-<span class="hl-number">1</span>) + calculate(n-<span class="hl-number">2</span>);
    }
}
</pre><p>
        The callable class above calculates the fibonacci number for a given number. In
        the calculate method, we are checking to see if the current thread is interrupted so that
        code can be responsive to cancellations once the execution started. Following
        <code class="literal">fib()</code>
        method submits the Fibonacci calculation task for number 'n'
        and waits maximum 3 seconds for result. If the execution doesn't complete in 3 seconds,
        <code class="literal">future.get()</code>
        will throw
        <code class="literal">TimeoutException</code>
        and upon
        catching it we interruptibly cancel the execution for saving some CPU cycles.
        </p><pre class="programlisting"><strong class="hl-keyword">long</strong> fib(<strong class="hl-keyword">int</strong> n) <strong class="hl-keyword">throws</strong> Exception {
    Config cfg = <strong class="hl-keyword">new</strong> Config();
    HazelcastInstance hz = Hazelcast.newHazelcastInstance(cfg);
    IExecutorService es = hz.getExecutorService();
    Future future = es.submit(<strong class="hl-keyword">new</strong> Fibonacci(n));  
    <strong class="hl-keyword">try</strong> {
        <strong class="hl-keyword">return</strong> future.get(<span class="hl-number">3</span>, TimeUnit.SECONDS);
    } <strong class="hl-keyword">catch</strong> (TimeoutException e) {
        future.cancel(true);            
    }
    <strong class="hl-keyword">return</strong> -<span class="hl-number">1</span>;
}
</pre><p>
        <code class="literal">fib(20)</code>
        will probably will take less than 3 seconds but
        <code class="literal">fib(50)</code>
        will take
        way longer. (This is not the example for writing better fibonacci calculation code but for
        showing how to cancel a running execution that takes too long.)
        <code class="literal">future.cancel(false)</code>
        can
        only cancel execution before it is running (executing) but
        <code class="literal">future.cancel(true)</code>
        can
        interrupt running executions if your code is able to handle the interruption. So if you are
        willing to be able to cancel already running task then your task has to be designed to
        handle interruption. If
        <code class="literal">calculate (int n)</code>
        method didn't have if
        <code class="literal">(Thread.currentThread().isInterrupted())</code>
        line, then you wouldn't be
        able to cancel the execution after it started.
    </p></div><div class="sect1" title="10.3.&nbsp;Execution Callback"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ExecutionCallback"></a>10.3.&nbsp;Execution Callback</h2></div></div></div><p>
        <code class="literal">ExecutionCallback</code>
        allows you to asynchronously get notified when the execution is done.

        </p><pre class="programlisting"><strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Fibonacci&lt;Long&gt; <strong class="hl-keyword">implements</strong> Callable&lt;Long&gt;, Serializable {
    <strong class="hl-keyword">int</strong> input = <span class="hl-number">0</span>;

    <strong class="hl-keyword">public</strong> Fibonacci() {
    }

    <strong class="hl-keyword">public</strong> Fibonacci(<strong class="hl-keyword">int</strong> input) {
        <strong class="hl-keyword">this</strong>.input = input;
    }

    <strong class="hl-keyword">public</strong> Long call() {
        <strong class="hl-keyword">return</strong> calculate (input);
    }

    <strong class="hl-keyword">private</strong> <strong class="hl-keyword">long</strong> calculate (<strong class="hl-keyword">int</strong> n) {
        <strong class="hl-keyword">if</strong> (n &lt;= <span class="hl-number">1</span>) <strong class="hl-keyword">return</strong> n;
        <strong class="hl-keyword">else</strong> <strong class="hl-keyword">return</strong> calculate(n-<span class="hl-number">1</span>) + calculate(n-<span class="hl-number">2</span>);
    }
}
</pre><p>

        </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.Hazelcast;
<strong class="hl-keyword">import</strong> com.hazelcast.core.ExecutionCallback;
<strong class="hl-keyword">import</strong> com.hazelcast.core.IExecutorService;
<strong class="hl-keyword">import</strong> java.util.concurrent.Future;
<strong class="hl-keyword">import</strong> com.hazelcast.config.Config;

Config cfg = <strong class="hl-keyword">new</strong> Config();
HazelcastInstance hz = Hazelcast.newHazelcastInstance(cfg);
IExecutorService es = hz.getExecutorService();
Callable&lt;Long&gt; task = <strong class="hl-keyword">new</strong> Fibonacci(<span class="hl-number">10</span>);

es.submit(task, <strong class="hl-keyword">new</strong> ExecutionCallback&lt;Long&gt; () {

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> onResponse(Long response) {
        System.out.println(<font font-style="normal" color="#008000">"Fibonacci calculation result = "</font> + response);
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> onFailure(Throwable t) {
        t.printStackTrace();
    }

});
</pre><p>
    </p></div></div><div class="chapter" title="Chapter&nbsp;11.&nbsp;Http Session Clustering with HazelcastWM"><div class="titlepage"><div><div><h2 class="title"><a name="HttpSessionClustering"></a>Chapter&nbsp;11.&nbsp;Http Session Clustering with HazelcastWM</h2></div></div></div><div class="simplesect"><div class="titlepage"></div><p>
    Say you have more than one web servers (A, B, C) with a load balancer in front of them. If server A goes down
    then your users on that server will be directed to one of the live servers (B or C) but their sessions will be lost!
    So we have to have all these sessions backed up somewhere if we don't want to lose the sessions upon server crashes.
    Hazelcast WM allows you to cluster user http sessions automatically. The following are required for enabling
    Hazelcast Session Clustering:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Target application or web server should support Java 1.5+
            </p></li><li class="listitem"><p>Target application or web server should support Servlet 2.4+ spec
            </p></li><li class="listitem"><p>Session objects that needs to be clustered have to be Serializable
            </p></li></ul></div><p>
    Here are the steps to setup Hazelcast Session Clustering:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Put the
                <code class="literal">hazelcast</code>
                and
                <code class="literal">hazelcast-wm</code>
                jars in your
                <code class="literal">WEB-INF/lib</code>
                directory. Optionally if you wish to connect to a cluster as a client add
                <code class="literal">hazelcast-client</code>
                as well.
            </p></li><li class="listitem"><p>Put the following xml into
                <code class="literal">web.xml</code>
                file. Make sure Hazelcast filter is placed
                before all the other filters if any; put it at the top for example.
            </p><p>
                </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;filter&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;filter-name&gt;</font>hazelcast-filter<font font-style="bold" color="#0A1777">&lt;/filter-name&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;filter-class&gt;</font>com.hazelcast.web.WebFilter<font font-style="bold" color="#0A1777">&lt;/filter-class&gt;</font>
    <em class="hl-comment" style="color: silver">&lt;!--
        Name of the distributed map storing
        your web session objects
    --&gt;</em>
    <font font-style="bold" color="#0A1777">&lt;init-param&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-name&gt;</font>map-name<font font-style="bold" color="#0A1777">&lt;/param-name&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-value&gt;</font>my-sessions<font font-style="bold" color="#0A1777">&lt;/param-value&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/init-param&gt;</font>
    <em class="hl-comment" style="color: silver">&lt;!--
        How is your load-balancer configured?
        stick-session means all requests of a session
        is routed to the node where the session is first created.
        This is excellent for performance.
        If sticky-session is set to false, when a session is updated
        on a node, entry for this session on all other nodes is invalidated.
        You have to know how your load-balancer is configured before
        setting this parameter. Default is true.
    --&gt;</em>
    <font font-style="bold" color="#0A1777">&lt;init-param&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-name&gt;</font>sticky-session<font font-style="bold" color="#0A1777">&lt;/param-name&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-value&gt;</font>true<font font-style="bold" color="#0A1777">&lt;/param-value&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/init-param&gt;</font>
    <em class="hl-comment" style="color: silver">&lt;!--
        Name of session id cookie
    --&gt;</em>
    <font font-style="bold" color="#0A1777">&lt;init-param&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-name&gt;</font>cookie-name<font font-style="bold" color="#0A1777">&lt;/param-name&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-value&gt;</font>hazelcast.sessionId<font font-style="bold" color="#0A1777">&lt;/param-value&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/init-param&gt;</font>
    <em class="hl-comment" style="color: silver">&lt;!--
        Domain of session id cookie. Default is based on incoming request.
    --&gt;</em>
    <font font-style="bold" color="#0A1777">&lt;init-param&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-name&gt;</font>cookie-domain<font font-style="bold" color="#0A1777">&lt;/param-name&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-value&gt;</font>.mywebsite.com<font font-style="bold" color="#0A1777">&lt;/param-value&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/init-param&gt;</font>
    <em class="hl-comment" style="color: silver">&lt;!--
        Should cookie only be sent using a secure protocol? Default is false.
    --&gt;</em>
    <font font-style="bold" color="#0A1777">&lt;init-param&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-name&gt;</font>cookie-secure<font font-style="bold" color="#0A1777">&lt;/param-name&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-value&gt;</font>false<font font-style="bold" color="#0A1777">&lt;/param-value&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/init-param&gt;</font>
    <em class="hl-comment" style="color: silver">&lt;!--
        Should HttpOnly attribute be set on cookie ? Default is false.
    --&gt;</em>
    <font font-style="bold" color="#0A1777">&lt;init-param&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-name&gt;</font>cookie-http-only<font font-style="bold" color="#0A1777">&lt;/param-name&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-value&gt;</font>false<font font-style="bold" color="#0A1777">&lt;/param-value&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/init-param&gt;</font>
    <em class="hl-comment" style="color: silver">&lt;!--
        Are you debugging? Default is false.
    --&gt;</em>
    <font font-style="bold" color="#0A1777">&lt;init-param&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-name&gt;</font>debug<font font-style="bold" color="#0A1777">&lt;/param-name&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-value&gt;</font>true<font font-style="bold" color="#0A1777">&lt;/param-value&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/init-param&gt;</font>
    <em class="hl-comment" style="color: silver">&lt;!--
        Configuration xml location;
            * as servlet resource OR
            * as classpath resource OR
            * as URL
        Default is one of hazelcast-default.xml
        or hazelcast.xml in classpath.
    --&gt;</em>
    <font font-style="bold" color="#0A1777">&lt;init-param&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-name&gt;</font>config-location<font font-style="bold" color="#0A1777">&lt;/param-name&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-value&gt;</font>/WEB-INF/hazelcast.xml<font font-style="bold" color="#0A1777">&lt;/param-value&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/init-param&gt;</font>
    <em class="hl-comment" style="color: silver">&lt;!--
        Do you want to use an existing HazelcastInstance?
        Default is null.
    --&gt;</em>
    <font font-style="bold" color="#0A1777">&lt;init-param&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-name&gt;</font>instance-name<font font-style="bold" color="#0A1777">&lt;/param-name&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-value&gt;</font>default<font font-style="bold" color="#0A1777">&lt;/param-value&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/init-param&gt;</font>
</pre><p>
 
</p><pre class="programlisting">
    <em class="hl-comment" style="color: silver">&lt;!--
        Do you want to connect as a client to an existing cluster?
        Default is false.
    --&gt;</em>
    <font font-style="bold" color="#0A1777">&lt;init-param&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-name&gt;</font>use-client<font font-style="bold" color="#0A1777">&lt;/param-name&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-value&gt;</font>false<font font-style="bold" color="#0A1777">&lt;/param-value&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/init-param&gt;</font>
    <em class="hl-comment" style="color: silver">&lt;!--
        Client configuration location;
            * as servlet resource OR
            * as classpath resource OR
            * as URL
        Default is null.
    --&gt;</em>
    <font font-style="bold" color="#0A1777">&lt;init-param&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-name&gt;</font>client-config-location<font font-style="bold" color="#0A1777">&lt;/param-name&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-value&gt;</font>/WEB-INF/hazelcast-client.properties<font font-style="bold" color="#0A1777">&lt;/param-value&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/init-param&gt;</font>
    <em class="hl-comment" style="color: silver">&lt;!--
        Do you want to shutdown HazelcastInstance during
        web application undeploy process?
        Default is true.
    --&gt;</em>
    <font font-style="bold" color="#0A1777">&lt;init-param&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-name&gt;</font>shutdown-on-destroy<font font-style="bold" color="#0A1777">&lt;/param-name&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;param-value&gt;</font>true<font font-style="bold" color="#0A1777">&lt;/param-value&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/init-param&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/filter&gt;</font>
<font font-style="bold" color="#0A1777">&lt;filter-mapping&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;filter-name&gt;</font>hazelcast-filter<font font-style="bold" color="#0A1777">&lt;/filter-name&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;url-pattern&gt;</font>/*<font font-style="bold" color="#0A1777">&lt;/url-pattern&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;dispatcher&gt;</font>FORWARD<font font-style="bold" color="#0A1777">&lt;/dispatcher&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;dispatcher&gt;</font>INCLUDE<font font-style="bold" color="#0A1777">&lt;/dispatcher&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;dispatcher&gt;</font>REQUEST<font font-style="bold" color="#0A1777">&lt;/dispatcher&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/filter-mapping&gt;</font>

<font font-style="bold" color="#0A1777">&lt;listener&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;listener-class&gt;</font>com.hazelcast.web.SessionListener<font font-style="bold" color="#0A1777">&lt;/listener-class&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/listener&gt;</font>
</pre><p>
            </p></li><li class="listitem"><p>Package and deploy your war file as you would normally do.
            </p></li></ol></div><p>

    It is that easy! All http requests will go through Hazelcast
    <code class="literal">WebFilter</code>
    and it will put the
    session objects into Hazelcast distributed map if needed.
    </p><p>
        <span class="bold"><strong>Info about sticky-sessions:</strong></span>
    </p><p>
        Hazelcast holds whole session attributes in a distributed map and in local http session. Local session is required
        for fast access to data and distributed map is needed for fail-safety.
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    <span class="italic">If sticky-session is not used, whenever a session attribute
                    is updated in a node (in both node local session and clustered cache),
                    that attribute should be invalidated in all other nodes' local sessions,
                    because now they have dirty value. So when a request arrives one of those other nodes
                    that attribute value is fetched from clustered cache.</span>
                </p></li><li class="listitem"><p>
                    <span class="italic">To overcome performance penalty of sending invalidation messages during updates,
                        sticky-sessions can be used.
                        If Hazelcast knows sessions are sticky, invalidation will not be send, because Hazelcast assumes there is
                        no other local session at the moment. When a server is down, requests belonging to a session hold
                        in that server will routed to other one and that server will fetch session data from clustered cache.
                        That means using sticky-sessions, one will not suffer performance penalty of accessing clustered data
                        and can benefit recover from a server failure.</span>
                </p></li></ul></div><p>
    </p></div></div><div class="chapter" title="Chapter&nbsp;12.&nbsp;WAN Replication"><div class="titlepage"><div><div><h2 class="title"><a name="WanReplication"></a>Chapter&nbsp;12.&nbsp;WAN Replication</h2></div></div></div><div class="simplesect"><div class="titlepage"></div><p>
        There are cases where you would need to synchronize multiple clusters. Synchronization of clusters
        is named as WAN (Wide Area Network) Replication because it is mainly used for replicating different
        clusters running on WAN. Imagine having different clusters in New York, London and Tokyo.
        Each cluster would be operating at very high speed in their LAN (Local Area Network) settings but you would
        want some or all parts of the data in these clusters replicating to each other.
        So updates in Tokyo cluster goes to London and NY,
        in the meantime updates in New York cluster is synchronized to Tokyo and London.
    </p><p>
        You can setup active-passive WAN
        Replication where only one active node replicating its updates on the passive one. You can also setup
        active-active replication where each cluster is actively updating and replication to the other cluster(s).
    </p><p>
        In the active-active replication setup, there might be cases where each node is updating the same entry in the
        same named distributed map. Thus, conflicts will occur when merging. For those cases, conflict-resolution
        will be needed. Here is how you can setup WAN Replication for London cluster for instance:
    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;wan-replication</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"my-wan-cluster"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;target-cluster</font> <font font-style="bold" color="#0A1777">group-name</font>=<font font-style="bold" color="#008000">"tokyo"</font> <font font-style="bold" color="#0A1777">group-password</font>=<font font-style="bold" color="#008000">"tokyo-pass"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;replication-impl&gt;</font>com.hazelcast.wan.WanNoDelayReplication<font font-style="bold" color="#0A1777">&lt;/replication-impl&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;end-points&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;address&gt;</font>10.2.1.1:5701<font font-style="bold" color="#0A1777">&lt;/address&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;address&gt;</font>10.2.1.2:5701<font font-style="bold" color="#0A1777">&lt;/address&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/end-points&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/target-cluster&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;target-cluster</font> <font font-style="bold" color="#0A1777">group-name</font>=<font font-style="bold" color="#008000">"london"</font> <font font-style="bold" color="#0A1777">group-password</font>=<font font-style="bold" color="#008000">"london-pass"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;replication-icom.hazelcast.wan.wan.WanNoDelayReplication&lt;</font>/replication-impl&gt;
            <font font-style="bold" color="#0A1777">&lt;end-points&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;address&gt;</font>10.3.5.1:5701<font font-style="bold" color="#0A1777">&lt;/address&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;address&gt;</font>10.3.5.2:5701<font font-style="bold" color="#0A1777">&lt;/address&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/end-points&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/target-cluster&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/wan-replication&gt;</font>

    <font font-style="bold" color="#0A1777">&lt;network&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;/network&gt;</font>

<font font-style="bold" color="#0A1777">&lt;/network&gt;</font>
...
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>
        This can be the configuration of the cluster running in NY, replicating to Tokyo and London.
        Tokyo and London clusters should have similar configurations if they are also active replicas.
    </p><p>
        If NY and London cluster configurations contain
        <code class="literal">wan-replication</code>
        element and
        Tokyo cluster doesn't then it means NY and London are active endpoints and Tokyo is passive endpoint.
    </p><p>
        As noted earlier you can have Hazelcast replicate some or all of the data in your clusters. You might have
        5 different distributed maps but you might want only one of these maps replicating across clusters.
        So you mark which maps to replicate by adding
        <code class="literal">wan-replication-ref</code>
        element into map configuration.
    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;wan-replication</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"my-wan-cluster"</font><font font-style="bold" color="#0A1777">&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/wan-replication&gt;</font>

    <font font-style="bold" color="#0A1777">&lt;network&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;/network&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"my-shared-map"</font><font font-style="bold" color="#0A1777">&gt;</font>
        ...
        <font font-style="bold" color="#0A1777">&lt;wan-replication-ref</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"my-wan-cluster"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;merge-policy&gt;</font>com.hazelcast.map.merge.PassThroughMergePolicy<font font-style="bold" color="#0A1777">&lt;/merge-policy&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/wan-replication-ref&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/map&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/network&gt;</font>
...
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>
        Here we have
        <code class="literal">my-shared-map</code>
        is configured to replicate itself to the cluster targets defined
        in the
        <code class="literal">wan-replication</code>
        element.
    </p><p>
        Note that you will also need to define a
        <code class="literal">merge policy</code>
        for merging replica entries and resolving conflicts
        during the merge.
    </p></div></div><div class="chapter" title="Chapter&nbsp;13.&nbsp;Service Provider Interface"><div class="titlepage"><div><div><h2 class="title"><a name="SPI"></a>Chapter&nbsp;13.&nbsp;Service Provider Interface</h2></div></div></div><div class="simplesect"><div class="titlepage"></div><p>
        TODO: Will be added later.
    </p></div></div><div class="chapter" title="Chapter&nbsp;14.&nbsp;Configuration"><div class="titlepage"><div><div><h2 class="title"><a name="Config"></a>Chapter&nbsp;14.&nbsp;Configuration</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#ConfigGroup">14.1. Creating Separate Clusters</a></span></dt><dt><span class="sect1"><a href="#NetworkConfig">14.2. Network Configuration</a></span></dt><dd><dl><dt><span class="sect2"><a href="#ConfigTcpIp">14.2.1. Configuring TCP/IP Cluster</a></span></dt><dt><span class="sect2"><a href="#ConfigSpecifyInterfaces">14.2.2. Specifying Network Interfaces</a></span></dt><dt><span class="sect2"><a href="#EC2AutoDiscovery">14.2.3. EC2 Auto Discovery</a></span></dt><dt><span class="sect2"><a href="#NetworkPartitioning">14.2.4. Network Partitioning (Split-Brain Syndrome)</a></span></dt><dt><span class="sect2"><a href="#SSL">14.2.5. SSL</a></span></dt><dt><span class="sect2"><a href="#Encryption">14.2.6. Encryption</a></span></dt><dt><span class="sect2"><a href="#SocketInterceptor">14.2.7. Socket Interceptor</a></span></dt><dt><span class="sect2"><a href="#IPv6">14.2.8. IPv6 Support</a></span></dt><dt><span class="sect2"><a href="#OutboundPorts">14.2.9. Restricting Outbound Ports</a></span></dt></dl></dd><dt><span class="sect1"><a href="#PartitionGroupConfig">14.3. Partition Group Configuration</a></span></dt><dt><span class="sect1"><a href="#ListenerConfig">14.4. Listener Configurations</a></span></dt><dt><span class="sect1"><a href="#WildcardConfiguration">14.5. Wildcard Configuration</a></span></dt><dt><span class="sect1"><a href="#ConfigurationProperties">14.6. Advanced Configuration Properties</a></span></dt><dt><span class="sect1"><a href="#Logging">14.7. Logging Configuration</a></span></dt><dt><span class="sect1"><a href="#EnterpriseConfig">14.8. Setting License Key <sup>(Enterprise Edition Only)</sup></a></span></dt></dl></div><p>
    Hazelcast can be configured through xml or using configuration api or even mix of both.
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                <span class="bold"><strong>Xml Configuration</strong></span>
            </p><p>If you are creating new Hazelcast instance with passing
                <code class="literal">null</code>
                parameter to
                <code class="literal">Hazelcast.newHazelcastInstance(null)</code> or just using empty factory method
                <code class="literal">Hazelcast.newHazelcastInstance()</code>,
                Hazelcast will look into two places for the configuration file:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                            <span class="bold"><strong>System property:</strong></span>
                            Hazelcast will first
                            check if "<code class="literal">hazelcast.config</code>" system property is set to
                            a file path. Example:
                            <code class="literal">-Dhazelcast.config=C:/myhazelcast.xml</code>.
                        </p></li><li class="listitem"><p>
                            <span class="bold"><strong>Classpath:</strong></span>
                            If config file is not set
                            as a system property, Hazelcast will check classpath for
                            <span class="bold"><strong>
                                <code class="literal">hazelcast.xml</code>
                            </strong></span>
                            file.
                        </p></li></ul></div><p>
                If Hazelcast doesn't find any config file, it will happily start with
                default configuration (<code class="literal">hazelcast-default.xml</code>) located in
                <code class="literal">hazelcast.jar</code>. (Before configuring Hazelcast, please try to
                work with default configuration to see if it works for you. Default should be just
                fine for most of the users. If not, then consider custom configuration for your
                environment.)
            </p><p>
                If you want to specify your own configuration file to create
                <code class="literal">Config</code>, Hazelcast supports several ways including filesystem,
                classpath, InputStream, URL etc.:
                </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                            <code class="code">Config cfg = new
                                XmlConfigBuilder(xmlFileName).build();
                            </code>
                        </p></li><li class="listitem"><p>
                            <code class="code">Config cfg = new
                                XmlConfigBuilder(inputStream).build();
                            </code>
                        </p></li><li class="listitem"><p>
                            <code class="code">Config cfg = new
                                ClasspathXmlConfig(xmlFileName);
                            </code>
                        </p></li><li class="listitem"><p>
                            <code class="code">Config cfg = new
                                FileSystemXmlConfig(configFilename);
                            </code>
                        </p></li><li class="listitem"><p>
                            <code class="code">Config cfg = new
                                UrlXmlConfig(url);
                            </code>
                        </p></li><li class="listitem"><p>
                            <code class="code">Config cfg = new
                                InMemoryXmlConfig(xml);
                            </code>
                        </p></li></ul></div><p>
            </p></li><li class="listitem"><p>
                <span class="bold"><strong>Programmatic Configuration</strong></span>
            </p><p>To configure Hazelcast programatically, just instantiate a
                <code class="literal">Config</code> object and set/change its properties/attributes due to
                your needs.
                </p><pre class="programlisting">Config cfg = <strong class="hl-keyword">new</strong> Config();
cfg.setPort(<span class="hl-number">5900</span>);
cfg.setPortAutoIncrement(false);
        
NetworkConfig network = cfg.getNetworkConfig();
JoinConfig join = network.getJoin();
join.getMulticastConfig().setEnabled(false);
join.getTcpIpConfig().addMember(<font font-style="normal" color="#008000">"10.45.67.32"</font>).addMember(<font font-style="normal" color="#008000">"10.45.67.100"</font>)
            .setRequiredMember(<font font-style="normal" color="#008000">"192.168.10.100"</font>).setEnabled(true);
network.getInterfaces().setEnabled(true).addInterface(<font font-style="normal" color="#008000">"10.45.67.*"</font>);
        
MapConfig mapCfg = <strong class="hl-keyword">new</strong> MapConfig();
mapCfg.setName(<font font-style="normal" color="#008000">"testMap"</font>);
mapCfg.setBackupCount(<span class="hl-number">2</span>);
mapCfg.getMaxSizeConfig().setSize(<span class="hl-number">10000</span>);
mapCfg.setTimeToLiveSeconds(<span class="hl-number">300</span>);
        
MapStoreConfig mapStoreCfg = <strong class="hl-keyword">new</strong> MapStoreConfig();
mapStoreCfg.setClassName(<font font-style="normal" color="#008000">"com.hazelcast.examples.DummyStore"</font>).setEnabled(true);
mapCfg.setMapStoreConfig(mapStoreCfg);

NearCacheConfig nearCacheConfig = <strong class="hl-keyword">new</strong> NearCacheConfig();
nearCacheConfig.setMaxSize(<span class="hl-number">1000</span>).setMaxIdleSeconds(<span class="hl-number">120</span>).setTimeToLiveSeconds(<span class="hl-number">300</span>);
mapCfg.setNearCacheConfig(nearCacheConfig);

cfg.addMapConfig(mapCfg);</pre><p>
            </p></li></ol></div><p>
    After creating
    <code class="literal">Config</code>
    object, you can use it to create a new Hazelcast instance.
    </p><pre class="programlisting">
HazelcastInstance hazelcast = Hazelcast.newHazelcastInstance(cfg);
...
</pre><p>

    <a name="NamedHazelcastInstance"></a>
    </p><div class="itemizedlist" title="HazelcastInstance with a name:"><p class="title"><b><a class="link" href="#NamedHazelcastInstance">HazelcastInstance with a name</a>:</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p>To create a named
                <code class="literal">HazelcastInstance</code>
                you should set
                <code class="code">instanceName</code>
                of
                <code class="literal">Config</code>
                object.
            </p><p>
                </p><pre class="programlisting">Config cfg = <strong class="hl-keyword">new</strong> Config();
config.setInstanceName(<font font-style="normal" color="#008000">'my-instance'</font>);
Hazelcast.newHazelcastInstance(config);</pre><p>
            </p></li><li class="listitem"><p>To retrieve an existing
                <code class="literal">HazelcastInstance</code>
                using its name, use;
            </p><p>
                <code class="code">Hazelcast.getHazelcastInstanceByName('my-instance');</code>
            </p></li><li class="listitem"><p>To retrieve all existing<code class="literal">HazelcastInstance</code>s, use;
            </p><p>
                <code class="code">Hazelcast.getAllHazelcastInstances();</code>
            </p></li></ul></div><p>

</p><div class="sect1" title="14.1.&nbsp;Creating Separate Clusters"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ConfigGroup"></a>14.1.&nbsp;Creating Separate Clusters</h2></div></div></div><p>
        By specifying group-name and group-password, you can separate your clusters in a simple way; dev group,
        production group, test group, app-a group etc...

        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;group&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;name&gt;</font>dev<font font-style="bold" color="#0A1777">&lt;/name&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;password&gt;</font>dev-pass<font font-style="bold" color="#0A1777">&lt;/password&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/group&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>

    </p><p>
        You can also set the groupName with
        <code class="literal">Config</code>
        API.
        JVM can host multiple Hazelcast instances (nodes).
        Each node can only participate in one group and it only joins to
        its own group, does not mess with others. Following code creates 3 separate
        Hazelcast nodes,
        <code class="literal">h1</code>
        belongs to
        <code class="literal">app1</code>
        cluster, while
        <code class="literal">h2</code>
        and
        <code class="literal">h3</code>
        are belong to
        <code class="literal">app2</code>
        cluster.
        </p><pre class="programlisting">
Config configApp1 = <strong class="hl-keyword">new</strong> Config();
configApp1.getGroupConfig().setName(<font font-style="normal" color="#008000">"app1"</font>);

Config configApp2 = <strong class="hl-keyword">new</strong> Config();
configApp2.getGroupConfig().setName(<font font-style="normal" color="#008000">"app2"</font>);

HazelcastInstance h1 = Hazelcast.newHazelcastInstance(configApp1);
HazelcastInstance h2 = Hazelcast.newHazelcastInstance(configApp2);
HazelcastInstance h3 = Hazelcast.newHazelcastInstance(configApp2);
</pre><p>
    </p></div><div class="sect1" title="14.2.&nbsp;Network Configuration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="NetworkConfig"></a>14.2.&nbsp;Network Configuration</h2></div></div></div><div class="sect2" title="14.2.1.&nbsp;Configuring TCP/IP Cluster"><div class="titlepage"><div><div><h3 class="title"><a name="ConfigTcpIp"></a>14.2.1.&nbsp;Configuring TCP/IP Cluster</h3></div></div></div><p>If multicast is not preferred way of discovery for your environment, then you can configure Hazelcast for full
        TCP/IP cluster. As configuration below shows, while
        <code class="literal">enable</code>
        attribute of
        <code class="literal">multicast</code>
        is set to false,
        <code class="literal">tcp-ip</code>
        has to be set to true. For the none-multicast option, all or subset of cluster members' hostnames and/or ip
        addresses must be listed. Note that all of the cluster members don't have to be listed there but at least one of
        them has to be active in cluster when a new member joins. The tcp-ip tag accepts an attribute called
        "connection-timeout-seconds".
        The default value is 5. Increasing this value is recommended if you have many IP's listed and members
        can not properly build up the cluster.

        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;network&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;port</font> <font font-style="bold" color="#0A1777">auto-increment</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>5701<font font-style="bold" color="#0A1777">&lt;/port&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;join&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;multicast</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"false"</font><font font-style="bold" color="#0A1777">&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;multicast-group&gt;</font>224.2.2.3<font font-style="bold" color="#0A1777">&lt;/multicast-group&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;multicast-port&gt;</font>54327<font font-style="bold" color="#0A1777">&lt;/multicast-port&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/multicast&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;tcp-ip</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;member&gt;</font>machine1<font font-style="bold" color="#0A1777">&lt;/member&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;member&gt;</font>machine2<font font-style="bold" color="#0A1777">&lt;/member&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;member&gt;</font>machine3:5799<font font-style="bold" color="#0A1777">&lt;/member&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;member&gt;</font>192.168.1.0-7<font font-style="bold" color="#0A1777">&lt;/member&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;member&gt;</font>192.168.1.21<font font-style="bold" color="#0A1777">&lt;/member&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/tcp-ip&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/join&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/network&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>

    </p></div><div class="sect2" title="14.2.2.&nbsp;Specifying Network Interfaces"><div class="titlepage"><div><div><h3 class="title"><a name="ConfigSpecifyInterfaces"></a>14.2.2.&nbsp;Specifying Network Interfaces</h3></div></div></div><p>
        You can also specify which network interfaces that Hazelcast should use. Servers mostly have more than one
        network
        interface so you may want to list the valid IPs. Range characters ('*' and '-') can be used for simplicity. So
        10.3.10.*, for instance, refers to IPs between 10.3.10.0 and 10.3.10.255. Interface 10.3.10.4-18 refers to IPs
        between 10.3.10.4 and 10.3.10.18 (4 and 18 included). If network interface configuration is enabled (disabled by
        default) and if Hazelcast cannot find an matching interface, then it will print a message on console and won't
        start on that node.
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;network&gt;</font>
        ....
        <font font-style="bold" color="#0A1777">&lt;interfaces</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>10.3.16.*<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font> 
            <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>10.3.10.4-18<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font> 
            <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>192.168.1.3<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>         
        <font font-style="bold" color="#0A1777">&lt;/interfaces&gt;</font>    
    <font font-style="bold" color="#0A1777">&lt;/network&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font> 
</pre><p>


    </p></div><div class="sect2" title="14.2.3.&nbsp;EC2 Auto Discovery"><div class="titlepage"><div><div><h3 class="title"><a name="EC2AutoDiscovery"></a>14.2.3.&nbsp;EC2 Auto Discovery</h3></div></div></div><p>Hazelcast supports EC2 Auto Discovery as of 1.9.4. It is useful when you don't want or
        can't provide the list of possible IP addresses. Here is a sample configuration:
        Disable join over multicast and tcp/ip and enable aws. Also provide the credentials.
        The aws tag accepts an attribute called "connection-timeout-seconds". The default value is 5.
        Increasing this value is recommended if you have many IP's listed and members can not properly build up the
        cluster.
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;join&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;multicast</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"false"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;multicast-group&gt;</font>224.2.2.3<font font-style="bold" color="#0A1777">&lt;/multicast-group&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;multicast-port&gt;</font>54327<font font-style="bold" color="#0A1777">&lt;/multicast-port&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/multicast&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;tcp-ip</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"false"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>192.168.1.2<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/tcp-ip&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;aws</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;access-key&gt;</font>my-access-key<font font-style="bold" color="#0A1777">&lt;/access-key&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;secret-key&gt;</font>my-secret-key<font font-style="bold" color="#0A1777">&lt;/secret-key&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;region&gt;</font>us-west-1<font font-style="bold" color="#0A1777">&lt;/region&gt;</font>                              <em class="hl-comment" style="color: silver">&lt;!-- optional, default is us-east-1 --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;host-header&gt;</font>ec2.amazonaws.com<font font-style="bold" color="#0A1777">&lt;/host-header&gt;</font>              <em class="hl-comment" style="color: silver">&lt;!-- optional, default is ec2.amazonaws.com.
                                                If set, region shouldn't be set as it will override this property --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;security-group-name&gt;</font>hazelcast-sg<font font-style="bold" color="#0A1777">&lt;/security-group-name&gt;</font> <em class="hl-comment" style="color: silver">&lt;!-- optional --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;tag-key&gt;</font>type<font font-style="bold" color="#0A1777">&lt;/tag-key&gt;</font>                                  <em class="hl-comment" style="color: silver">&lt;!-- optional --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;tag-value&gt;</font>hz-nodes<font font-style="bold" color="#0A1777">&lt;/tag-value&gt;</font>                          <em class="hl-comment" style="color: silver">&lt;!-- optional --&gt;</em>
    <font font-style="bold" color="#0A1777">&lt;/aws&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/join&gt;</font>
</pre><p>
        You need to add hazelcast-cloud.jar dependency into your project. Note that it is
        also bundled inside hazelcast-all.jar. hazelcast-cloud module doesn't depend on any other third party modules.
    </p></div><div class="sect2" title="14.2.4.&nbsp;Network Partitioning (Split-Brain Syndrome)"><div class="titlepage"><div><div><h3 class="title"><a name="NetworkPartitioning"></a>14.2.4.&nbsp;Network Partitioning (Split-Brain Syndrome)</h3></div></div></div><p>Imagine that you have 10-node cluster and for some reason the network is divided into two
        in a way that 4 servers cannot see the other 6. As a result you ended up having two separate
        clusters; 4-node cluster and 6-node cluster. Members in each sub-cluster are thinking that
        the other nodes are dead even though they are not. This situation is called Network
        Partitioning (aka Split-Brain Syndrome).
    </p><p>Since it is a network failure, there is no way to avoid it programatically and your
        application will run as two separate independent clusters but we should be able to answer the
        following questions: "What will happen after the network failure is fixed and connectivity
        is restored between these two clusters? Will these two clusters merge into one again? If
        they do, how are the data conflicts resolved, because you might end up having two different
        values for the same key in the same map?"
    </p><p>Here is how Hazelcast deals with it:
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>The oldest member of the cluster checks if there is another cluster with the
                    same group-name and group-password in the network.
                </p></li><li class="listitem"><p>If the oldest member founds such cluster, then figures out which cluster
                    should merge to the other.
                </p></li><li class="listitem"><p>Each member of the merging cluster will do the following:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>pause
                        </p></li><li class="listitem"><p>take locally owned map entries</p></li><li class="listitem"><p>close all its network connections (detach from its cluster)</p></li><li class="listitem"><p>join to the new cluster</p></li><li class="listitem"><p>send merge request for each its locally owned map entry</p></li><li class="listitem"><p>resume
                        </p></li></ul></div></li></ol></div><p>
        So each member of the merging cluster is actually rejoining to the new
        cluster and sending merge request for each its locally owned map entry.
    </p><p>
        <span class="bold"><strong>
            <span class="italic">Q: Which cluster will merge into the
                other?
            </span>
        </strong></span>
    </p><p>A. Smaller cluster will merge into the bigger one. If they have equal number of members
        then a hashing algorithm determines the merging cluster.
    </p><p>
        <span class="italic">
            <span class="bold"><strong>Q. Each cluster may have different versions
                of the same key in the same map. How is the conflict
                resolved?
            </strong></span>
        </span>
    </p><p>A. Destination cluster will decide how to handle merging entry based on the
        <code class="literal">MergePolicy</code>
        set for that map. There are built-in merge policies such
        as
        <code class="literal">PassThroughMergePolicy, PutIfAbsentMapMergePolicy, HigherHitsMapMergePolicy and LatestUpdateMapMergePolicy</code>
        but you can develop
        your own merge policy by implementing <code class="literal">com.hazelcast.map.merge.MapMergePolicy</code>. You
        should set the full class name of your implementation to the merge-policy configuration.
        </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">interface</strong> MergePolicy {
    <strong class="hl-tag" style="color: blue">/**
    * Returns the value of the entry after the merge
    * of entries with the same key. Returning value can be
    * You should consider the case where existingEntry is null.
    *
    * @param mapName       name of the map
    * @param mergingEntry  entry merging into the destination cluster
    * @param existingEntry existing entry in the destination cluster
    * @return final value of the entry. If returns null then entry will be removed.
    */</strong>
    Object merge(String mapName, EntryView mergingEntry, EntryView existingEntry);
}</pre><p>
     </p><p>
        Here is how merge policies are specified per map.
        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;backup-count&gt;</font>1<font font-style="bold" color="#0A1777">&lt;/backup-count&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;eviction-policy&gt;</font>NONE<font font-style="bold" color="#0A1777">&lt;/eviction-policy&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;max-size&gt;</font>0<font font-style="bold" color="#0A1777">&lt;/max-size&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;eviction-percentage&gt;</font>25<font font-style="bold" color="#0A1777">&lt;/eviction-percentage&gt;</font>
        <em class="hl-comment" style="color: silver">&lt;!--
            While recovering from split-brain (network partitioning),
            map entries in the small cluster will merge into the bigger cluster
            based on the policy set here. When an entry merge into the
            cluster, there might an existing entry with the same key already.
            Values of these entries might be different for that same key.
            Which value should be set for the key? Conflict is resolved by
            the policy set here. Default policy is hz.ADD_NEW_ENTRY

            There are built-in merge policies such as
            There are built-in merge policies such as
            com.hazelcast.map.merge.PassThroughMergePolicy; entry will be added if there is no existing entry for the key.
            com.hazelcast.map.merge.PutIfAbsentMapMergePolicy ; entry will be added if the merging entry doesn't exist in the cluster.
            com.hazelcast.map.merge.HigherHitsMapMergePolicy ; entry with the higher hits wins.
            com.hazelcast.map.merge.LatestUpdateMapMergePolicy ; entry with the latest update wins.
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;merge-policy&gt;</font>MY_MERGE_POLICY_CLASS<font font-style="bold" color="#0A1777">&lt;/merge-policy&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/map&gt;</font>

    ...
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>
    </p></div><div class="sect2" title="14.2.5.&nbsp;SSL"><div class="titlepage"><div><div><h3 class="title"><a name="SSL"></a>14.2.5.&nbsp;SSL</h3></div></div></div><p>
    Hazelcast allows you to use SSL socket communication among all Hazelcast
    members. You need to implement <code class="code">com.hazelcast.nio.ssl.SSLContextFactory</code>
    and configure SSL section in network configuration.

    </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> MySSLContextFactory <strong class="hl-keyword">implements</strong> SSLContextFactory {
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> init(Properties properties) <strong class="hl-keyword">throws</strong> Exception {
    }

    <strong class="hl-keyword">public</strong> SSLContext getSSLContext() {
        ...
        SSLContext sslCtx = SSLContext.getInstance(protocol);
        <strong class="hl-keyword">return</strong> sslCtx;
    }
}
</pre><p>

    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;network&gt;</font>
        ...
        <font font-style="bold" color="#0A1777">&lt;ssl</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;factory-class-name&gt;</font>com.hazelcast.examples.MySSLContextFactory<font font-style="bold" color="#0A1777">&lt;/factory-class-name&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;properties&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"foo"</font><font font-style="bold" color="#0A1777">&gt;</font>bar<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/properties&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/ssl&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/network&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>
    Hazelcast provides a default SSLContextFactory; <code class="code">com.hazelcast.nio.ssl.BasicSSLContextFactory</code> which
    uses configured keystore to initialize <code class="code">SSLContext</code>. All required is to define <code class="literal">keyStore</code> and
    <code class="literal">keyStorePassword</code>. Also you can set <code class="literal">keyManagerAlgorithm</code> (default <code class="code">SunX509</code>),
    <code class="literal">trustManagerAlgorithm</code> (default <code class="code">SunX509</code>) and <code class="literal">protocol</code> (default <code class="code">TLS</code>).

    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;network&gt;</font>
        ...
        <font font-style="bold" color="#0A1777">&lt;ssl</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;factory-class-name&gt;</font>com.hazelcast.nio.ssl.BasicSSLContextFactory<font font-style="bold" color="#0A1777">&lt;/factory-class-name&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;properties&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"keyStore"</font><font font-style="bold" color="#0A1777">&gt;</font>keyStore<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"keyStorePassword"</font><font font-style="bold" color="#0A1777">&gt;</font>keyStorePassword<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"keyManagerAlgorithm"</font><font font-style="bold" color="#0A1777">&gt;</font>SunX509<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"trustManagerAlgorithm"</font><font font-style="bold" color="#0A1777">&gt;</font>SunX509<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"protocol"</font><font font-style="bold" color="#0A1777">&gt;</font>TLS<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/properties&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/ssl&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/network&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>

    By version 3.1, Hazelcast client has SSL support too. Client SSL configuration can be defined using config API.
        </p><pre class="programlisting">
Properties props = <strong class="hl-keyword">new</strong> Properties();
...
ClientConfig config = <strong class="hl-keyword">new</strong> ClientConfig();
config.getSocketOptions().setSocketFactory(<strong class="hl-keyword">new</strong> SSLSocketFactory(props));

</pre><p>


    You can also set <code class="literal">keyStore</code> and <code class="literal">keyStorePassword</code> through
    <code class="literal">javax.net.ssl.keyStore</code> and <code class="literal">javax.net.ssl.keyStorePassword</code> system properties.

    <span class="italic">Note that, you can not use SSL when <a class="link" href="#Encryption" title="14.2.6.&nbsp;Encryption">Hazelcast Encryption</a> is enabled.</span>
    </p></div><div class="sect2" title="14.2.6.&nbsp;Encryption"><div class="titlepage"><div><div><h3 class="title"><a name="Encryption"></a>14.2.6.&nbsp;Encryption</h3></div></div></div><p>
        Hazelcast allows you to encrypt entire socket level communication among all Hazelcast
        members. Encryption is based on
        <a class="link" href="http://java.sun.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html" target="_top">Java
            Cryptography Architecture
        </a>
        In symmetric encryption, each node uses the same key, so the key is shared.
        Here is a sample configuration for symmetric encryption:
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;network&gt;</font>
        ...
        <em class="hl-comment" style="color: silver">&lt;!--
            Make sure to set enabled=true
            Make sure this configuration is exactly the same on
            all members
        --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;symmetric-encryption</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <em class="hl-comment" style="color: silver">&lt;!--
               encryption algorithm such as
               DES/ECB/PKCS5Padding,
               PBEWithMD5AndDES,
               Blowfish,
               DESede
            --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;algorithm&gt;</font>PBEWithMD5AndDES<font font-style="bold" color="#0A1777">&lt;/algorithm&gt;</font>

            <em class="hl-comment" style="color: silver">&lt;!-- salt value to use when generating the secret key --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;salt&gt;</font>thesalt<font font-style="bold" color="#0A1777">&lt;/salt&gt;</font>

            <em class="hl-comment" style="color: silver">&lt;!-- pass phrase to use when generating the secret key --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;password&gt;</font>thepass<font font-style="bold" color="#0A1777">&lt;/password&gt;</font>

            <em class="hl-comment" style="color: silver">&lt;!-- iteration count to use when generating the secret key --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;iteration-count&gt;</font>19<font font-style="bold" color="#0A1777">&lt;/iteration-count&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/symmetric-encryption&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/network&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>
        Also see <a class="link" href="#SSL" title="14.2.5.&nbsp;SSL">SSL Encryption</a>.
    </p></div><div class="sect2" title="14.2.7.&nbsp;Socket Interceptor"><div class="titlepage"><div><div><h3 class="title"><a name="SocketInterceptor"></a>14.2.7.&nbsp;Socket Interceptor</h3></div></div></div><p>
    Hazelcast allows you to intercept socket connections before a node joins to cluster or a client connects to a node.
    This provides ability to add custom hooks to join/connection procedure (like identity checking using Kerberos, etc.).
    You should implement <code class="code">com.hazelcast.nio.MemberSocketInterceptor</code> for members and
    <code class="code">com.hazelcast.nio.SocketInterceptor</code> for clients.

    </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> MySocketInterceptor <strong class="hl-keyword">implements</strong> MemberSocketInterceptor {
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> init(SocketInterceptorConfig socketInterceptorConfig) {
        <em class="hl-comment" style="color: silver">// initialize interceptor</em>
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> onConnect(Socket connectedSocket) <strong class="hl-keyword">throws</strong> IOException {
        <em class="hl-comment" style="color: silver">// do something meaningful when connected</em>
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> onAccept(Socket acceptedSocket) <strong class="hl-keyword">throws</strong> IOException {
        <em class="hl-comment" style="color: silver">// do something meaningful when accepted a connection</em>
    }
}
</pre><p>

    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;network&gt;</font>
        ...
       <font font-style="bold" color="#0A1777">&lt;socket-interceptor</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
           <font font-style="bold" color="#0A1777">&lt;class-name&gt;</font>com.hazelcast.examples.MySocketInterceptor<font font-style="bold" color="#0A1777">&lt;/class-name&gt;</font>
           <font font-style="bold" color="#0A1777">&lt;properties&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"kerberos-host"</font><font font-style="bold" color="#0A1777">&gt;</font>kerb-host-name<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"kerberos-config-file"</font><font font-style="bold" color="#0A1777">&gt;</font>kerb.conf<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
           <font font-style="bold" color="#0A1777">&lt;/properties&gt;</font>
       <font font-style="bold" color="#0A1777">&lt;/socket-interceptor&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/network&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>


</p><pre class="programlisting">

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> MyClientSocketInterceptor <strong class="hl-keyword">implements</strong> SocketInterceptor {
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> onConnect(Socket connectedSocket) <strong class="hl-keyword">throws</strong> IOException {
        <em class="hl-comment" style="color: silver">// do something meaningful when connected</em>
    }
}

ClientConfig clientConfig = <strong class="hl-keyword">new</strong> ClientConfig();
clientConfig.setGroupConfig(<strong class="hl-keyword">new</strong> GroupConfig(<font font-style="normal" color="#008000">"dev"</font>,<font font-style="normal" color="#008000">"dev-pass"</font>)).addAddress(<font font-style="normal" color="#008000">"10.10.3.4"</font>);

MyClientSocketInterceptor myClientSocketInterceptor = <strong class="hl-keyword">new</strong> MyClientSocketInterceptor();
clientConfig.setSocketInterceptor(myClientSocketInterceptor);
HazelcastInstance client = HazelcastClient.newHazelcastClient(clientConfig);
</pre><p>

</p></div><div class="sect2" title="14.2.8.&nbsp;IPv6 Support"><div class="titlepage"><div><div><h3 class="title"><a name="IPv6"></a>14.2.8.&nbsp;IPv6 Support</h3></div></div></div><p>
        Hazelcast supports IPv6 addresses seamlessly. [
        <span class="emphasis"><em>IPv6 support has been switched off by default.
            <a class="link" href="#IPv6-Note">See note below</a>
        </em></span>
        ]
        All you need is to define IPv6 addresses or interfaces in
        <a class="link" href="#NetworkConfig" title="14.2.&nbsp;Network Configuration">network configuration</a>. Only limitation at the moment is you can not
        define
        wildcard IPv6 addresses in
        <a class="link" href="#ConfigTcpIp" title="14.2.1.&nbsp;Configuring TCP/IP Cluster">TCP-IP</a>
        join configuration.
        <a class="link" href="#ConfigSpecifyInterfaces" title="14.2.2.&nbsp;Specifying Network Interfaces">Interfaces</a>
        section does not have this limitation, you can
        configure wildcard IPv6 interfaces same as IPv4 interfaces.

        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;network&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;port</font> <font font-style="bold" color="#0A1777">auto-increment</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>5701<font font-style="bold" color="#0A1777">&lt;/port&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;join&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;multicast</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"false"</font><font font-style="bold" color="#0A1777">&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;multicast-group&gt;</font>FF02:0:0:0:0:0:0:1<font font-style="bold" color="#0A1777">&lt;/multicast-group&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;multicast-port&gt;</font>54327<font font-style="bold" color="#0A1777">&lt;/multicast-port&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/multicast&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;tcp-ip</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;member&gt;</font>[fe80::223:6cff:fe93:7c7e]:5701<font font-style="bold" color="#0A1777">&lt;/member&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>192.168.1.0-7<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>192.168.1.*<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>fe80:0:0:0:45c5:47ee:fe15:493a<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/tcp-ip&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/join&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;interfaces</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>10.3.16.*<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>10.3.10.4-18<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>fe80:0:0:0:45c5:47ee:fe15:*<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>fe80::223:6cff:fe93:0-5555<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/interfaces&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/network&gt;</font>
</pre><p>
    </p><p>
        JVM has two system properties for setting the preferred protocol stack &#8212;IPv4 or IPv6&#8212; as well as the preferred
        address family types &#8212;inet4 or inet6. On a dual stack machine IPv6 stack is preferred by default, this can be
        changed through
        <code class="code">java.net.preferIPv4Stack=&lt;true|false&gt;</code>
        system property. And when querying name
        services JVM prefers IPv4 addressed over IPv6 addresses and will return an IPv4 address if possible. This can be
        changed through
        <code class="code">java.net.preferIPv6Addresses=&lt;true|false&gt;</code>
        system property.
    </p><p>
        Also see additional<a class="link" href="http://docs.oracle.com/javase/1.5.0/docs/guide/net/ipv6_guide/query.html#details" target="_top">
        details on IPv6 support in Java
    </a>.
    </p><p><a name="IPv6-Note"></a>
        <span class="bold"><strong>Note:</strong></span>
    </p><p>
        IPv6 support has been switched off by default, since some platforms have issues in use of IPv6 stack. And some
        other
        platforms such as Amazon AWS have no support at all. To enable IPv6 support, just set configuration property
        <code class="code">hazelcast.prefer.ipv4.stack</code>
        to false.
        See
        <a class="link" href="#ConfigurationProperties" title="14.6.&nbsp;Advanced Configuration Properties">Configuration Properties.</a>
    </p></div><div class="sect2" title="14.2.9.&nbsp;Restricting Outbound Ports"><div class="titlepage"><div><div><h3 class="title"><a name="OutboundPorts"></a>14.2.9.&nbsp;Restricting Outbound Ports</h3></div></div></div><p>
    By default Hazelcast lets the system to pick up an ephemeral port during socket bind operation.
    But security policies/firewalls may require to restrict outbound ports to be used by Hazelcast enabled applications.
    To fulfill this requirement, you can configure Hazelcast to use only defined outbound ports.

    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;network&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;port</font> <font font-style="bold" color="#0A1777">auto-increment</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>5701<font font-style="bold" color="#0A1777">&lt;/port&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;outbound-ports&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;ports&gt;</font>33000-35000<font font-style="bold" color="#0A1777">&lt;/ports&gt;</font>   <em class="hl-comment" style="color: silver">&lt;!-- ports between 33000 and 35000 --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;ports&gt;</font>37000,37001,37002,37003<font font-style="bold" color="#0A1777">&lt;/ports&gt;</font> <em class="hl-comment" style="color: silver">&lt;!-- comma separated ports --&gt;</em>
            <font font-style="bold" color="#0A1777">&lt;ports&gt;</font>38000,38500-38600<font font-style="bold" color="#0A1777">&lt;/ports&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/outbound-ports&gt;</font>
        ...
    <font font-style="bold" color="#0A1777">&lt;/network&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font>
</pre><p>


    </p><pre class="programlisting">
    ...

    NetworkConfig networkConfig = config.getNetworkConfig();
    networkConfig.addOutboundPortDefinition(<font font-style="normal" color="#008000">"35000-35100"</font>);         <em class="hl-comment" style="color: silver">// ports between 35000 and 35100</em>
    networkConfig.addOutboundPortDefinition(<font font-style="normal" color="#008000">"36001, 36002, 36003"</font>); <em class="hl-comment" style="color: silver">// comma separated ports</em>
    networkConfig.addOutboundPort(<span class="hl-number">37000</span>);
    networkConfig.addOutboundPort(<span class="hl-number">37001</span>);
    ...
</pre><p>

    <span class="italic">* You can use port ranges and/or comma separated ports.</span>
    </p></div></div><div class="sect1" title="14.3.&nbsp;Partition Group Configuration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="PartitionGroupConfig"></a>14.3.&nbsp;Partition Group Configuration</h2></div></div></div><p>Hazelcast distributes key objects into partitions (blocks) using a consistent hashing algorithm and those partitions are assigned to nodes. That means an entry is stored in a node which is owner of partition to that entry's key is assigned. Number of total partitions is default 271 and can be changed with configuration property <code class="code">hazelcast.map.partition.count</code>. Along with those partitions, there are also copies of them as backups. Backup partitions can have multiple copies due to backup count defined in configuration, such as first backup partition, second backup partition etc. As a rule, a node can not hold more than one copy of a partition (ownership or backup). By default Hazelcast distributes partitions and their backup copies randomly and equally among cluster nodes assuming all nodes in the cluster are identical.
    </p><p>
        <span class="italic">What if some nodes share same JVM or physical machine or chassis and you want backups of these nodes to be assigned to nodes in another machine or chassis? What if processing or memory capacities of some nodes are different and you do not want equal number of partitions to be assigned to all nodes?
        </span>
    </p><p>
        You can group nodes in the same JVM (or physical machine) or nodes located in the same chassis. Or you can group nodes to create identical capacity. 
        We call these groups <code class="literal">partition groups</code>. This way partitions are assigned to those partition groups instead of single nodes. And backups of these partitions are located in another partition group.
    </p><p>When you enable partition grouping, Hazelcast presents three choices to configure partition groups at the moments.
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                First one is to group nodes automatically using IP addresses of nodes, so nodes sharing same network interface will be grouped together.
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;partition-group</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font> <font font-style="bold" color="#0A1777">group-type</font>=<font font-style="bold" color="#008000">"HOST_AWARE"</font><font font-style="bold" color="#0A1777"> /&gt;</font></pre><p>
                    </p><pre class="programlisting">
Config config = ...;
PartitionGroupConfig partitionGroupConfig = config.getPartitionGroupConfig();
partitionGroupConfig.setEnabled(true).setGroupType(MemberGroupType.HOST_AWARE);</pre><p>
                </p></li><li class="listitem"><p>
                Second one is custom grouping using Hazelcast's interface matching configuration. This way, you can add different and multiple interfaces to a group. You can also use wildcards in interface addresses.
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;partition-group</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font> <font font-style="bold" color="#0A1777">group-type</font>=<font font-style="bold" color="#008000">"CUSTOM"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;member-group&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>10.10.0.*<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>10.10.3.*<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>10.10.5.*<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/member-group&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;member-group&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>10.10.10.10-100<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>10.10.1.*<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;interface&gt;</font>10.10.2.*<font font-style="bold" color="#0A1777">&lt;/interface&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/member-group
&lt;/partition-group&gt;</font></pre><p>
                    </p><pre class="programlisting">
Config config = ...;
PartitionGroupConfig partitionGroupConfig = config.getPartitionGroupConfig();
partitionGroupConfig.setEnabled(true).setGroupType(MemberGroupType.CUSTOM);

MemberGroupConfig memberGroupConfig = <strong class="hl-keyword">new</strong> MemberGroupConfig();
memberGroupConfig.addInterface(<font font-style="normal" color="#008000">"10.10.0.*"</font>)
    .addInterface(<font font-style="normal" color="#008000">"10.10.3.*"</font>).addInterface(<font font-style="normal" color="#008000">"10.10.5.*"</font>);

MemberGroupConfig memberGroupConfig2 = <strong class="hl-keyword">new</strong> MemberGroupConfig();
memberGroupConfig2.addInterface(<font font-style="normal" color="#008000">"10.10.10.10-100"</font>)
    .addInterface(<font font-style="normal" color="#008000">"10.10.1.*"</font>).addInterface(<font font-style="normal" color="#008000">"10.10.2.*"</font>);

partitionGroupConfig.addMemberGroupConfig(memberGroupConfig);
partitionGroupConfig.addMemberGroupConfig(memberGroupConfig2);</pre><p>
                </p></li><li class="listitem"><p>
                    Third one is to give every member their own group. This gives the least amount of protection and is
                    the default configuration for a Hazelcast cluster.
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;partition-group</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font> <font font-style="bold" color="#0A1777">group-type</font>=<font font-style="bold" color="#008000">"PER_MEMBER"</font><font font-style="bold" color="#0A1777"> /&gt;</font></pre><p>
                    </p><pre class="programlisting">
                        Config config = ...;
                        PartitionGroupConfig partitionGroupConfig = config.getPartitionGroupConfig();
                        partitionGroupConfig.setEnabled(true).setGroupType(MemberGroupType.PER_MEMBER);</pre><p>
                </p></li></ul></div><p>
    </p></div><div class="sect1" title="14.4.&nbsp;Listener Configurations"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ListenerConfig"></a>14.4.&nbsp;Listener Configurations</h2></div></div></div><p>
        Hazelcast provides various event listener extensions to receive specific event types. These are:
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    <span class="bold"><strong>MembershipListener</strong></span> for cluster membership events
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>DistributedObjectListener</strong></span> for distributed object creation and destroy events
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>MigrationListener</strong></span> for partition migration start and complete events
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>LifecycleListener</strong></span> for HazelcastInstance lifecycle events
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>EntryListener</strong></span> for IMap and MultiMap entry events
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>ItemListener</strong></span> for IQueue, ISet and IList item events
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>MessageListener</strong></span> for ITopic message events
                </p></li></ul></div><p>
        These listeners can be added to and removed from related object using Hazelcast API. Such as
        </p><pre class="programlisting">MembershipListener listener = <strong class="hl-keyword">new</strong> MyMembershipListener();
hazelcastInstance.getCluster().addMembershipListener(listener);
hazelcastInstance.getCluster().removeMembershipListener(listener);</pre><p>
        </p><pre class="programlisting">EntryListener listener = <strong class="hl-keyword">new</strong> MyEntryListener();
IMap map = hazelcastInstance.getMap(<font font-style="normal" color="#008000">"default"</font>);
String id =map.addEntryListener(listener, true);
map.removeEntryListener(id);</pre><p>
        </p><pre class="programlisting">ItemListener listener = <strong class="hl-keyword">new</strong> MyItemListener();
IQueue queue = hazelcastInstance.getQueue(<font font-style="normal" color="#008000">"default"</font>);
queue.addItemListener(listener, true);
queue.removeItemListener(listener);</pre><p>
    </p><p>
        Downside of attaching listeners using API is possibility of missing events between creation of object and registering listener. To overcome this race condition Hazelcast introduces registration of listeners in configuration. Listeners can be registered using either Hazelcast XML configuration, Config API or Spring configuration.
    </p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    <span class="bold"><strong>MembershipListener</strong></span>
                </p><p>
                    <span class="italic">Hazelcast XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;listeners&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;listener&gt;</font>com.hazelcast.examples.MembershipListener<font font-style="bold" color="#0A1777">&lt;/listener&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/listeners&gt;</font></pre><p>
                </p><p><span class="italic">Config API</span>
                    </p><pre class="programlisting">
config.addListenerConfig(<strong class="hl-keyword">new</strong> ListenerConfig(<font font-style="normal" color="#008000">"com.hazelcast.examples.MembershipListener"</font>));</pre><p>
                </p><p>
                    <span class="italic">Spring XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hz:listeners&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:listener</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.spring.DummyMembershipListener"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:listener</font> <font font-style="bold" color="#0A1777">implementation</font>=<font font-style="bold" color="#008000">"dummyMembershipListener"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hz:listeners&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>DistributedObjectListener</strong></span>
                </p><p>
                    <span class="italic">Hazelcast XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;listeners&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;listener&gt;</font>com.hazelcast.examples.DistributedObjectListener<font font-style="bold" color="#0A1777">&lt;/listener&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/listeners&gt;</font></pre><p>
                </p><p><span class="italic">Config API</span>
                    </p><pre class="programlisting">
config.addListenerConfig(<strong class="hl-keyword">new</strong> ListenerConfig(<font font-style="normal" color="#008000">"com.hazelcast.examples.DistributedObjectListener"</font>));</pre><p>
                </p><p>
                <span class="italic">Spring XML configuration</span>
                </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hz:listeners&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:listener</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.spring.DummyDistributedObjectListener"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:listener</font> <font font-style="bold" color="#0A1777">implementation</font>=<font font-style="bold" color="#008000">"dummyDistributedObjectListener"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hz:listeners&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>MigrationListener</strong></span>
                </p><p>
                    <span class="italic">Hazelcast XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;listeners&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;listener&gt;</font>com.hazelcast.examples.MigrationListener<font font-style="bold" color="#0A1777">&lt;/listener&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/listeners&gt;</font></pre><p>
                </p><p><span class="italic">Config API</span>
                    </p><pre class="programlisting">
config.addListenerConfig(<strong class="hl-keyword">new</strong> ListenerConfig(<font font-style="normal" color="#008000">"com.hazelcast.examples.MigrationListener"</font>));</pre><p>
                </p><p>
                    <span class="italic">Spring XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hz:listeners&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:listener</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.spring.DummyMigrationListener"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:listener</font> <font font-style="bold" color="#0A1777">implementation</font>=<font font-style="bold" color="#008000">"dummyMigrationListener"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hz:listeners&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>LifecycleListener</strong></span>
                </p><p>
                    <span class="italic">Hazelcast XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;listeners&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;listener&gt;</font>com.hazelcast.examples.LifecycleListener<font font-style="bold" color="#0A1777">&lt;/listener&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/listeners&gt;</font></pre><p>
                </p><p><span class="italic">Config API</span>
                    </p><pre class="programlisting">
config.addListenerConfig(<strong class="hl-keyword">new</strong> ListenerConfig(<font font-style="normal" color="#008000">"com.hazelcast.examples.LifecycleListener"</font>));</pre><p>
                </p><p>
                    <span class="italic">Spring XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hz:listeners&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:listener</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.spring.DummyLifecycleListener"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:listener</font> <font font-style="bold" color="#0A1777">implementation</font>=<font font-style="bold" color="#008000">"dummyLifecycleListener"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hz:listeners&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>EntryListener</strong></span> for IMap
                </p><p>
                    <span class="italic">Hazelcast XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;entry-listeners&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;entry-listener</font> <font font-style="bold" color="#0A1777">include-value</font>=<font font-style="bold" color="#008000">"true"</font> <font font-style="bold" color="#0A1777">local</font>=<font font-style="bold" color="#008000">"false"</font><font font-style="bold" color="#0A1777">&gt;</font>com.hazelcast.examples.EntryListener<font font-style="bold" color="#0A1777">&lt;/entry-listener&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/entry-listeners&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/map&gt;</font></pre><p>
                </p><p><span class="italic">Config API</span>
                    </p><pre class="programlisting">
mapConfig.addEntryListenerConfig(<strong class="hl-keyword">new</strong> EntryListenerConfig(<font font-style="normal" color="#008000">"com.hazelcast.examples.EntryListener"</font>, false, false));</pre><p>
                </p><p>
                <span class="italic">Spring XML configuration</span>
                </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hz:map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:entry-listeners&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:entry-listener</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.spring.DummyEntryListener"</font> <font font-style="bold" color="#0A1777">include-value</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">/&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:entry-listener</font> <font font-style="bold" color="#0A1777">implementation</font>=<font font-style="bold" color="#008000">"dummyEntryListener"</font> <font font-style="bold" color="#0A1777">local</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/hz:entry-listeners&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hz:map&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>EntryListener</strong></span> for MultiMap
                </p><p>
                    <span class="italic">Hazelcast XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;multimap</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;value-collection-type&gt;</font>SET<font font-style="bold" color="#0A1777">&lt;/value-collection-type&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;entry-listeners&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;entry-listener</font> <font font-style="bold" color="#0A1777">include-value</font>=<font font-style="bold" color="#008000">"true"</font> <font font-style="bold" color="#0A1777">local</font>=<font font-style="bold" color="#008000">"false"</font><font font-style="bold" color="#0A1777">&gt;</font>com.hazelcast.examples.EntryListener<font font-style="bold" color="#0A1777">&lt;/entry-listener&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/entry-listeners&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/multimap&gt;</font></pre><p>
                </p><p><span class="italic">Config API</span>
                    </p><pre class="programlisting">
multiMapConfig.addEntryListenerConfig(<strong class="hl-keyword">new</strong> EntryListenerConfig(<font font-style="normal" color="#008000">"com.hazelcast.examples.EntryListener"</font>, false, false));</pre><p>
                </p><p>
                    <span class="italic">Spring XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hz:multimap</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font> <font font-style="bold" color="#0A1777">value-collection-type</font>=<font font-style="bold" color="#008000">"LIST"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:entry-listeners&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:entry-listener</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.spring.DummyEntryListener"</font> <font font-style="bold" color="#0A1777">include-value</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">/&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:entry-listener</font> <font font-style="bold" color="#0A1777">implementation</font>=<font font-style="bold" color="#008000">"dummyEntryListener"</font> <font font-style="bold" color="#0A1777">local</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/hz:entry-listeners&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hz:multimap&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>ItemListener</strong></span> for IQueue
                </p><p>
                    <span class="italic">Hazelcast XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;queue</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;item-listeners&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;item-listener</font> <font font-style="bold" color="#0A1777">include-value</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>com.hazelcast.examples.ItemListener<font font-style="bold" color="#0A1777">&lt;/item-listener&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/item-listeners&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/queue&gt;</font></pre><p>
                </p><p><span class="italic">Config API</span>
                    </p><pre class="programlisting">
queueConfig.addItemListenerConfig(<strong class="hl-keyword">new</strong> ItemListenerConfig(<font font-style="normal" color="#008000">"com.hazelcast.examples.ItemListener"</font>, true));</pre><p>
                </p><p>
                    <span class="italic">Spring XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hz:queue</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777"> &gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:item-listeners&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:item-listener</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.spring.DummyItemListener"</font> <font font-style="bold" color="#0A1777">include-value</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/hz:item-listeners&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hz:queue&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>MessageListener</strong></span> for ITopic
                </p><p>
                    <span class="italic">Hazelcast XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;topic</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;message-listeners&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;message-listener&gt;</font>com.hazelcast.examples.MessageListener<font font-style="bold" color="#0A1777">&lt;/message-listener&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/message-listeners&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/topic&gt;</font></pre><p>
                </p><p><span class="italic">Config API</span>
                    </p><pre class="programlisting">
topicConfig.addMessageListenerConfig(<strong class="hl-keyword">new</strong> ListenerConfig(<font font-style="normal" color="#008000">"com.hazelcast.examples.MessageListener"</font>));</pre><p>
                </p><p>
                    <span class="italic">Spring XML configuration</span>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hz:topic</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"default"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:message-listeners&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:message-listener</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.hazelcast.spring.DummyMessageListener"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/hz:message-listeners&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hz:topic&gt;</font></pre><p>
                </p></li></ul></div><p>
    </p></div><div class="sect1" title="14.5.&nbsp;Wildcard Configuration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="WildcardConfiguration"></a>14.5.&nbsp;Wildcard Configuration</h2></div></div></div><p>Hazelcast supports wildcard configuration of Maps, Queues and Topics. Using an asterisk
        (*) character in the name, different instances of Maps, Queues and Topics can be configured
        by a single configuration.
    </p><p>Note that, with a limitation of a single usage, asterisk (*) can be placed anywhere
        inside the configuration name.
    </p><p>For instance a map named '<code class="code">com.hazelcast.test.mymap</code>' can be configured using one of
        these configurations;
    </p><p>
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"com.hazelcast.test.*"</font><font font-style="bold" color="#0A1777">&gt;</font>
...
<font font-style="bold" color="#0A1777">&lt;/map&gt;</font></pre><p>
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"com.hazel*"</font><font font-style="bold" color="#0A1777">&gt;</font>
...
<font font-style="bold" color="#0A1777">&lt;/map&gt;</font></pre><p>
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"*.test.mymap"</font><font font-style="bold" color="#0A1777">&gt;</font>
...
<font font-style="bold" color="#0A1777">&lt;/map&gt;</font></pre><p>
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"com.*test.mymap"</font><font font-style="bold" color="#0A1777">&gt;</font>
...
<font font-style="bold" color="#0A1777">&lt;/map&gt;</font></pre><p>

        Or a queue '<code class="code">com.hazelcast.test.myqueue</code>'
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;queue</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"*hazelcast.test.myqueue"</font><font font-style="bold" color="#0A1777">&gt;</font>
...
<font font-style="bold" color="#0A1777">&lt;/queue&gt;</font></pre><p>
        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;queue</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"com.hazelcast.*.myqueue"</font><font font-style="bold" color="#0A1777">&gt;</font>
...
<font font-style="bold" color="#0A1777">&lt;/queue&gt;</font></pre><p>
    </p></div><div class="sect1" title="14.6.&nbsp;Advanced Configuration Properties"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ConfigurationProperties"></a>14.6.&nbsp;Advanced Configuration Properties</h2></div></div></div><p>
        There are some advanced configuration properties to tune some aspects
        of Hazelcast. These can be set as property name and value pairs
        through configuration xml, configuration API or JVM system property.
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    <span class="bold"><strong>Configuration xml</strong></span>
                </p><p>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hazelcast</font> <font font-style="bold" color="#0A1777">xsi:schemaLocation</font>=<font font-style="bold" color="#008000">"http://www.hazelcast.com/schema/config
    http://www.hazelcast.com/schema/config/hazelcast-config-3.1.xsd"</font>
    <font font-style="bold" color="#0A1777">xmlns</font>=<font font-style="bold" color="#008000">"http://www.hazelcast.com/schema/config"</font>
    <font font-style="bold" color="#0A1777">xmlns:xsi</font>=<font font-style="bold" color="#008000">"http://www.w3.org/2001/XMLSchema-instance"</font><font font-style="bold" color="#0A1777">&gt;</font>
    ....
    <font font-style="bold" color="#0A1777">&lt;properties&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"hazelcast.property.foo"</font><font font-style="bold" color="#0A1777">&gt;</font>value<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
            ....
    <font font-style="bold" color="#0A1777">&lt;/properties&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>Configuration API</strong></span>
                </p><p>
                    </p><pre class="programlisting">
Config cfg = <strong class="hl-keyword">new</strong> Config() ;
cfg.setProperty(<font font-style="normal" color="#008000">"hazelcast.property.foo"</font>, <font font-style="normal" color="#008000">"value"</font>);
                    </pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>System Property</strong></span>
                </p><p>
                    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Using JVM parameter:
                                <code class="literal">java -Dhazelcast.property.foo=value</code>
                            </p></li><li class="listitem"><p>Using System class:
                                <code class="literal">System.setProperty("hazelcast.property.foo", "value");
                                </code>
                            </p></li></ol></div><p>
                </p></li></ul></div><p>
    </p><table border="1" width="950" id="d0e4250"><caption>Table&nbsp;14.1.&nbsp;Properties Table</caption><col width="44%"><col width="36%"><col width="10%"><col width="6%"><col width="2%"><col width="2%"><col width="2%"><thead><tr>
                <th>Property Name</th>
                <th>Description</th>
                <th>Value Type</th>
                <th>Default</th>
            </tr></thead><tbody><tr>
                <td>
                    <code class="literal"><a name="hazelcast.memcache.enabled"></a>hazelcast.memcache.enabled</code>
                </td>
                <td>Enable
                    <a class="link" href="#MemcacheClient" title="17.2.&nbsp;Memcache Client">Memcache</a>
                    client request listener service
                </td>
                <td>boolean</td>
                <td>true</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.rest.enabled</code>
                </td>
                <td>Enable
                    <a class="link" href="#RestClient" title="17.3.&nbsp;Rest Client">REST</a>
                    client request listener service
                </td>
                <td>boolean</td>
                <td>true</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.logging.type</code>
                </td>
                <td>Name of
                    <a class="link" href="#Logging" title="14.7.&nbsp;Logging Configuration">logging</a>
                    framework type to send logging events.
                </td>
                <td>enum</td>
                <td>jdk</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.map.load.chunk.size</code>
                </td>
                <td>Chunk size for
                    <a class="link" href="#MapPersistence" title="2.1.3.&nbsp;Persistence">MapLoader</a>
                    's map initialization
                    process (MapLoder.loadAllKeys())
                </td>
                <td>integer</td>
                <td>1000</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.merge.first.run.delay.seconds</code>
                </td>
                <td>Inital run delay of
                    <a class="link" href="#NetworkPartitioning" title="14.2.4.&nbsp;Network Partitioning (Split-Brain Syndrome)">split brain/merge process</a>
                    in seconds
                </td>
                <td>integer</td>
                <td>300</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.merge.next.run.delay.seconds</code>
                </td>
                <td>Run interval of
                    <a class="link" href="#NetworkPartitioning" title="14.2.4.&nbsp;Network Partitioning (Split-Brain Syndrome)">split brain/merge process</a>
                    in
                    seconds
                </td>
                <td>integer</td>
                <td>120</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.socket.bind.any</code>
                </td>
                <td>Bind both server-socket and client-sockets to any local interface</td>
                <td>boolean</td>
                <td>true</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.socket.server.bind.any</code>
                </td>
                <td>Bind server-socket to any local interface.
                    If not set, <code class="literal">hazelcast.socket.bind.any</code> will be used as default.</td>
                <td>boolean</td>
                <td>true</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.socket.client.bind.any</code>
                </td>
                <td>Bind client-sockets to any local interface.
                    If not set, <code class="literal">hazelcast.socket.bind.any</code> will be used as default.</td>
                <td>boolean</td>
                <td>true</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.socket.receive.buffer.size</code>
                </td>
                <td>Socket receive buffer size in KB</td>
                <td>integer</td>
                <td>32</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.socket.send.buffer.size</code>
                </td>
                <td>Socket send buffer size in KB</td>
                <td>integer</td>
                <td>32</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.socket.keep.alive</code>
                </td>
                <td>Socket set keep alive</td>
                <td>boolean</td>
                <td>true</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.socket.no.delay</code>
                </td>
                <td>Socket set TCP no delay</td>
                <td>boolean</td>
                <td>true</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.prefer.ipv4.stack</code>
                </td>
                <td>Prefer Ipv4 network interface when picking a local address.</td>
                <td>boolean</td>
                <td>true</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.shutdownhook.enabled</code>
                </td>
                <td>Enable Hazelcast shutdownhook thread</td>
                <td>boolean</td>
                <td>true</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.wait.seconds.before.join</code>
                </td>
                <td>Wait time before join operation</td>
                <td>integer</td>
                <td>5</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.max.wait.seconds.before.join</code>
                </td>
                <td>Maximum wait time before join operation</td>
                <td>integer</td>
                <td>20</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.heartbeat.interval.seconds</code>
                </td>
                <td>Heartbeat send interval in seconds</td>
                <td>integer</td>
                <td>1</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.max.no.heartbeat.seconds</code>
                </td>
                <td>Max timeout of heartbeat in seconds for a node to assume it is dead</td>
                <td>integer</td>
                <td>300</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.icmp.enabled</code>
                </td>
                <td>Enable ICMP ping</td>
                <td>boolean</td>
                <td>false</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.icmp.timeout</code>
                </td>
                <td>ICMP timeout in ms</td>
                <td>int</td>
                <td>1000</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.icmp.ttl</code>
                </td>
                <td>ICMP TTL (maximum numbers of hops to try)</td>
                <td>int</td>
                <td>0</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.master.confirmation.interval.seconds</code>
                </td>
                <td>Interval at which nodes send master confirmation</td>
                <td>integer</td>
                <td>30</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.max.no.master.confirmation.seconds</code>
                </td>
                <td>Max timeout of master confirmation from other nodes</td>
                <td>integer</td>
                <td>450</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.member.list.publish.interval.seconds</code>
                </td>
                <td>Interval at which master node publishes a member list</td>
                <td>integer</td>
                <td>600</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.prefer.ipv4.stack</code>
                </td>
                <td>Prefer IPv4 Stack, don't use IPv6. See <a class="link" href="#IPv6" title="14.2.8.&nbsp;IPv6 Support">IPv6 doc.</a></td>
                <td>boolean</td>
                <td>true</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.initial.min.cluster.size</code>
                </td>
                <td>Initial expected cluster size to wait before node to start completely</td>
                <td>integer</td>
                <td>0</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.initial.wait.seconds</code>
                </td>
                <td>Inital time in seconds to wait before node to start completely</td>
                <td>integer</td>
                <td>0</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.partition.count</code>
                </td>
                <td>Total partition count</td>
                <td>integer</td>
                <td>271</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.jmx</code>
                </td>
                <td>Enable
                    <a class="link" href="#JMX" title="Chapter&nbsp;7.&nbsp;Monitoring with JMX">JMX</a>
                    agent
                </td>
                <td>boolean</td>
                <td>false</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.jmx.detailed</code>
                </td>
                <td>Enable detailed views on
                    <a class="link" href="#JMX" title="Chapter&nbsp;7.&nbsp;Monitoring with JMX">JMX</a>
                </td>
                <td>boolean</td>
                <td>false</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.mc.map.excludes</code>
                </td>
                <td>Comma seperated map names to exclude from
                    <a class="link" href="http://www.hazelcast.com/mancenter.jsp" target="_top">Hazelcast Management
                        Center
                    </a>
                </td>
                <td>CSV</td>
                <td>null</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.mc.queue.excludes</code>
                </td>
                <td>Comma seperated queue names to exclude from
                    <a class="link" href="http://www.hazelcast.com/mancenter.jsp" target="_top">Hazelcast Management
                        Center
                    </a>
                </td>
                <td>CSV</td>
                <td>null</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.mc.topic.excludes</code>
                </td>
                <td>Comma seperated topic names to exclude from
                    <a class="link" href="http://www.hazelcast.com/mancenter.jsp" target="_top">Hazelcast Management
                        Center
                    </a>
                </td>
                <td>CSV</td>
                <td>null</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.version.check.enabled</code>
                </td>
                <td>Enable Hazelcast new version check on startup</td>
                <td>boolean</td>
                <td>true</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.mc.max.visible.instance.count</code>
                </td>
                <td>Management Center maximum visible instance count</td>
                <td>integer</td>
                <td>100</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.connection.monitor.interval</code>
                </td>
                <td>Minimum interval to consider a connection error as critical in milliseconds.</td>
                <td>integer</td>
                <td>100</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.connection.monitor.max.faults</code>
                </td>
                <td>Maximum IO error count before disconnecting from a node.</td>
                <td>integer</td>
                <td>3</td>
            </tr><tr>
                <td>
                    <code class="literal"><a name="hazelcast.partition.migration.interval"></a>hazelcast.partition.migration.interval</code>
                </td>
                <td>Interval to run partition migration tasks in seconds.</td>
                <td>integer</td>
                <td>0</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.partition.migration.timeout</code>
                </td>
                <td>Timeout for partition migration tasks in seconds.</td>
                <td>integer</td>
                <td>300</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.graceful.shutdown.max.wait</code>
                </td>
                <td>Maximum wait seconds during graceful shutdown.</td>
                <td>integer</td>
                <td>600</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.mc.url.change.enabled</code>
                </td>
                <td>Management Center changing server url is enabled</td>
                <td>boolean</td>
                <td>true</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.elastic.memory.enabled</code>
                </td>
                <td>Enable
                    <a class="link" href="#ElasticMemory" title="Chapter&nbsp;4.&nbsp;Elastic Memory (Enterprise Edition Only)">Hazelcast Elastic Memory</a>
                    off-heap storage
                </td>
                <td>boolean</td>
                <td>false</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.elastic.memory.total.size</code>
                </td>
                <td>
                    <a class="link" href="#ElasticMemory" title="Chapter&nbsp;4.&nbsp;Elastic Memory (Enterprise Edition Only)">Hazelcast Elastic Memory</a>
                    storage total size in MB
                </td>
                <td>integer</td>
                <td>128</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.elastic.memory.chunk.size</code>
                </td>
                <td>
                    <a class="link" href="#ElasticMemory" title="Chapter&nbsp;4.&nbsp;Elastic Memory (Enterprise Edition Only)">Hazelcast Elastic Memory</a>
                    storage chunk size in KB
                </td>
                <td>integer</td>
                <td>1</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.elastic.memory.shared.storage</code>
                </td>
                <td>
                    <a class="link" href="#ElasticMemory" title="Chapter&nbsp;4.&nbsp;Elastic Memory (Enterprise Edition Only)">Enable Hazelcast Elastic Memory</a>
                    shared storage
                </td>
                <td>boolean</td>
                <td>false</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.enterprise.license.key</code>
                </td>
                <td>
                    <a class="link" href="http://www.hazelcast.com/products.jsp" target="_top">Hazelcast Enterprise</a>
                    license key
                </td>
                <td>string</td>
                <td>null</td>
            </tr><tr>
                <td>
                    <code class="literal">hazelcast.system.log.enabled</code>
                </td>
                <td>
                    Enable system logs
                </td>
                <td>boolean</td>
                <td>true</td>
            </tr></tbody></table></div><div class="sect1" title="14.7.&nbsp;Logging Configuration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Logging"></a>14.7.&nbsp;Logging Configuration</h2></div></div></div><p>Hazelcast has a flexible logging configuration and doesn't depend on any logging framework except JDK logging.
        It has in-built adaptors for a number of logging frameworks
        and also supports custom loggers by providing logging interfaces.
    </p><p>To use built-in adaptors you should set
        <code class="code">hazelcast.logging.type</code>
        property to one of
        predefined types below.
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="bold"><strong>jdk:</strong></span>JDK logging (default)
                </p></li><li class="listitem"><p><span class="bold"><strong>log4j:</strong></span>Log4j
                </p></li><li class="listitem"><p><span class="bold"><strong>slf4j:</strong></span>Slf4j
                </p></li><li class="listitem"><p><span class="bold"><strong>none:</strong></span>disable logging
                </p></li></ul></div><p>

        You can set
        <code class="code">hazelcast.logging.type</code>
        through configuration xml, configuration API or JVM system property.
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                    <span class="bold"><strong>Configuration xml</strong></span>
                </p><p>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hazelcast</font> <font font-style="bold" color="#0A1777">xsi:schemaLocation</font>=<font font-style="bold" color="#008000">"http://www.hazelcast.com/schema/config
    http://www.hazelcast.com/schema/config/hazelcast-config-3.1.xsd"</font>
    <font font-style="bold" color="#0A1777">xmlns</font>=<font font-style="bold" color="#008000">"http://www.hazelcast.com/schema/config"</font>
    <font font-style="bold" color="#0A1777">xmlns:xsi</font>=<font font-style="bold" color="#008000">"http://www.w3.org/2001/XMLSchema-instance"</font><font font-style="bold" color="#0A1777">&gt;</font>

    ....

    <font font-style="bold" color="#0A1777">&lt;properties&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"hazelcast.logging.type"</font><font font-style="bold" color="#0A1777">&gt;</font>jdk<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
        ....
    <font font-style="bold" color="#0A1777">&lt;/properties&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font></pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>Configuration API</strong></span>
                </p><p>
                    </p><pre class="programlisting">
Config cfg = <strong class="hl-keyword">new</strong> Config() ;
cfg.setProperty(<font font-style="normal" color="#008000">"hazelcast.logging.type"</font>, <font font-style="normal" color="#008000">"log4j"</font>);
                    </pre><p>
                </p></li><li class="listitem"><p>
                    <span class="bold"><strong>System Property</strong></span>
                </p><p>
                    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Using JVM parameter:
                                <code class="literal">java -Dhazelcast.logging.type=slf4j</code>
                            </p></li><li class="listitem"><p>Using System class:
                                <code class="literal">System.setProperty("hazelcast.logging.type", "none");</code>
                            </p></li></ol></div><p>
                </p></li></ul></div><p>
    </p><p>To use custom logging feature you should implement
        <code class="code">com.hazelcast.logging.LoggerFactory</code>
        and
        <code class="code">com.hazelcast.logging.ILogger</code>
        interfaces and set system property
        <code class="literal">hazelcast.logging.class</code>
        to
        your custom
        <code class="code">LoggerFactory</code>
        class name.
        </p><pre class="programlisting">java -Dhazelcast.logging.<strong class="hl-keyword">class</strong>=foo.bar.MyLoggingFactory</pre><p>
    </p><p>
        You can also listen to logging events generated by Hazelcast runtime by registering <code class="literal">LogListener</code>s to<code class="literal">LoggingService</code>.
        </p><pre class="programlisting">
LogListener listener = <strong class="hl-keyword">new</strong> LogListener() {
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> log(LogEvent logEvent) {
        <em class="hl-comment" style="color: silver">// do something</em>
    }
}
LoggingService loggingService = Hazelcast.getLoggingService();
loggingService.addLogListener(Level.INFO, listener):
        </pre><p>
        Through the
        <code class="literal">LoggingService</code>
        you can get the current used ILogger implementation and log your own messages too.
    </p></div><div class="sect1" title="14.8.&nbsp;Setting License Key (Enterprise Edition Only)"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="EnterpriseConfig"></a>14.8.&nbsp;Setting License Key <sup>(Enterprise Edition Only)</sup></h2></div></div></div><p>To be able to use Hazelcast Enterprise Edition, you need to set license key in configuration.</p><p>
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p><span class="bold"><strong>Hazelcast XML Configuration</strong></span> </p><p>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hazelcast&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;license-key&gt;</font>HAZELCAST_ENTERPRISE_LICENSE_KEY<font font-style="bold" color="#0A1777">&lt;/license-key&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font></pre><p>
                </p></li><li class="listitem"><p><span class="bold"><strong>Hazelcast Config API</strong></span> </p><p>
                    </p><pre class="programlisting">
Config config = <strong class="hl-keyword">new</strong> Config();
config.setLicenseKey(<font font-style="normal" color="#008000">"HAZELCAST_ENTERPRISE_LICENSE_KEY"</font>);
</pre><p>
                </p></li><li class="listitem"><p><span class="bold"><strong>Spring XML Configuration</strong></span> </p><p>
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hz:config&gt;</font>
    ...
    <font font-style="bold" color="#0A1777">&lt;hz:license-key&gt;</font>HAZELCAST_ENTERPRISE_LICENSE_KEY<font font-style="bold" color="#0A1777">&lt;/hz:license-key&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/hazelcast&gt;</font></pre><p>
                </p></li><li class="listitem"><p><span class="bold"><strong>JVM System Property</strong></span> </p><p>
                    </p><pre class="programlisting">-Dhazelcast.enterprise.license.key=HAZELCAST_ENTERPRISE_LICENSE_KEY</pre><p>
                </p></li></ul></div><p>
    </p></div></div><div class="chapter" title="Chapter&nbsp;15.&nbsp;Hibernate Second Level Cache"><div class="titlepage"><div><div><h2 class="title"><a name="HibernateSecondLevelCache"></a>Chapter&nbsp;15.&nbsp;Hibernate Second Level Cache</h2></div></div></div><div class="simplesect"><div class="titlepage"></div><p>
    Hazelcast provides distributed second level cache for
    your Hibernate entities, collections and queries. Hazelcast has two implementations of Hibernate
    2nd level cache, one for hibernate-pre-3.3 and one for hibernate-3.3.x versions. In your
    Hibernate configuration file (ex: hibernate.cfg.xml), add these properties:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>To enable use of second level cache
                </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"hibernate.cache.use_second_level_cache"</font><font font-style="bold" color="#0A1777">&gt;</font>true<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
</pre><p>
            </p></li><li class="listitem"><p>To enable use of query cache
                </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"hibernate.cache.use_query_cache"</font><font font-style="bold" color="#0A1777">&gt;</font>true<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
</pre><p>
            </p></li><li class="listitem"><p>And to force minimal puts into cache
                </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"hibernate.cache.use_minimal_puts"</font><font font-style="bold" color="#0A1777">&gt;</font>true<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
</pre><p>
            </p></li><li class="listitem"><p>To configure Hazelcast for Hibernate, it is enough to put configuration file named
                <code class="literal">hazelcast.xml</code>
                into root of your classpath. If Hazelcast can
                not find
                <code class="literal">hazelcast.xml</code>
                then it will use default configuration
                from hazelcast.jar.
            </p></li><li class="listitem"><p>You can define custom named Hazelcast configuration xml file with one of these
                Hibernate configuration properties.
                </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"hibernate.cache.provider_configuration_file_resource_path"</font><font font-style="bold" color="#0A1777">&gt;</font>
     hazelcast-custom-config.xml
<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
                </pre><p>
                or
                </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"hibernate.cache.hazelcast.configuration_file_path"</font><font font-style="bold" color="#0A1777">&gt;</font>
     hazelcast-custom-config.xml
<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
                </pre><p>
            </p></li><li class="listitem"><p>You can set up Hazelcast to connect cluster as Native Client. Native client is not
                member and it connects to one of the cluster members and delegates all cluster wide
                operations to it. When the relied cluster member dies, client will transparently
                switch to another live member.
                </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"hibernate.cache.hazelcast.use_native_client"</font><font font-style="bold" color="#0A1777">&gt;</font>true<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
</pre><p>
                To setup Native Client properly, you should add Hazelcast 
                <span class="bold"><strong>group-name</strong></span>, 
                <span class="bold"><strong>group-password</strong></span> and
                <span class="bold"><strong>cluster member address</strong></span> properties. 
                Native Client
                will connect to defined member and will get addresses of all members in the cluster.
                If the connected member will die or leave the cluster, client will automatically
                switch to another member in the cluster.
                </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"hibernate.cache.hazelcast.native_client_address"</font><font font-style="bold" color="#0A1777">&gt;</font>10.34.22.15<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
<font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"hibernate.cache.hazelcast.native_client_group"</font><font font-style="bold" color="#0A1777">&gt;</font>dev<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
<font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"hibernate.cache.hazelcast.native_client_password"</font><font font-style="bold" color="#0A1777">&gt;</font>dev-pass<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
</pre><p>
                <span class="italic">To use Native Client you should add
                    <code class="literal">hazelcast-client-&lt;version&gt;.jar</code>
                    into your
                    classpath.
                </span>
            </p><p>
                <a class="link" href="#NativeClient" title="17.1.&nbsp;Native Client">Read more about NativeClient</a>
            </p></li><li class="listitem"><p>To define Hibernate RegionFacyory, add following property.
                </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"hibernate.cache.region.factory_class"</font><font font-style="bold" color="#0A1777">&gt;</font>
     com.hazelcast.hibernate.HazelcastCacheRegionFactory
<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
				</pre><p>

                Or as an alternative you can use <code class="code">HazelcastLocalCacheRegionFactory</code>
                which stores data in local node and sends invalidation messages when an entry is updated on local.
                </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"hibernate.cache.region.factory_class"</font><font font-style="bold" color="#0A1777">&gt;</font>
     com.hazelcast.hibernate.HazelcastLocalCacheRegionFactory
<font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
                </pre><p>
            </p></li></ul></div><p>
    Hazelcast creates a separate distributed map for each Hibernate cache region. So
    these regions can be configured easily via Hazelcast map configuration. You can define 
    <span class="bold"><strong>backup</strong></span>,
    <span class="bold"><strong>eviction</strong></span>,
    <span class="bold"><strong>TTL</strong></span> and
    <span class="bold"><strong>Near Cache</strong></span> properties.
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                <a class="link" href="#MapBackup" title="2.1.1.&nbsp;Backups">Backup Configuration</a>
            </p></li><li class="listitem"><p>
                <a class="link" href="#MapEviction" title="2.1.2.&nbsp;Eviction">Eviction And TTL Configuration</a>
            </p></li><li class="listitem"><p>
                <a class="link" href="#MapNearCache" title="2.1.9.&nbsp;Near Cache">Near Cache Configuration</a>
            </p></li></ul></div><p>
    Hibernate has four cache concurrency strategies:
    <span class="emphasis"><em>read-only</em></span>, 
    <span class="emphasis"><em>read-write</em></span>, 
    <span class="emphasis"><em>nonstrict-read-write</em></span> and
    <span class="emphasis"><em>transactional</em></span>. 
    But Hibernate does not forces cache providers to support all strategies. And Hazelcast supports
    first three (<span class="bold"><strong>read-only</strong></span>, 
    	<span class="bold"><strong>read-write</strong></span>, 
    	<span class="bold"><strong>nonstrict-read-write</strong></span>) of these four strategies. 
       Hazelcast has no support for <span class="emphasis"><em>transactional</em></span> strategy yet.
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>If you are using xml based class configurations, you should add a
                <span class="emphasis"><em>cache</em></span> element into your configuration with
                <span class="emphasis"><em>usage</em></span> attribute with one of 
                <span class="emphasis"><em>read-only</em></span>, 
                <span class="emphasis"><em>read-write</em></span>, 
                <span class="emphasis"><em>nonstrict-read-write</em></span>.
                </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;class</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"eg.Immutable"</font> <font font-style="bold" color="#0A1777">mutable</font>=<font font-style="bold" color="#008000">"false"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;cache</font> <font font-style="bold" color="#0A1777">usage</font>=<font font-style="bold" color="#008000">"read-only"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    .... 
<font font-style="bold" color="#0A1777">&lt;/class&gt;</font>

<font font-style="bold" color="#0A1777">&lt;class</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"eg.Cat"</font> <font font-style="bold" color="#0A1777">....</font><font font-style="bold" color="#0A1777"> &gt;</font>
    <font font-style="bold" color="#0A1777">&lt;cache</font> <font font-style="bold" color="#0A1777">usage</font>=<font font-style="bold" color="#008000">"read-write"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    ....
    <font font-style="bold" color="#0A1777">&lt;set</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"kittens"</font> <font font-style="bold" color="#0A1777">...</font><font font-style="bold" color="#0A1777"> &gt;</font>
        <font font-style="bold" color="#0A1777">&lt;cache</font> <font font-style="bold" color="#0A1777">usage</font>=<font font-style="bold" color="#008000">"read-write"</font><font font-style="bold" color="#0A1777">/&gt;</font>
        ....
    <font font-style="bold" color="#0A1777">&lt;/set&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/class&gt;</font>
</pre><p>
            </p></li><li class="listitem"><p>If you are using Hibernate-Annotations then you can add
                <span class="emphasis"><em>class-cache</em></span> or
                <span class="emphasis"><em>collection-cache</em></span> element into your Hibernate configuration file with
                <span class="emphasis"><em>usage</em></span> attribute with one of 
                <span class="emphasis"><em>read only</em></span>,
                <span class="emphasis"><em>read/write</em></span>,
                <span class="emphasis"><em>nonstrict read/write</em></span>.
                </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;class-cache</font> <font font-style="bold" color="#0A1777">usage</font>=<font font-style="bold" color="#008000">"read-only"</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"eg.Immutable"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;class-cache</font> <font font-style="bold" color="#0A1777">usage</font>=<font font-style="bold" color="#008000">"read-write"</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"eg.Cat"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;collection-cache</font> <font font-style="bold" color="#0A1777">collection</font>=<font font-style="bold" color="#008000">"eg.Cat.kittens"</font> <font font-style="bold" color="#0A1777">usage</font>=<font font-style="bold" color="#008000">"read-write"</font><font font-style="bold" color="#0A1777">/&gt;</font>
</pre><p>
            </p></li></ul></div><p>
    OR
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Alternatively, you can put Hibernate Annotation's
                <span class="emphasis"><em>@Cache</em></span>
                annotation on your entities and collections.
                </p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Cache(usage = CacheConcurrencyStrategy.READ_WRITE)</span></em>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> Cat <strong class="hl-keyword">implements</strong> Serializable {
     ...
}
</pre><p>
            </p></li></ul></div><p>
    The last thing you should be aware of is to drop
    hazelcast-hibernate-&lt;version&gt;.jar into your classpath.

    </p><div class="itemizedlist" title="Additional Properties:"><p class="title"><b>Additional Properties:</b></p><ul class="itemizedlist" type="disc"><li class="listitem"><p>
                <span class="bold"><strong>Accessing underlying
                    <code class="code">HazelcastInstance</code>
                </strong></span>
            </p><p>Using
                <code class="code">com.hazelcast.hibernate.instance.HazelcastAccessor</code>
                you can access the underlying
                <code class="code">HazelcastInstance</code>
                used by Hibernate SessionFactory.
                </p><pre class="programlisting">SessionFactory sessionFactory = ...;
HazelcastInstance hazelcastInstance = HazelcastAccessor.getHazelcastInstance(sessionFactory);        
</pre><p>
            </p></li><li class="listitem"><p>
                <span class="bold"><strong>Changing/setting lock timeout value of
                    <span class="italic">read-write</span>
                    strategy
                </strong></span>
            </p><p>Lock timeout value can be set using
                <code class="literal">hibernate.cache.hazelcast.lock_timeout_in_seconds</code>
                Hibernate property.
                Value should be in seconds and default value is 300 seconds.
            </p></li><li class="listitem"><p>
                <span class="bold"><strong>Using named
                    <code class="literal">HazelcastInstance</code>
                </strong></span>
            </p><p>
            	Instead of creating a new <code class="literal">HazelcastInstance</code> for each <code class="literal">SessionFactory</code>,
                an existing instance can be used by setting
                <code class="literal">hibernate.cache.hazelcast.instance_name</code>
                Hibernate property to <code class="literal">HazelcastInstance</code>'s name.
                For more information see <a class="link" href="#NamedHazelcastInstance">Named HazelcastInstance</a>.
            </p></li><li class="listitem"><p>
                <span class="bold"><strong>Disabling shutdown during SessionFactory.close()</strong></span>
            </p><p>Shutting down
                <code class="literal">HazelcastInstance</code>
                can be disabled during
                <code class="code">SessionFactory.close()</code>
                by setting
                <code class="literal">hibernate.cache.hazelcast.shutdown_on_session_factory_close</code>
                Hibernate property to false.
                <span class="italic">(In this case Hazelcast property
                    <code class="literal">hazelcast.shutdownhook.enabled</code>
                    should not
                    be set to false.)
                </span>
                Default value is <code class="literal">true</code>.
            </p></li></ul></div><p>
    </p></div></div><div class="chapter" title="Chapter&nbsp;16.&nbsp;Spring Integration"><div class="titlepage"><div><div><h2 class="title"><a name="SpringIntegration"></a>Chapter&nbsp;16.&nbsp;Spring Integration</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#SpringConfiguration">16.1. Configuration</a></span></dt><dt><span class="sect1"><a href="#SpringContext">16.2. Spring Managed Context</a></span></dt><dt><span class="sect1"><a href="#SpringCache">16.3. Spring Cache</a></span></dt><dt><span class="sect1"><a href="#SpringHibernate">16.4. Hibernate 2nd Level Cache Config</a></span></dt><dt><span class="sect1"><a href="#SpringJPA">16.5. Spring Data - JPA</a></span></dt><dt><span class="sect1"><a href="#SpringMongoDB">16.6. Spring Data - MongoDB</a></span></dt></dl></div><div class="sect1" title="16.1.&nbsp;Configuration"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SpringConfiguration"></a>16.1.&nbsp;Configuration</h2></div></div></div><p>
    You can declare Hazelcast beans for Spring context
    using <span class="emphasis"><em>beans</em></span> namespace (default spring <span class="emphasis"><em>beans</em></span> namespace)
    as well to declare hazelcast maps, queues and others.
    <span class="bold"><strong>Hazelcast-Spring integration requires either hazelcast-spring jar or hazelcast-all jar in the
        classpath.
    </strong></span>
    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"instance"</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"com.hazelcast.core.Hazelcast"</font> <font font-style="bold" color="#0A1777">factory-method</font>=<font font-style="bold" color="#008000">"newHazelcastInstance"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;constructor-arg&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"com.hazelcast.config.Config"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"groupConfig"</font><font font-style="bold" color="#0A1777">&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"com.hazelcast.config.GroupConfig"</font><font font-style="bold" color="#0A1777">&gt;</font>
                    <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"name"</font> <font font-style="bold" color="#0A1777">value</font>=<font font-style="bold" color="#008000">"dev"</font><font font-style="bold" color="#0A1777">/&gt;</font>
                    <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"password"</font> <font font-style="bold" color="#0A1777">value</font>=<font font-style="bold" color="#008000">"pwd"</font><font font-style="bold" color="#0A1777">/&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
            <em class="hl-comment" style="color: silver">&lt;!-- and so on ... --&gt;</em>
        <font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/constructor-arg&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>

<font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"map"</font> <font font-style="bold" color="#0A1777">factory-bean</font>=<font font-style="bold" color="#008000">"instance"</font> <font font-style="bold" color="#0A1777">factory-method</font>=<font font-style="bold" color="#008000">"getMap"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;constructor-arg</font> <font font-style="bold" color="#0A1777">value</font>=<font font-style="bold" color="#008000">"map"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>
</pre><p>
    Hazelcast has Spring integration (requires version 2.5 or greater) since 1.9.1
    using
    <span class="emphasis"><em>hazelcast</em></span>
    namespace.
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Add namespace
                <span class="emphasis"><em>xmlns:hz="http://www.hazelcast.com/schema/spring"</em></span>
                to beans
                tag in context file:
                </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;beans</font> <font font-style="bold" color="#0A1777">xmlns</font>=<font font-style="bold" color="#008000">"http://www.springframework.org/schema/beans"</font>
       <font font-style="bold" color="#0A1777">xmlns:xsi</font>=<font font-style="bold" color="#008000">"http://www.w3.org/2001/XMLSchema-instance"</font>
       <font font-style="bold" color="#0A1777">xmlns:hz</font>=<font font-style="bold" color="#008000">"http://www.hazelcast.com/schema/spring"</font>
       <font font-style="bold" color="#0A1777">xsi:schemaLocation</font>=<font font-style="bold" color="#008000">"http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
                http://www.hazelcast.com/schema/spring
                http://www.hazelcast.com/schema/spring/hazelcast-spring-3.0.xsd"</font><font font-style="bold" color="#0A1777">&gt;</font>
</pre><p>
            </p></li><li class="listitem"><p>Use
                <span class="emphasis"><em>hz</em></span>
                namespace shortcuts to declare cluster, its items and
                so on.
            </p></li></ul></div><p>
    After that you can configure Hazelcast instance (node):
    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hz:hazelcast</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"instance"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:config&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:group</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"dev"</font> <font font-style="bold" color="#0A1777">password</font>=<font font-style="bold" color="#008000">"password"</font><font font-style="bold" color="#0A1777">/&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:network</font> <font font-style="bold" color="#0A1777">port</font>=<font font-style="bold" color="#008000">"5701"</font> <font font-style="bold" color="#0A1777">port-auto-increment</font>=<font font-style="bold" color="#008000">"false"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;hz:join&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;hz:multicast</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"false"</font>
                              <font font-style="bold" color="#0A1777">multicast-group</font>=<font font-style="bold" color="#008000">"224.2.2.3"</font>
                              <font font-style="bold" color="#0A1777">multicast-port</font>=<font font-style="bold" color="#008000">"54327"</font><font font-style="bold" color="#0A1777">/&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;hz:tcp-ip</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
                    <font font-style="bold" color="#0A1777">&lt;hz:members&gt;</font>10.10.1.2, 10.10.1.3<font font-style="bold" color="#0A1777">&lt;/hz:members&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;/hz:tcp-ip&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/hz:join&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/hz:network&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"map"</font>
                <font font-style="bold" color="#0A1777">backup-count</font>=<font font-style="bold" color="#008000">"2"</font>
                <font font-style="bold" color="#0A1777">max-size</font>=<font font-style="bold" color="#008000">"0"</font>
                <font font-style="bold" color="#0A1777">eviction-percentage</font>=<font font-style="bold" color="#008000">"30"</font>
                <font font-style="bold" color="#0A1777">read-backup-data</font>=<font font-style="bold" color="#008000">"true"</font>
                <font font-style="bold" color="#0A1777">cache-value</font>=<font font-style="bold" color="#008000">"true"</font>
                <font font-style="bold" color="#0A1777">eviction-policy</font>=<font font-style="bold" color="#008000">"NONE"</font>
                <font font-style="bold" color="#0A1777">merge-policy</font>=<font font-style="bold" color="#008000">"com.hazelcast.map.merge.PassThroughMergePolicy"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/hz:config&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hz:hazelcast&gt;</font>
</pre><p>
    You can easily configure map-store and near-cache too. (For map-store you should set either
    <span class="emphasis"><em>class-name</em></span> or <span class="emphasis"><em>implementation</em></span> attribute.)
    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hz:config&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"map1"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;hz:near-cache</font> <font font-style="bold" color="#0A1777">time-to-live-seconds</font>=<font font-style="bold" color="#008000">"0"</font> <font font-style="bold" color="#0A1777">max-idle-seconds</font>=<font font-style="bold" color="#008000">"60"</font>
               <font font-style="bold" color="#0A1777">eviction-policy</font>=<font font-style="bold" color="#008000">"LRU"</font> <font font-style="bold" color="#0A1777">max-size</font>=<font font-style="bold" color="#008000">"5000"</font>  <font font-style="bold" color="#0A1777">invalidate-on-change</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">/&gt;</font>

            <font font-style="bold" color="#0A1777">&lt;hz:map-store</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font> <font font-style="bold" color="#0A1777">class-name</font>=<font font-style="bold" color="#008000">"com.foo.DummyStore"</font>
                <font font-style="bold" color="#0A1777">write-delay-seconds</font>=<font font-style="bold" color="#008000">"0"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/hz:map&gt;</font>

    <font font-style="bold" color="#0A1777">&lt;hz:map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"map2"</font><font font-style="bold" color="#0A1777">&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;hz:map-store</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font> <font font-style="bold" color="#0A1777">implementation</font>=<font font-style="bold" color="#008000">"dummyMapStore"</font>
                <font font-style="bold" color="#0A1777">write-delay-seconds</font>=<font font-style="bold" color="#008000">"0"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/hz:map&gt;</font>

    <font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"dummyMapStore"</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"com.foo.DummyStore"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hz:config&gt;</font>
</pre><p>
    It's possible to use placeholders instead of concrete values. For instance, use
    property file
    <span class="emphasis"><em>app-default.properties</em></span>
    for group configuration:
    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"locations"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;list&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;value&gt;</font>classpath:/app-default.properties<font font-style="bold" color="#0A1777">&lt;/value&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/list&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>

<font font-style="bold" color="#0A1777">&lt;hz:hazelcast</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"instance"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:config&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:group</font>
            <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"${cluster.group.name}"</font>
            <font font-style="bold" color="#0A1777">password</font>=<font font-style="bold" color="#008000">"${cluster.group.password}"</font><font font-style="bold" color="#0A1777">/&gt;</font>
        <em class="hl-comment" style="color: silver">&lt;!-- ... --&gt;</em>
    <font font-style="bold" color="#0A1777">&lt;/hz:config&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hz:hazelcast&gt;</font>
</pre><p>
    Similar for client
    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hz:client</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"client"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:group</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"${cluster.group.name}"</font> <font font-style="bold" color="#0A1777">password</font>=<font font-style="bold" color="#008000">"${cluster.group.password}"</font><font font-style="bold" color="#0A1777">/&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:network&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;hz:member&gt;</font>10.10.1.2:5701<font font-style="bold" color="#0A1777">&lt;/hz:member&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;hz:member&gt;</font>10.10.1.3:5701<font font-style="bold" color="#0A1777">&lt;/hz:member&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/hz:network&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/hz:client&gt;</font>
</pre><p>
    Hazelcast also supports <code class="code">lazy-init</code>, <code class="code">scope</code> and <code class="code">depends-on</code> bean attributes.
    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hz:hazelcast</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"instance"</font> <font font-style="bold" color="#0A1777">lazy-init</font>=<font font-style="bold" color="#008000">"true"</font> <font font-style="bold" color="#0A1777">scope</font>=<font font-style="bold" color="#008000">"singleton"</font><font font-style="bold" color="#0A1777">&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/hz:hazelcast&gt;</font>

<font font-style="bold" color="#0A1777">&lt;hz:client</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"client"</font> <font font-style="bold" color="#0A1777">scope</font>=<font font-style="bold" color="#008000">"prototype"</font> <font font-style="bold" color="#0A1777">depends-on</font>=<font font-style="bold" color="#008000">"instance"</font><font font-style="bold" color="#0A1777">&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/hz:client&gt;</font>

</pre><p>
    You can declare beans for the following Hazelcast objects:
    </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>map</p></li><li class="listitem"><p>multiMap</p></li><li class="listitem"><p>queue</p></li><li class="listitem"><p>topic</p></li><li class="listitem"><p>set</p></li><li class="listitem"><p>list</p></li><li class="listitem"><p>executorService</p></li><li class="listitem"><p>idGenerator</p></li><li class="listitem"><p>atomicLong</p></li><li class="listitem"><p>semaphore</p></li><li class="listitem"><p>countDownLatch</p></li><li class="listitem"><p>lock</p></li></ul></div><p>
    Example:
    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;hz:map</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"map"</font> <font font-style="bold" color="#0A1777">instance-ref</font>=<font font-style="bold" color="#008000">"client"</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"map"</font> <font font-style="bold" color="#0A1777">lazy-init</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
<font font-style="bold" color="#0A1777">&lt;hz:multiMap</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"multiMap"</font> <font font-style="bold" color="#0A1777">instance-ref</font>=<font font-style="bold" color="#008000">"instance"</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"multiMap"</font> <font font-style="bold" color="#0A1777">lazy-init</font>=<font font-style="bold" color="#008000">"false"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
<font font-style="bold" color="#0A1777">&lt;hz:queue</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"queue"</font> <font font-style="bold" color="#0A1777">instance-ref</font>=<font font-style="bold" color="#008000">"client"</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"queue"</font> <font font-style="bold" color="#0A1777">lazy-init</font>=<font font-style="bold" color="#008000">"true"</font> <font font-style="bold" color="#0A1777">depends-on</font>=<font font-style="bold" color="#008000">"instance"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;hz:topic</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"topic"</font> <font font-style="bold" color="#0A1777">instance-ref</font>=<font font-style="bold" color="#008000">"instance"</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"topic"</font> <font font-style="bold" color="#0A1777">depends-on</font>=<font font-style="bold" color="#008000">"instance, client"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;hz:set</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"set"</font> <font font-style="bold" color="#0A1777">instance-ref</font>=<font font-style="bold" color="#008000">"instance"</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"set"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
<font font-style="bold" color="#0A1777">&lt;hz:list</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"list"</font> <font font-style="bold" color="#0A1777">instance-ref</font>=<font font-style="bold" color="#008000">"instance"</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"list"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;hz:executorService</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"executorService"</font> <font font-style="bold" color="#0A1777">instance-ref</font>=<font font-style="bold" color="#008000">"client"</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"executorService"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;hz:idGenerator</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"idGenerator"</font> <font font-style="bold" color="#0A1777">instance-ref</font>=<font font-style="bold" color="#008000">"instance"</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"idGenerator"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;hz:atomicLong</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"atomicLong"</font> <font font-style="bold" color="#0A1777">instance-ref</font>=<font font-style="bold" color="#008000">"instance"</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"atomicLong"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;hz:semaphore</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"semaphore"</font> <font font-style="bold" color="#0A1777">instance-ref</font>=<font font-style="bold" color="#008000">"instance"</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"semaphore"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;hz:countDownLatch</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"countDownLatch"</font> <font font-style="bold" color="#0A1777">instance-ref</font>=<font font-style="bold" color="#008000">"instance"</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"countDownLatch"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;hz:lock</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"lock"</font> <font font-style="bold" color="#0A1777">instance-ref</font>=<font font-style="bold" color="#008000">"instance"</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"lock"</font><font font-style="bold" color="#0A1777">/&gt;</font>
</pre><p>
    </p><a name="SpringInjectingTypedBean"></a><p><a class="link" href="#SpringInjectingTypedBean">
        <span class="bold"><strong>Injecting Typed Collections/Maps</strong></span></a></p><p>
        Spring tries to create a new <code class="code">Map</code>/<code class="code">Collection</code> instance and fill the new instance
        by iterating and converting values of the original <code class="code">Map</code>/<code class="code">Collection</code>
        (<code class="literal">IMap</code>, <code class="literal">IQueue</code> etc.) to required types when generic type parameters
        of the original <code class="code">Map</code>/<code class="code">Collection</code> and the target property/attribute do not match.
    </p><p>
        Since Hazelcast <code class="code">Map</code>s/<code class="code">Collection</code>s are designed to hold very large data
        which a single machine can not carry, iterating through whole values can cause out of memory errors.
    </p><p>
        To avoid this issue either target property/attribute can be declared as
        un-typed <code class="code">Map</code>/<code class="code">Collection</code>
        </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> SomeBean {
    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    IMap map; <em class="hl-comment" style="color: silver">// instead of IMap&lt;K, V&gt; map</em>

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    IQueue queue; <em class="hl-comment" style="color: silver">// instead of IQueue&lt;E&gt; queue</em>

    ...
}
</pre><p>

        or parameters of injection methods (constructor, setter) can be un-typed.

        </p><pre class="programlisting">
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> SomeBean {

    IMap&lt;K, V&gt; map;

    IQueue&lt;E&gt; queue;

    <strong class="hl-keyword">public</strong> SomeBean(IMap map) { <em class="hl-comment" style="color: silver">// instead of IMap&lt;K, V&gt; map</em>
        <strong class="hl-keyword">this</strong>.map = map;
    }

    ...

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> setQueue(IQueue queue) { <em class="hl-comment" style="color: silver">// instead of IQueue&lt;E&gt; queue</em>
        <strong class="hl-keyword">this</strong>.queue = queue;
    }
    ...
}
</pre><p>
        <span class="italic">For more info see
            <a class="link" href="https://jira.springsource.org/browse/SPR-3407" target="_top">
                Spring issue-3407
            </a>.</span>
    </p></div><div class="sect1" title="16.2.&nbsp;Spring Managed Context"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SpringContext"></a>16.2.&nbsp;Spring Managed Context</h2></div></div></div><p>
        It's often desired to access Spring managed beans, to apply bean properties or to apply factory callbacks
        such as <code class="code">ApplicationContextAware</code>, <code class="code">BeanNameAware</code> or to apply bean post-processing
        such as <code class="code">InitializingBean</code>, <code class="code">@PostConstruct</code> like annotations
        while using Hazelcast distributed <code class="code">ExecutorService</code> or more
        generally any Hazelcast managed object. Achieving those features are as simple as adding <code class="code">@SpringAware</code>
        annotation to your distributed object types. Once you have configured HazelcastInstance as explained in
        Spring configuration,
        just mark any distributed type with <code class="code">@SpringAware</code> annotation.

        </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;beans</font> <font font-style="bold" color="#0A1777">xmlns</font>=<font font-style="bold" color="#008000">"http://www.springframework.org/schema/beans"</font>
       <font font-style="bold" color="#0A1777">xmlns:xsi</font>=<font font-style="bold" color="#008000">"http://www.w3.org/2001/XMLSchema-instance"</font>
       <font font-style="bold" color="#0A1777">xmlns:context</font>=<font font-style="bold" color="#008000">"http://www.springframework.org/schema/context"</font>
       <font font-style="bold" color="#0A1777">xmlns:hz</font>=<font font-style="bold" color="#008000">"http://www.hazelcast.com/schema/spring"</font>
       <font font-style="bold" color="#0A1777">xsi:schemaLocation</font>=<font font-style="bold" color="#008000">"http://www.springframework.org/schema/beans
                http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
		        http://www.springframework.org/schema/context
                http://www.springframework.org/schema/context/spring-context-3.0.xsd
                http://www.hazelcast.com/schema/spring
                http://www.hazelcast.com/schema/spring/hazelcast-spring-3.0.xsd"</font><font font-style="bold" color="#0A1777">&gt;</font>

    <font font-style="bold" color="#0A1777">&lt;context:annotation-config /&gt;</font>

    <font font-style="bold" color="#0A1777">&lt;hz:hazelcast</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"instance"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;hz:config&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;hz:group</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"dev"</font> <font font-style="bold" color="#0A1777">password</font>=<font font-style="bold" color="#008000">"password"</font><font font-style="bold" color="#0A1777">/&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;hz:network</font> <font font-style="bold" color="#0A1777">port</font>=<font font-style="bold" color="#008000">"5701"</font> <font font-style="bold" color="#0A1777">port-auto-increment</font>=<font font-style="bold" color="#008000">"false"</font><font font-style="bold" color="#0A1777">&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;hz:join&gt;</font>
                    <font font-style="bold" color="#0A1777">&lt;hz:multicast</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"false"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
                    <font font-style="bold" color="#0A1777">&lt;hz:tcp-ip</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>
                        <font font-style="bold" color="#0A1777">&lt;hz:members&gt;</font>10.10.1.2, 10.10.1.3<font font-style="bold" color="#0A1777">&lt;/hz:members&gt;</font>
                    <font font-style="bold" color="#0A1777">&lt;/hz:tcp-ip&gt;</font>
                <font font-style="bold" color="#0A1777">&lt;/hz:join&gt;</font>
            <font font-style="bold" color="#0A1777">&lt;/hz:network&gt;</font>
            ...
        <font font-style="bold" color="#0A1777">&lt;/hz:config&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/hz:hazelcast&gt;</font>

    <font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"someBean"</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"com.hazelcast.examples.spring.SomeBean"</font> <font font-style="bold" color="#0A1777">scope</font>=<font font-style="bold" color="#008000">"singleton"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/beans&gt;</font>
</pre><p>

    <span class="bold"><strong>ExecutorService example:</strong></span>

    </p><pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@SpringAware</span></em>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> SomeTask <strong class="hl-keyword">implements</strong> Callable&lt;Long&gt;, ApplicationContextAware, Serializable {

    <strong class="hl-keyword">private</strong> <strong class="hl-keyword">transient</strong> ApplicationContext context;

    <strong class="hl-keyword">private</strong> <strong class="hl-keyword">transient</strong> SomeBean someBean;

    <strong class="hl-keyword">public</strong> Long call() <strong class="hl-keyword">throws</strong> Exception {
        <strong class="hl-keyword">return</strong> someBean.value;
    }

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> setApplicationContext(<strong class="hl-keyword">final</strong> ApplicationContext applicationContext)
        <strong class="hl-keyword">throws</strong> BeansException {
        context = applicationContext;
    }

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> setSomeBean(<strong class="hl-keyword">final</strong> SomeBean someBean) {
        <strong class="hl-keyword">this</strong>.someBean = someBean;
    }
}
</pre><p>

   </p><pre class="programlisting">
HazelcastInstance hazelcast = (HazelcastInstance) context.getBean(<font font-style="normal" color="#008000">"hazelcast"</font>);
SomeBean bean = (SomeBean) context.getBean(<font font-style="normal" color="#008000">"someBean"</font>);

Future&lt;Long&gt; f = hazelcast.getExecutorService().submit(<strong class="hl-keyword">new</strong> SomeTask());
Assert.assertEquals(bean.value, f.get().longValue());

<em class="hl-comment" style="color: silver">// choose a member</em>
Member member = hazelcast.getCluster().getMembers().iterator().next();

Future&lt;Long&gt; f2 = (Future&lt;Long&gt;) hazelcast.getExecutorService()
    .submitToMember(<strong class="hl-keyword">new</strong> SomeTask(), member);
Assert.assertEquals(bean.value, f2.get().longValue());

</pre><p>


    <span class="bold"><strong>Distributed Map value example:</strong></span>

    </p><pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@SpringAware</span></em>
<em><span class="hl-annotation" style="color: gray">@Component("someValue")</span></em>
<em><span class="hl-annotation" style="color: gray">@Scope("prototype")</span></em>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">class</strong> SomeValue <strong class="hl-keyword">implements</strong> Serializable, ApplicationContextAware {

    <strong class="hl-keyword">transient</strong> ApplicationContext context;

    <strong class="hl-keyword">transient</strong> SomeBean someBean;

    <strong class="hl-keyword">transient</strong> <strong class="hl-keyword">boolean</strong> init = false;

    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> setApplicationContext(<strong class="hl-keyword">final</strong> ApplicationContext applicationContext)
        <strong class="hl-keyword">throws</strong> BeansException {
        context = applicationContext;
    }

    <em><span class="hl-annotation" style="color: gray">@Autowired</span></em>
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> setSomeBean(<strong class="hl-keyword">final</strong> SomeBean someBean) {
        <strong class="hl-keyword">this</strong>.someBean = someBean;
    }

    <em><span class="hl-annotation" style="color: gray">@PostConstruct</span></em>
    <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> init() {
        someBean.doSomethingUseful();
        init = true;
    }
    ...
}
</pre><p>

   On Node-1;
</p><pre class="programlisting">
HazelcastInstance hazelcast = (HazelcastInstance) context.getBean(<font font-style="normal" color="#008000">"hazelcast"</font>);
SomeValue value = (SomeValue) context.getBean(<font font-style="normal" color="#008000">"someValue"</font>)
IMap&lt;String, SomeValue&gt; map = hazelcast.getMap(<font font-style="normal" color="#008000">"values"</font>);
map.put(<font font-style="normal" color="#008000">"key"</font>, value);
</pre><p>

    On Node-2;
    </p><pre class="programlisting">
HazelcastInstance hazelcast = (HazelcastInstance) context.getBean(<font font-style="normal" color="#008000">"hazelcast"</font>);
IMap&lt;String, SomeValue&gt; map = hazelcast.getMap(<font font-style="normal" color="#008000">"values"</font>);
SomeValue value = map.get(<font font-style="normal" color="#008000">"key"</font>);
Assert.assertTrue(value.init);
</pre><p>
        <span class="italic">Note that, Spring managed properties/fields are marked as <code class="code">transient</code>.</span>
    </p></div><div class="sect1" title="16.3.&nbsp;Spring Cache"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SpringCache"></a>16.3.&nbsp;Spring Cache</h2></div></div></div><p>
        As of version 3.1, Spring Framework provides support for adding caching into an existing Spring application.
        To use Hazelcast as Spring cache provider, you should just define a <code class="code">com.hazelcast.spring.cache.HazelcastCacheManager</code>
        bean and register it as Spring cache manager.

    </p><pre class="programlisting"><font font-style="bold" color="#0A1777">&lt;cache:annotation-driven</font> <font font-style="bold" color="#0A1777">cache-manager</font>=<font font-style="bold" color="#008000">"cacheManager"</font><font font-style="bold" color="#0A1777"> /&gt;</font>

<font font-style="bold" color="#0A1777">&lt;hz:hazelcast</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"hazelcast"</font><font font-style="bold" color="#0A1777">&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/hz:hazelcast&gt;</font>

<font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"cacheManager"</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"com.hazelcast.spring.cache.HazelcastCacheManager"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;constructor-arg</font> <font font-style="bold" color="#0A1777">ref</font>=<font font-style="bold" color="#008000">"instance"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>
</pre><p>
    <span class="italic">For more info see
        <a class="link" href="http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/html/cache.html" target="_top">
            Spring Cache Abstraction
        </a>.</span>
    </p></div><div class="sect1" title="16.4.&nbsp;Hibernate 2nd Level Cache Config"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SpringHibernate"></a>16.4.&nbsp;Hibernate 2nd Level Cache Config</h2></div></div></div><p>
    If you are using Hibernate with Hazelcast as 2nd level cache provider, you
    can easily create <code class="code">RegionFactory</code> instances within
    Spring configuration (by Spring version 3.1). That way it is possible to use same
    <code class="code">HazelcastInstance</code> as Hibernate L2 cache instance.

    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hz:hibernate-region-factory</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"regionFactory"</font> <font font-style="bold" color="#0A1777">instance-ref</font>=<font font-style="bold" color="#008000">"instance"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
...
<font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"sessionFactory"</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"org.springframework.orm.hibernate3.LocalSessionFactoryBean"</font> <font font-style="bold" color="#0A1777">scope</font>=<font font-style="bold" color="#008000">"singleton"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"dataSource"</font> <font font-style="bold" color="#0A1777">ref</font>=<font font-style="bold" color="#008000">"dataSource"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"cacheRegionFactory"</font> <font font-style="bold" color="#0A1777">ref</font>=<font font-style="bold" color="#008000">"regionFactory"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
    ...
<font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>
</pre><p>
        </p></div><div class="sect1" title="16.5.&nbsp;Spring Data - JPA"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SpringJPA"></a>16.5.&nbsp;Spring Data - JPA</h2></div></div></div><p>
        Hazelcast supports JPA persistence integrated with <a class="link" href="http://www.springsource.org/spring-data/jpa" target="_top">
        Spring Data-JPA</a> module.
        Your POJOs are mapped and persisted to your relational database.
        To use JPA persistence first you should create a Repository interface extending CrudRepository class with object type that you want to persist..
        </p><pre class="programlisting">
<strong class="hl-keyword">package</strong> com.hazelcast.jpa.repository;

<strong class="hl-keyword">import</strong> com.hazelcast.jpa.Product;
<strong class="hl-keyword">import</strong> org.springframework.data.repository.CrudRepository;

<strong class="hl-keyword">public</strong> <strong class="hl-keyword">interface</strong> ProductRepository <strong class="hl-keyword">extends</strong> CrudRepository&lt;Product, Long&gt; {

}
</pre><p>
        Then you should add your data source and repository definition to you Spring configuration,
        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;jpa:repositories</font>
       <font font-style="bold" color="#0A1777">base-package</font>=<font font-style="bold" color="#008000">"com.hazelcast.jpa.repository"</font><font font-style="bold" color="#0A1777"> /&gt;</font>

    <font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"com.hazelcast.jpa.SpringJPAMapStore"</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"jpamapstore"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"crudRepository"</font> <font font-style="bold" color="#0A1777">ref</font>=<font font-style="bold" color="#008000">"productRepository"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>

    <font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"org.apache.commons.dbcp.BasicDataSource"</font> <font font-style="bold" color="#0A1777">destroy-method</font>=<font font-style="bold" color="#008000">"close"</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"dataSource"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"driverClassName"</font> <font font-style="bold" color="#0A1777">value</font>=<font font-style="bold" color="#008000">"com.mysql.jdbc.Driver"</font><font font-style="bold" color="#0A1777">/&gt;</font>
             <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"url"</font> <font font-style="bold" color="#0A1777">value</font>=<font font-style="bold" color="#008000">"jdbc:mysql://localhost:3306/YOUR_DB"</font><font font-style="bold" color="#0A1777">/&gt;</font>
             <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"username"</font> <font font-style="bold" color="#0A1777">value</font>=<font font-style="bold" color="#008000">"YOUR_USERNAME"</font><font font-style="bold" color="#0A1777">/&gt;</font>
             <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"password"</font> <font font-style="bold" color="#0A1777">value</font>=<font font-style="bold" color="#008000">"YOUR_PASSWORD"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>

    <font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"entityManagerFactory"</font>
      <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean"</font><font font-style="bold" color="#0A1777">&gt;</font>
      <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"dataSource"</font> <font font-style="bold" color="#0A1777">ref</font>=<font font-style="bold" color="#008000">"dataSource"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
      <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"jpaVendorAdapter"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"org.springframework.orm.jpa.vendor.HibernateJpaVendorAdapter"</font><font font-style="bold" color="#0A1777">&gt;</font>
          <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"generateDdl"</font> <font font-style="bold" color="#0A1777">value</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
          <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"database"</font> <font font-style="bold" color="#0A1777">value</font>=<font font-style="bold" color="#008000">"MYSQL"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>
      <font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"persistenceUnitName"</font> <font font-style="bold" color="#0A1777">value</font>=<font font-style="bold" color="#008000">"jpa.sample"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>

    <font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"org.springframework.orm.jpa.JpaTransactionManager"</font>
      <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"transactionManager"</font><font font-style="bold" color="#0A1777">&gt;</font>
      <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"entityManagerFactory"</font>
          <font font-style="bold" color="#0A1777">ref</font>=<font font-style="bold" color="#008000">"entityManagerFactory"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
      <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"jpaDialect"</font><font font-style="bold" color="#0A1777">&gt;</font>
        <font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"org.springframework.orm.jpa.vendor.HibernateJpaDialect"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
      <font font-style="bold" color="#0A1777">&lt;/property&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>
    </pre><p>
    In the example configuration above, Hibernate and MYSQL is configured,
        you change them according your ORM and database selection.
        Also you should define your persistence unit with persistence.xml under META-INF directory.

        </p><pre class="programlisting">
<span class="hl-directive" style="color: maroon">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>
<font font-style="bold" color="#0A1777">&lt;persistence</font> <font font-style="bold" color="#0A1777">version</font>=<font font-style="bold" color="#008000">"2.0"</font> <font font-style="bold" color="#0A1777">xmlns</font>=<font font-style="bold" color="#008000">"http://java.sun.com/xml/ns/persistence"</font> <font font-style="bold" color="#0A1777">xmlns:xsi</font>=<font font-style="bold" color="#008000">"http://www.w3.org/2001/XMLSchema-instance"</font> <font font-style="bold" color="#0A1777">xsi:schemaLocation</font>=<font font-style="bold" color="#008000">"http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd"</font><font font-style="bold" color="#0A1777">&gt;</font>
	<font font-style="bold" color="#0A1777">&lt;persistence-unit</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"jpa.sample"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/persistence&gt;</font>
</pre><p>

        By default, the key is expected to be the same with id of the JPA object. You can change this behaviour and customize MapStore implementation extending SpringJPAMapStore class.

    <span class="italic">For more info see
        <a class="link" href="http://static.springsource.org/spring-data/data-jpa/docs/current/reference/html/" target="_top">
            Spring Data JPA Reference
        </a>.</span>
    </p></div><div class="sect1" title="16.6.&nbsp;Spring Data - MongoDB"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="SpringMongoDB"></a>16.6.&nbsp;Spring Data - MongoDB</h2></div></div></div><p>
        With version 2.1, Hazelcast will support MongoDB persistence integrated with <a class="link" href="http://www.springsource.org/spring-data/mongodb" target="_top">
        Spring Data-MongoDB</a> module.
        Spring MongoDB module maps your objects to equivalent MongoDB objects.
        To persist your objects into MongoDB you should define MongoDB mapstore in your Spring configuration as follows:
        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;mongo:mongo</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"mongo"</font> <font font-style="bold" color="#0A1777">host</font>=<font font-style="bold" color="#008000">"localhost"</font> <font font-style="bold" color="#0A1777">port</font>=<font font-style="bold" color="#008000">"27017"</font><font font-style="bold" color="#0A1777">/&gt;</font>

<font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"mongoTemplate"</font>
      <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"org.springframework.data.mongodb.core.MongoTemplate"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;constructor-arg</font> <font font-style="bold" color="#0A1777">ref</font>=<font font-style="bold" color="#008000">"mongo"</font><font font-style="bold" color="#0A1777">/&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;constructor-arg</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"databaseName"</font> <font font-style="bold" color="#0A1777">value</font>=<font font-style="bold" color="#008000">"test"</font><font font-style="bold" color="#0A1777">/&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>

<font font-style="bold" color="#0A1777">&lt;bean</font> <font font-style="bold" color="#0A1777">class</font>=<font font-style="bold" color="#008000">"com.hazelcast.spring.mongodb.MongoMapStore"</font> <font font-style="bold" color="#0A1777">id</font>=<font font-style="bold" color="#008000">"mongomapstore"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;property</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"mongoTemplate"</font> <font font-style="bold" color="#0A1777">ref</font>=<font font-style="bold" color="#008000">"mongoTemplate"</font><font font-style="bold" color="#0A1777"> /&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/bean&gt;</font>
</pre><p>
        Then you can set this as mapstore for maps that you want to persist into MongoDB.
        </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;hz:map</font> <font font-style="bold" color="#0A1777">name</font>=<font font-style="bold" color="#008000">"user"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;hz:map-store</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font> <font font-style="bold" color="#0A1777">implementation</font>=<font font-style="bold" color="#008000">"mongomapstore"</font>
                  <font font-style="bold" color="#0A1777">write-delay-seconds</font>=<font font-style="bold" color="#008000">"0"</font><font font-style="bold" color="#0A1777">&gt;</font>
    <font font-style="bold" color="#0A1777">&lt;/hz:map-store&gt;</font>
<font font-style="bold" color="#0A1777">&lt;/hz:map&gt;</font>
</pre><p>
        By default, the key is set as id of the MongoDB object. You can override MongoMapStore class for you custom needs.

    <span class="italic">For more info see
        <a class="link" href="http://static.springsource.org/spring-data/data-mongodb/docs/current/reference/html/" target="_top">
            Spring Data MongoDB Reference
        </a>.</span>
    </p></div></div><div class="chapter" title="Chapter&nbsp;17.&nbsp;Clients"><div class="titlepage"><div><div><h2 class="title"><a name="Clients"></a>Chapter&nbsp;17.&nbsp;Clients</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#NativeClient">17.1. Native Client</a></span></dt><dd><dl><dt><span class="sect2"><a href="#JavaClient">17.1.1. Java Client</a></span></dt><dt><span class="sect2"><a href="#CSharpClient">17.1.2. CSharp Client <sup>(Enterprise Edition Only)</sup></a></span></dt></dl></dd><dt><span class="sect1"><a href="#MemcacheClient">17.2. Memcache Client</a></span></dt><dt><span class="sect1"><a href="#RestClient">17.3. Rest Client</a></span></dt></dl></div><p>

    There are currently three ways to connect to a running Hazelcast cluster:
    </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                <a class="link" href="#NativeClient" title="17.1.&nbsp;Native Client">Native Clients</a>
            </p></li><li class="listitem"><p>
                <a class="link" href="#MemcacheClient" title="17.2.&nbsp;Memcache Client">Memcache Clients</a>
            </p></li><li class="listitem"><p>
                <a class="link" href="#RestClient" title="17.3.&nbsp;Rest Client">REST Client</a>
            </p></li></ol></div><p>
</p><div class="sect1" title="17.1.&nbsp;Native Client"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="NativeClient"></a>17.1.&nbsp;Native Client</h2></div></div></div><p>Native Client enables you to do almost all Hazelcast operations without being a member of the
        cluster. It connects to one of the cluster members and delegates all cluster wide operations
        to it or connects to all of them and delegate operations smartly. When the relied cluster member dies, client will transparently switch to another live
        member.
    </p><p>There can be hundreds, even thousands of clients connected to the cluster. But by default there is 40 threads
    on server side that will handle all the requests. You may want to increase hazelcast.executor.client.thread.count
    property for better performance. </p><p>Imagine a trading application where all the trading data stored and managed in a 10 node
        Hazelcast cluster. Swing/Web applications at traders' desktops can use Native Java Client to
        access and modify the data in the Hazelcast cluster.
    </p><p>Currently Hazelcast has Native Java and C# Client available.
        C# Client implementation has not yet finished as of version 3.
    </p><div class="sect2" title="17.1.1.&nbsp;Java Client"><div class="titlepage"><div><div><h3 class="title"><a name="JavaClient"></a>17.1.1.&nbsp;Java Client</h3></div></div></div><p>You can do almost all hazelcast operations with Java Client. It already implements the
            same interface. You must include hazelcast-client.jar into your classpath.
            </p><pre class="programlisting"><strong class="hl-keyword">import</strong> com.hazelcast.core.HazelcastInstance;
<strong class="hl-keyword">import</strong> com.hazelcast.client.HazelcastClient;

<strong class="hl-keyword">import</strong> java.util.Map;
<strong class="hl-keyword">import</strong> java.util.Collection;


ClientConfig clientConfig = <strong class="hl-keyword">new</strong> ClientConfig();
clientConfig.getGroupConfig().setName(<font font-style="normal" color="#008000">"dev"</font>).setPassword(<font font-style="normal" color="#008000">"dev-pass"</font>);
clientConfig.addAddress(<font font-style="normal" color="#008000">"10.90.0.1"</font>, <font font-style="normal" color="#008000">"10.90.0.2:5702"</font>);

HazelcastInstance client = HazelcastClient.newHazelcastClient(clientConfig);
<em class="hl-comment" style="color: silver">//All cluster operations that you can do with ordinary HazelcastInstance</em>
Map&lt;String, Customer&gt; mapCustomers = client.getMap(<font font-style="normal" color="#008000">"customers"</font>);
mapCustomers.put(<font font-style="normal" color="#008000">"1"</font>, <strong class="hl-keyword">new</strong> Customer(<font font-style="normal" color="#008000">"Joe"</font>, <font font-style="normal" color="#008000">"Smith"</font>));
mapCustomers.put(<font font-style="normal" color="#008000">"2"</font>, <strong class="hl-keyword">new</strong> Customer(<font font-style="normal" color="#008000">"Ali"</font>, <font font-style="normal" color="#008000">"Selam"</font>));
mapCustomers.put(<font font-style="normal" color="#008000">"3"</font>, <strong class="hl-keyword">new</strong> Customer(<font font-style="normal" color="#008000">"Avi"</font>, <font font-style="normal" color="#008000">"Noyan"</font>));

Collection&lt;Customer&gt; colCustomers = mapCustomers.values();
<strong class="hl-keyword">for</strong> (Customer customer : colCustomers) {
     <em class="hl-comment" style="color: silver">// process customer</em>
}
</pre><p>
        </p></div><div class="sect2" title="17.1.2.&nbsp;CSharp Client (Enterprise Edition Only)"><div class="titlepage"><div><div><h3 class="title"><a name="CSharpClient"></a>17.1.2.&nbsp;CSharp Client <sup>(Enterprise Edition Only)</sup></h3></div></div></div><p>Not yet implemented as of version 3</p></div></div><div class="sect1" title="17.2.&nbsp;Memcache Client"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MemcacheClient"></a>17.2.&nbsp;Memcache Client</h2></div></div></div><p>A Memcache client written in any language can talk directly to Hazelcast cluster. No
        additional configuration is required. Here is an example: Let's say your cluster's members
        are:</p><pre class="programlisting">Members [<span class="hl-number">5</span>] {
    Member [<span class="hl-number">10.20</span>.<span class="hl-number">17.1</span>:<span class="hl-number">5701</span>]
    Member [<span class="hl-number">10.20</span>.<span class="hl-number">17.2</span>:<span class="hl-number">5701</span>]
    Member [<span class="hl-number">10.20</span>.<span class="hl-number">17.4</span>:<span class="hl-number">5701</span>]
    Member [<span class="hl-number">10.20</span>.<span class="hl-number">17.3</span>:<span class="hl-number">5701</span>]
    Member [<span class="hl-number">10.20</span>.<span class="hl-number">17.5</span>:<span class="hl-number">5701</span>]
 }
</pre><p>And you have a PHP application that uses PHP Memcache client to cache things in
        Hazelcast. All you need to do is have your PHP memcache client connect to one of these
        members. It doesn't matter which member the client connects to because Hazelcast cluster
        looks as one giant machine (Single System Image). PHP client code sample:
</p><pre class="programlisting">&lt;?php
    $memcache = <strong class="hl-keyword">new</strong> Memcache;
    $memcache-&gt;connect(<font font-style="normal" color="#008000">'10.20.17.1'</font>, <span class="hl-number">5701</span>) or die (<font font-style="normal" color="#008000">"Could not connect"</font>);
    $memcache-&gt;set(<font font-style="normal" color="#008000">'key1'</font>,<font font-style="normal" color="#008000">'value1'</font>,<span class="hl-number">0</span>,<span class="hl-number">3600</span>);
    $get_result = $memcache-&gt;get(<font font-style="normal" color="#008000">'key1'</font>); <em class="hl-comment" style="color: silver">//retrieve your data</em>
    var_dump($get_result); <em class="hl-comment" style="color: silver">//show it</em>
?&gt;
</pre><p>Notice that memcache client is connecting to
        <code class="literal">10.20.17.1</code>
        and
        using port<code class="literal">5701</code>. Java client code sample with SpyMemcached client:
    </p><pre class="programlisting">
MemcachedClient client = <strong class="hl-keyword">new</strong> MemcachedClient(AddrUtil.getAddresses(<font font-style="normal" color="#008000">"10.20.17.1:5701 10.20.17.2:5701"</font>));
client.set(<font font-style="normal" color="#008000">"key1"</font>, <span class="hl-number">3600</span>, <font font-style="normal" color="#008000">"value1"</font>);
System.out.println(client.get(<font font-style="normal" color="#008000">"key1"</font>));
</pre><p>If you want your data to be stored in different maps(e.g to utilize per map configuration ), you can do that with a map name prefix as following:
</p><pre class="programlisting">
MemcachedClient client = <strong class="hl-keyword">new</strong> MemcachedClient(AddrUtil.getAddresses(<font font-style="normal" color="#008000">"10.20.17.1:5701 10.20.17.2:5701"</font>));
client.set(<font font-style="normal" color="#008000">"map1:key1"</font>, <span class="hl-number">3600</span>, <font font-style="normal" color="#008000">"value1"</font>); <em class="hl-comment" style="color: silver">// store to *hz_memcache_map1</em>
client.set(<font font-style="normal" color="#008000">"map2:key1"</font>, <span class="hl-number">3600</span>, <font font-style="normal" color="#008000">"value1"</font>); <em class="hl-comment" style="color: silver">// store to hz_memcache_map2</em>
System.out.println(client.get(<font font-style="normal" color="#008000">"key1"</font>)); <em class="hl-comment" style="color: silver">//get from hz_memcache_map1</em>
System.out.println(client.get(<font font-style="normal" color="#008000">"key2"</font>)); <em class="hl-comment" style="color: silver">//get from hz_memcache_map2</em>
</pre><p>
        hz_memcache prefix is to separate memcache maps from hazelcast maps.
     </p><p>
        An entry written with a memcache client can be read by another memcache client
        written in another language.
    </p></div><div class="sect1" title="17.3.&nbsp;Rest Client"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="RestClient"></a>17.3.&nbsp;Rest Client</h2></div></div></div><p>Let's say your cluster's members are:</p><pre class="programlisting">Members [<span class="hl-number">5</span>] {
    Member [<span class="hl-number">10.20</span>.<span class="hl-number">17.1</span>:<span class="hl-number">5701</span>]
    Member [<span class="hl-number">10.20</span>.<span class="hl-number">17.2</span>:<span class="hl-number">5701</span>]
    Member [<span class="hl-number">10.20</span>.<span class="hl-number">17.4</span>:<span class="hl-number">5701</span>]
    Member [<span class="hl-number">10.20</span>.<span class="hl-number">17.3</span>:<span class="hl-number">5701</span>]
    Member [<span class="hl-number">10.20</span>.<span class="hl-number">17.5</span>:<span class="hl-number">5701</span>]
 }
</pre><p>And you have a distributed map named 'stocks'. You can put a new
        <code class="literal">key1/value1</code>
        entry into this map by issuing
        <code class="literal">HTTP
            POST
        </code>
        call to
        <code class="literal">http://10.20.17.1:5701/hazelcast/rest/maps/stocks/key1</code>
        URL. Your http post call's content body should contain the value (value1). You can
        retrieve this entry via
        <code class="literal">HTTP GET</code>
        call to
        <code class="literal">http://10.20.17.1:5701/hazelcast/rest/maps/stocks/key1</code>. You can also retrieve this
        entry from another member such
        as <code class="literal">http://10.20.17.3:5701/hazelcast/rest/maps/stocks/key1</code>.
    </p><p>RESTful access is provided through any member of your cluster. So you can even put an
        HTTP load-balancer in-front of your cluster members for load-balancing and
        fault-tolerance.
    </p><p>Now go ahead and install a REST plugin for your browser and explore further.</p><p>Hazelcast also stores the mime-type of your
        <code class="literal">POST</code>
        request if it
        contains any. So if, for example, you post binary of an image file and set the
        mime-type of the
        <code class="literal">HTTP POST</code>
        request to
        <code class="literal">image/jpeg</code>
        then this mime-type will be part of the
        response of your
        <code class="literal">HTTP GET</code>
        request for that entry.
    </p><p>Let's say you also have a task queue named 'tasks'. You can offer a new item into the
        queue via HTTP POST and take and item from the queue via HTTP DELETE.
    </p><p>
        <code class="code">HTTP POST http://10.20.17.1:5701/hazelcast/rest/queues/tasks &lt;CONTENT&gt;</code>
        means
        </p><pre class="programlisting">Hazelcast.getQueue(<font font-style="normal" color="#008000">"tasks"</font>).offer(&lt;CONTENT&gt;);
</pre><p>
        and
        <code class="code">HTTP DELETE http://10.20.17.1:5701/hazelcast/rest/queues/tasks/3</code>
        means
        </p><pre class="programlisting">Hazelcast.getQueue(<font font-style="normal" color="#008000">"tasks"</font>).poll(<span class="hl-number">3</span>, SECONDS);
</pre><p>
        Note that you will have to handle the failures on REST polls as there is no
        transactional guarantee.
    </p></div></div><div class="chapter" title="Chapter&nbsp;18.&nbsp;Management Center"><div class="titlepage"><div><div><h2 class="title"><a name="ManagementCenter"></a>Chapter&nbsp;18.&nbsp;Management Center</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#MC_Intro">18.1. Introduction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#MC_Installation">18.1.1. Installation</a></span></dt><dt><span class="sect2"><a href="#MC_UserAdministration">18.1.2. User Administration</a></span></dt><dt><span class="sect2"><a href="#MC_ToolOverview">18.1.3. Tool Overview</a></span></dt></dl></dd><dt><span class="sect1"><a href="#MC_Maps">18.2. Maps</a></span></dt><dd><dl><dt><span class="sect2"><a href="#MC_MapMonitoring">18.2.1. Monitoring Maps</a></span></dt><dt><span class="sect2"><a href="#MC_MapBrowser">18.2.2. Map Browser</a></span></dt><dt><span class="sect2"><a href="#MC_MapConfiguration">18.2.3. Map Configuration</a></span></dt></dl></dd><dt><span class="sect1"><a href="#MC_Queues">18.3. Queues</a></span></dt><dt><span class="sect1"><a href="#MC_Topics">18.4. Topics</a></span></dt><dt><span class="sect1"><a href="#MC_Members">18.5. Members</a></span></dt><dd><dl><dt><span class="sect2"><a href="#MC_MemberMonitoring">18.5.1. Monitoring</a></span></dt><dt><span class="sect2"><a href="#MC_MemberOperations">18.5.2. Operations</a></span></dt></dl></dd><dt><span class="sect1"><a href="#MC_Logs">18.6. System Logs</a></span></dt><dt><span class="sect1"><a href="#MC_Scripting">18.7. Scripting</a></span></dt><dt><span class="sect1"><a href="#MC_TimeTravel">18.8. Time Travel</a></span></dt><dt><span class="sect1"><a href="#MC_Console">18.9. Console</a></span></dt></dl></div><div class="sect1" title="18.1.&nbsp;Introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MC_Intro"></a>18.1.&nbsp;Introduction</h2></div></div></div><p>
        Hazelcast Management Center enables you to monitor and manage your servers running hazelcast.
        With Management Center, in addition to monitoring overall state of your clusters, you can also analyze
        and browse your data structures in details.
        You can also update map configurations and take thread dump from nodes.
        With its scripting module, you can run scritps (JavaScript, Groovy etc.) on your servers.
        Version 2.0 is a web based tool so you can deploy it into your internal server and serve your users.
    </p><div class="sect2" title="18.1.1.&nbsp;Installation"><div class="titlepage"><div><div><h3 class="title"><a name="MC_Installation"></a>18.1.1.&nbsp;Installation</h3></div></div></div><p>
            It is important to understand how it actually works. Basically you will deploy
            <code class="literal">mancenter-_version_.war</code>
            application into your Java web server and then tell
            Hazelcast nodes to talk to that web application. That means, your Hazelcast nodes should know the
            URL of
            <code class="literal">mancenter</code>
            application before they start.
        </p><p>Here are the steps:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Download the latest Hazelcast zip from
                    <a class="link" href="http://www.hazelcast.com/downloads.jsp" target="_top">hazelcast.com</a>
                </p></li><li class="listitem"><p>
                    Zip contains
                    <code class="literal">mancenter-_version_.war</code>
                    file. Deploy it to your web server (Tomcat, Jetty etc.)
                    Let's say it is running at <code class="literal">http://localhost:8080/mancenter-_version_</code>.
                </p></li><li class="listitem"><p>Start your web server and make sure
                    <code class="literal">http://localhost:8080/mancenter-_version_</code>
                    is up.
                </p></li><li class="listitem"><p>Configure your Hazelcast nodes by adding the URL of your web app to your <code class="literal">
                    hazelcast.xml</code>.
                    Hazelcast nodes will send their states to this URL.
                    </p><pre class="programlisting">
<font font-style="bold" color="#0A1777">&lt;management-center</font> <font font-style="bold" color="#0A1777">enabled</font>=<font font-style="bold" color="#008000">"true"</font><font font-style="bold" color="#0A1777">&gt;</font>http://localhost:8080/mancenter-_version_<font font-style="bold" color="#0A1777">&lt;/management-center&gt;</font></pre><p>
                </p></li><li class="listitem"><p>Start your hazelcast cluster.
                </p></li><li class="listitem"><p>Browse to
                    <code class="literal">http://localhost:8080/mancenter-_version_</code>
                    and login.
                    <span class="bold"><strong>
                        Initial login username/passwords is
                        <code class="literal">admin/admin</code>
                    </strong></span>
                </p></li></ul></div><p>
        <span class="emphasis"><em>Management Center creates a directory with name "mancenter" under your "user/home" directory to save data files.
                You can change the data directory setting "hazelcast.mancenter.home" system property.
        </em></span>
        </p></div><div class="sect2" title="18.1.2.&nbsp;User Administration"><div class="titlepage"><div><div><h3 class="title"><a name="MC_UserAdministration"></a>18.1.2.&nbsp;User Administration</h3></div></div></div><p>Default credentials are for the admin user. In the
            <code class="literal">Administration</code>
            tab,
            Admin can add/remove/update users and control user read/write permissions.
        </p><p>
            <span class="inlinemediaobject"><img src="images/admin.jpg" width="70%"></span>
        </p></div><div class="sect2" title="18.1.3.&nbsp;Tool Overview"><div class="titlepage"><div><div><h3 class="title"><a name="MC_ToolOverview"></a>18.1.3.&nbsp;Tool Overview</h3></div></div></div><p>The starter page of the tool is <code class="literal">Cluster Home</code>. Here you can see cluster's main properties
            such as uptime,
            memory. Also with pie chart, you can see the distribution of partitions over cluster members. You can come
            back to this page, by clicking the
            <code class="literal">Home</code>
            icon on the top-right toolbar.
            On the left panel you see the Map/Queue/Topic instances in the cluster. At the bottom-left corner, members
            of the cluster are listed.
            On top menu bar, you can change the current tab to <code class="literal">Scripting, Docs</code>,
            user<code class="literal">Administration</code>. Note that Administration tab is viewable only for admin users.
            Also
            <code class="literal">Scripting</code>
            page is disabled for users with read-only credential.
        </p><p>
            <span class="inlinemediaobject"><img src="images/clusterhome.jpg" width="70%"></span>
        </p></div></div><div class="sect1" title="18.2.&nbsp;Maps"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MC_Maps"></a>18.2.&nbsp;Maps</h2></div></div></div><p>
        Map instances are listed on the left panel. When you click on a map, a new tab for monitoring this map instance
        is opened on the right.
        In this tab, you can monitor metrics also re-configure the map.
    </p><p>
        <span class="inlinemediaobject"><img src="images/maphome.jpg" width="70%"></span>
    </p><div class="sect2" title="18.2.1.&nbsp;Monitoring Maps"><div class="titlepage"><div><div><h3 class="title"><a name="MC_MapMonitoring"></a>18.2.1.&nbsp;Monitoring Maps</h3></div></div></div><p>
            In map page you can monitor instance metrics by 2 charts and 2 datatables. First data table "Memory Data
            Table" gives the memory metrics distributed over members. "Throughput Data Table" gives information about
            the operations performed on instance (get, put, remove)
            Each chart monitors a type data of the instance on cluster. You can change the type by clicking on chart.
            The possible ones are: Size, Throughput, Memory, Backup Size, Backup Memory, Hits, Locked Entries, Puts,
            Gets, Removes...
        </p><p>
            <span class="inlinemediaobject"><img src="images/mapchart.jpg" width="70%"></span>
        </p></div><div class="sect2" title="18.2.2.&nbsp;Map Browser"><div class="titlepage"><div><div><h3 class="title"><a name="MC_MapBrowser"></a>18.2.2.&nbsp;Map Browser</h3></div></div></div><p>
            You can open "Map Browser" tool by clicking "Browse" button on map tab page. Using map browser, you can
            reach map's entries by keys. Besides its value, extra informations such as entry's cost, expiration time is
            provided.
        </p><p>
            <a class="link" href="images/mapbrowse.jpg" target="_top">
                <span class="inlinemediaobject"><img src="images/mapbrowse.jpg" width="70%"></span>
            </a>
        </p></div><div class="sect2" title="18.2.3.&nbsp;Map Configuration"><div class="titlepage"><div><div><h3 class="title"><a name="MC_MapConfiguration"></a>18.2.3.&nbsp;Map Configuration</h3></div></div></div><p>
            You can open "Map Configuration" tool by clicking "Config" button on map tab page. This button is disabled
            for users with Read-Only permission. Using map config tool you can adjust map's setting. You can change
            backup count, max size, max idle(seconds), eviction policy, cache value, read backup data, backup count of
            the map.
        </p><p>
            <span class="inlinemediaobject"><img src="images/mapconfig.jpg" width="70%"></span>
        </p></div></div><div class="sect1" title="18.3.&nbsp;Queues"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MC_Queues"></a>18.3.&nbsp;Queues</h2></div></div></div><p>
        Queues is the second data structure that you can monitor in management center. You can activate the Queue Tab by
        clicking the instance name listed on the left panel under queues part. The queue page consists of the charts
        monitoring data about the queue. You can change the data to be monitored by clicking on the chart. Available
        options are Size, Polls, Offers.
    </p><p>
        <span class="inlinemediaobject"><img src="images/queue.jpg" width="70%"></span>
    </p></div><div class="sect1" title="18.4.&nbsp;Topics"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MC_Topics"></a>18.4.&nbsp;Topics</h2></div></div></div><p>
        You can monitor your topics' metrics by clicking the topic name listed on the left panel under topics part.
        There are two charts which reflects live data, and a datatable lists the live data distributed among members.
    </p><p>
        <span class="inlinemediaobject"><img src="images/topic.jpg" width="70%"></span>
    </p></div><div class="sect1" title="18.5.&nbsp;Members"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MC_Members"></a>18.5.&nbsp;Members</h2></div></div></div><p>
        The current members in the cluster are listed on the bottom side of the left panel. You can monitor each member
        on tab page displayed by clicking on member items.
    </p><p>
        <span class="inlinemediaobject"><img src="images/member.jpg" width="70%"></span>
    </p><div class="sect2" title="18.5.1.&nbsp;Monitoring"><div class="titlepage"><div><div><h3 class="title"><a name="MC_MemberMonitoring"></a>18.5.1.&nbsp;Monitoring</h3></div></div></div><p>
            In members page there are 4 inner tab pages to monitor member's state and properties.
            Runtime: Runtime properties about memory, threads are given. This data updates dynamically.
            Properties: System properties are displayed.
            Configuration: Configuration xml initially set can be viewed here.
            Partitions: The partitions belongs to this member are listed.
        </p><p>
            <span class="inlinemediaobject"><img src="images/memberconf.jpg" width="70%"></span>
        </p></div><div class="sect2" title="18.5.2.&nbsp;Operations"><div class="titlepage"><div><div><h3 class="title"><a name="MC_MemberOperations"></a>18.5.2.&nbsp;Operations</h3></div></div></div><p>
            Besides monitoring you can perform certain actions on members.
            You can take thread dump of the member and you can perform garbage collection on the selected member.
        </p><p>
            <span class="inlinemediaobject"><img src="images/mapoperations.jpg" width="70%"></span>
        </p></div></div><div class="sect1" title="18.6.&nbsp;System Logs"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MC_Logs"></a>18.6.&nbsp;System Logs</h2></div></div></div><p>
        System logs part helps you track internal operations and detect problems.
        To see system logs first you should set a Log level other than "None".
        In left menu there are inputs by which you can filter the displayed logs dynamically.
        Also you can Export your logs and send the file to Hazelcast support team, so they can analyze and help you solving your problem.
    </p><p>
        <span class="inlinemediaobject"><img src="images/systemlogs.jpg" width="70%"></span>
    </p></div><div class="sect1" title="18.7.&nbsp;Scripting"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MC_Scripting"></a>18.7.&nbsp;Scripting</h2></div></div></div><p>
        In scripting part, you can execute your own code on your cluster.
        In the left part you can select members, on which the code will be executed.
        Also you can select over scripting languages: Javascript, Groovy, JRuby, BeanShell.
        This part is only enabled for users with read/write permissions for current cluster.
    </p><p>
        <span class="inlinemediaobject"><img src="images/scripting.jpg" width="70%"></span>
    </p></div><div class="sect1" title="18.8.&nbsp;Time Travel"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MC_TimeTravel"></a>18.8.&nbsp;Time Travel</h2></div></div></div><p>
        Time Travel mode is activated by clicking clock icon on top right toolbar.
        In time travel mode,
        the time is paused and the full state of the cluster
        is displayed according the time selected on time slider.
        You can change time either by Prev/Next buttons or sliding the slider.
        Also you can change the day by clicking calendar icon.
        Management center stores the states in you local disk, while your web
        server is alive. So if you slide to a time when you do not have data,
        the reports will be seen as empty.
    </p><p>
        <span class="inlinemediaobject"><img src="images/timetravel.jpg" width="70%"></span>
    </p></div><div class="sect1" title="18.9.&nbsp;Console"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="MC_Console"></a>18.9.&nbsp;Console</h2></div></div></div><p>
        The console tool enables you execute commands on the cluster.
        You can read or write on instances but first you should set namespace.
        For example if you have a map with name "mapCustomers".
        To get a customer with key "Jack" you should first set the namespace with command "ns mapCustomers".
        Then you can take the object by "m.get Jack"
        Here is the command list:
        </p><pre class="programlisting">
-- General commands
echo true|false                      //turns on/off echo of commands (default false)
silent true|false                    //turns on/off silent of command output (default false)
#<font font-style="bold" color="#0A1777">&lt;number&gt;</font> <font font-style="bold" color="#0A1777">&lt;command&gt;</font>                  //repeats <font font-style="bold" color="#0A1777">&lt;number&gt;</font> time <font font-style="bold" color="#0A1777">&lt;command&gt;</font>, replace $i in <font font-style="bold" color="#0A1777">&lt;command&gt;</font> with current iteration (0..<font font-style="bold" color="#0A1777">&lt;number-1&gt;</font>)
&amp;<font font-style="bold" color="#0A1777">&lt;number&gt;</font> <font font-style="bold" color="#0A1777">&lt;command&gt;</font>                  //forks <font font-style="bold" color="#0A1777">&lt;number&gt;</font> threads to execute <font font-style="bold" color="#0A1777">&lt;command&gt;</font>, replace $t in <font font-style="bold" color="#0A1777">&lt;command&gt;</font> with current thread number (0..<font font-style="bold" color="#0A1777">&lt;number-1&gt;</font>
     When using #x or &amp;x, is is advised to use silent true as well.
     When using &amp;x with m.putmany and m.removemany, each thread will get a different share of keys unless a start key index is specified
jvm                                  //displays info about the runtime
who                                  //displays info about the cluster
whoami                               //displays info about this cluster member
ns <font font-style="bold" color="#0A1777">&lt;string&gt;</font>                          //switch the namespace for using the distributed queue/map/set/list <font font-style="bold" color="#0A1777">&lt;string&gt;</font> (defaults to "default"
@<font font-style="bold" color="#0A1777">&lt;file&gt;</font>                              //executes the given <font font-style="bold" color="#0A1777">&lt;file&gt;</font> script. Use '//' for comments in the script

-- Queue commands
q.offer <font font-style="bold" color="#0A1777">&lt;string&gt;</font>                     //adds a string object to the queue
q.poll                               //takes an object from the queue
q.offermany <font font-style="bold" color="#0A1777">&lt;number&gt;</font> [<font font-style="bold" color="#0A1777">&lt;size&gt;</font>]        //adds indicated number of string objects to the queue ('obj<font font-style="bold" color="#0A1777">&lt;i&gt;</font>' or byte[<font font-style="bold" color="#0A1777">&lt;size&gt;</font>])
q.pollmany <font font-style="bold" color="#0A1777">&lt;number&gt;</font>                  //takes indicated number of objects from the queue
q.iterator [remove]                  //iterates the queue, remove if specified
q.size                               //size of the queue
q.clear                              //clears the queue

-- Set commands
s.add <font font-style="bold" color="#0A1777">&lt;string&gt;</font>                       //adds a string object to the set
s.remove <font font-style="bold" color="#0A1777">&lt;string&gt;</font>                    //removes the string object from the set
s.addmany <font font-style="bold" color="#0A1777">&lt;number&gt;</font>                   //adds indicated number of string objects to the set ('obj<font font-style="bold" color="#0A1777">&lt;i&gt;</font>')
s.removemany <font font-style="bold" color="#0A1777">&lt;number&gt;</font>                //takes indicated number of objects from the set
s.iterator [remove]                  //iterates the set, removes if specified
s.size                               //size of the set
s.clear                              //clears the set

-- Lock commands
lock <font font-style="bold" color="#0A1777">&lt;key&gt;</font>                           //same as Hazelcast.getLock(key).lock()
tryLock <font font-style="bold" color="#0A1777">&lt;key&gt;</font>                        //same as Hazelcast.getLock(key).tryLock()
tryLock <font font-style="bold" color="#0A1777">&lt;key&gt;</font> <font font-style="bold" color="#0A1777">&lt;time&gt;</font>                 //same as tryLock <font font-style="bold" color="#0A1777">&lt;key&gt;</font> with timeout in seconds
unlock <font font-style="bold" color="#0A1777">&lt;key&gt;</font>                         //same as Hazelcast.getLock(key).unlock()

-- Map commands
m.put <font font-style="bold" color="#0A1777">&lt;key&gt;</font> <font font-style="bold" color="#0A1777">&lt;value&gt;</font>                  //puts an entry to the map
m.remove <font font-style="bold" color="#0A1777">&lt;key&gt;</font>                       //removes the entry of given key from the map
m.get <font font-style="bold" color="#0A1777">&lt;key&gt;</font>                          //returns the value of given key from the map
m.putmany <font font-style="bold" color="#0A1777">&lt;number&gt;</font> [<font font-style="bold" color="#0A1777">&lt;size&gt;</font>] [<font font-style="bold" color="#0A1777">&lt;index&gt;</font>]//puts indicated number of entries to the map ('key<font font-style="bold" color="#0A1777">&lt;i&gt;</font>':byte[<font font-style="bold" color="#0A1777">&lt;size&gt;</font>], <font font-style="bold" color="#0A1777">&lt;index&gt;</font>+(0..<font font-style="bold" color="#0A1777">&lt;number&gt;</font>)
m.removemany <font font-style="bold" color="#0A1777">&lt;number&gt;</font> [<font font-style="bold" color="#0A1777">&lt;index&gt;</font>]      //removes indicated number of entries from the map ('key<font font-style="bold" color="#0A1777">&lt;i&gt;</font>', <font font-style="bold" color="#0A1777">&lt;index&gt;</font>+(0..<font font-style="bold" color="#0A1777">&lt;number&gt;</font>)
     When using &amp;x with m.putmany and m.removemany, each thread will get a different share of keys unless a start key <font font-style="bold" color="#0A1777">&lt;index&gt;</font> is specified
m.keys                               //iterates the keys of the map
m.values                             //iterates the values of the map
m.entries                            //iterates the entries of the map
m.iterator [remove]                  //iterates the keys of the map, remove if specified
m.size                               //size of the map
m.clear                              //clears the map
m.destroy                            //destroys the map
m.lock <font font-style="bold" color="#0A1777">&lt;key&gt;</font>                         //locks the key
m.tryLock <font font-style="bold" color="#0A1777">&lt;key&gt;</font>                      //tries to lock the key and returns immediately
m.tryLock <font font-style="bold" color="#0A1777">&lt;key&gt;</font> <font font-style="bold" color="#0A1777">&lt;time&gt;</font>               //tries to lock the key within given seconds
m.unlock <font font-style="bold" color="#0A1777">&lt;key&gt;</font>                       //unlocks the key

-- List commands:
l.add <font font-style="bold" color="#0A1777">&lt;string&gt;</font>
l.add <font font-style="bold" color="#0A1777">&lt;index&gt;</font> <font font-style="bold" color="#0A1777">&lt;string&gt;</font>
l.contains <font font-style="bold" color="#0A1777">&lt;string&gt;</font>
l.remove <font font-style="bold" color="#0A1777">&lt;string&gt;</font>
l.remove <font font-style="bold" color="#0A1777">&lt;index&gt;</font>
l.set <font font-style="bold" color="#0A1777">&lt;index&gt;</font> <font font-style="bold" color="#0A1777">&lt;string&gt;</font>
l.iterator [remove]
l.size
l.clear
-- IAtomicLong commands:
a.get
a.set <font font-style="bold" color="#0A1777">&lt;long&gt;</font>
a.inc
a.dec
-- Executor Service commands:
execute	<font font-style="bold" color="#0A1777">&lt;echo-input&gt;</font>				//executes an echo task on random member
execute0nKey	<font font-style="bold" color="#0A1777">&lt;echo-input&gt;</font> <font font-style="bold" color="#0A1777">&lt;key&gt;</font>		//executes an echo task on the member that owns the given key
execute0nMember <font font-style="bold" color="#0A1777">&lt;echo-input&gt;</font> <font font-style="bold" color="#0A1777">&lt;key&gt;</font>	//executes an echo task on the member with given index
execute0nMembers <font font-style="bold" color="#0A1777">&lt;echo-input&gt;</font> 		//executes an echo task on all of the members
</pre><p>
    </p><p>
        <span class="inlinemediaobject"><img src="images/console.jpg" width="70%"></span>
    </p></div></div><div class="chapter" title="Chapter&nbsp;19.&nbsp;Miscellaneous"><div class="titlepage"><div><div><h2 class="title"><a name="Miscellaneous"></a>Chapter&nbsp;19.&nbsp;Miscellaneous</h2></div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="sect1"><a href="#CommonGotchas">19.1. Common Gotchas</a></span></dt><dt><span class="sect1"><a href="#ClusterTestHowTo">19.2. Testing Cluster</a></span></dt><dt><span class="sect1"><a href="#Todo">19.3. Planned Features</a></span></dt></dl></div><div class="sect1" title="19.1.&nbsp;Common Gotchas"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="CommonGotchas"></a>19.1.&nbsp;Common Gotchas</h2></div></div></div><p>Hazelcast is the distributed implementation of several structures that exist in Java.
        Most of the time it behaves as you expect. However there are some design choices in
        Hazelcast that violate some contracts. This page will list those violations.
        </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                    <span class="bold"><strong>equals() and hashCode() methods for the objects stored
                        in Hazelcast
                    </strong></span>
                </p><p>When you store a key, value in a distributed Map, Hazelcast serializes the key
                    and value and stores the byte array version of them in local ConcurrentHashMaps.
                    And this ConcurrentHashMap uses the equals and hashCode methods of byte array
                    version of your key. So it does not take into account the actual equals and
                    hashCode implementations of your objects. So it is important that you choose
                    your keys in a proper way. Implementing the equals and hashCode is not enough,
                    it is also important that the object is always serialized into the same byte
                    array. All primitive types, like; String, Long, Integer and etc. are good
                    candidates for keys to use in Hazelcast. An unsorted Set is an example of a very
                    bad candidate because Java Serialization may serialize the same unsorted set in
                    two different byte arrays.
                </p><p>Note that the distributed Set and List stores its entries as the keys in a
                    distributed Map. So the notes above apply to the objects you store in Set and
                    List.
                </p></li><li class="listitem"><p>
                    Hazelcast always return a clone copy of a value. Modifying the returned value does not change
                    the actual value in the map (or multimap or list or set).
                    You should put modified value back to make changes visible to all nodes.
                    </p><pre class="programlisting">
V value = map.get(key);
value.updateSomeProperty();
map.put(key, value);
</pre><p>
                    If <code class="code">cache-value</code> is true (default is true), Hazelcast caches that returned value
                    for fast access in local node. Modifications done to this cached value without
                    putting it back to map will be visible to only local node, successive <code class="code">get</code> calls will
                    return the same cached value.
                    To reflect modifications to distributed map, you should put modified value back into map.
                </p></li><li class="listitem"><p>
                    Collections which return values of methods such as <code class="code">IMap.keySet</code>, <code class="code">IMap.values</code>,
                    <code class="code">IMap.entrySet</code>, <code class="code">MultiMap.get</code>, <code class="code">MultiMap.remove</code>,
                    <code class="code">IMap.keySet</code>, <code class="code">IMap.values</code>, contain cloned values. These collections are NOT
                    backup by related Hazelcast objects.
                    So changes to the these are <span class="bold"><strong>NOT</strong></span> reflected in the originals, and vice-versa.
                </p></li><li class="listitem"><p>
                    Most of the Hazelcast operations throw an <code class="code">RuntimeInterruptedException</code>
                    (which is unchecked version of <code class="code">InterruptedException</code>)
                    if a user thread is interrupted while waiting a response.
                    Hazelcast uses RuntimeInterruptedException to pass InterruptedException up through interfaces
                    that don't have InterruptedException in their signatures. Users should be able to catch and handle
                    <code class="code">RuntimeInterruptedException</code> in such cases as if their threads are interrupted on
                    a blocking operation.
                </p></li><li class="listitem"><p>
                    Some of Hazelcast operations can throw <code class="code">ConcurrentModificationException</code> under transaction
                    while trying to acquire a resource, although operation signatures don't define such an exception.
                    Exception is thrown if resource can not be acquired in a specific time. Users should be able to catch
                    and handle <code class="code">ConcurrentModificationException</code> while they are using Hazelcast transactions.
                </p></li></ol></div><p>
    </p></div><div class="sect1" title="19.2.&nbsp;Testing Cluster"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ClusterTestHowTo"></a>19.2.&nbsp;Testing Cluster</h2></div></div></div><p>Hazelcast allows you to create more than one member on the same JVM. Each member is called
        <code class="literal">HazelcastInstance</code>
        and each will have its own configuration, socket
        and threads, so you can treat them as totally separate members. This enables us to write and
        run cluster unit tests on single JVM. As you can use this feature for creating separate
        members different applications running on the same JVM (imagine running multiple webapps on
        the same JVM), you can also use this feature for testing Hazelcast cluster.
    </p><p>Let's say you want to test if two members have the same size of a map.
        </p><pre class="programlisting">
<em><span class="hl-annotation" style="color: gray">@Test</span></em>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> testTwoMemberMapSizes() {
    <em class="hl-comment" style="color: silver">// start the first member</em>
    HazelcastInstance h1 = Hazelcast.newHazelcastInstance(null);
    <em class="hl-comment" style="color: silver">// get the map and put 1000 entries</em>
    Map map1 = h1.getMap(<font font-style="normal" color="#008000">"testmap"</font>);
    <strong class="hl-keyword">for</strong> (<strong class="hl-keyword">int</strong> i = <span class="hl-number">0</span>; i &lt; <span class="hl-number">1000</span>; i++) {
        map1.put(i, <font font-style="normal" color="#008000">"value"</font> + i);
    }
    <em class="hl-comment" style="color: silver">// check the map size</em>
    assertEquals(<span class="hl-number">1000</span>, map1.size());
    <em class="hl-comment" style="color: silver">// start the second member</em>
    HazelcastInstance h2 = Hazelcast.newHazelcastInstance(null);
    <em class="hl-comment" style="color: silver">// get the same map from the second member</em>
    Map map2 = h2.getMap(<font font-style="normal" color="#008000">"testmap"</font>);
    <em class="hl-comment" style="color: silver">// check the size of map2</em>
    assertEquals(<span class="hl-number">1000</span>, map2.size());
    <em class="hl-comment" style="color: silver">// check the size of map1 again</em>
    assertEquals(<span class="hl-number">1000</span>, map1.size());
}
</pre><p>In the test above, everything happened in the same thread. When developing
        multi-threaded test, coordination of the thread executions has to be carefully handled.
        Usage of
        <code class="literal">CountDownLatch</code>
        for thread coordination is highly recommended.
        You can certainly use other things. Here is an example where we need to listen for messages
        and make sure that we got these messages:</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@Test</span></em>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> testTopic() {
    <em class="hl-comment" style="color: silver">// start two member cluster</em>
    HazelcastInstance h1 = Hazelcast.newHazelcastInstance(null);
    HazelcastInstance h2 = Hazelcast.newHazelcastInstance(null);
    String topicName = <font font-style="normal" color="#008000">"TestMessages"</font>;
    <em class="hl-comment" style="color: silver">// get a topic from the first member and add a messageListener</em>
    ITopic&lt;String&gt; topic1 = h1.getTopic(topicName);
    <strong class="hl-keyword">final</strong> CountDownLatch latch1 = <strong class="hl-keyword">new</strong> CountDownLatch(<span class="hl-number">1</span>);
    topic1.addMessageListener(<strong class="hl-keyword">new</strong> MessageListener() {
        <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> onMessage(Object msg) {
            assertEquals(<font font-style="normal" color="#008000">"Test1"</font>, msg);
            latch1.countDown();
        }
    });
    <em class="hl-comment" style="color: silver">// get a topic from the second member and add a messageListener</em>
    ITopic&lt;String&gt; topic2 = h2.getTopic(topicName);
    <strong class="hl-keyword">final</strong> CountDownLatch latch2 = <strong class="hl-keyword">new</strong> CountDownLatch(<span class="hl-number">2</span>);
    topic2.addMessageListener(<strong class="hl-keyword">new</strong> MessageListener() {
        <strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> onMessage(Object msg) {
            assertEquals(<font font-style="normal" color="#008000">"Test1"</font>, msg);
            latch2.countDown();
        }
    });
    <em class="hl-comment" style="color: silver">// publish the first message, both should receive this</em>
    topic1.publish(<font font-style="normal" color="#008000">"Test1"</font>);
    <em class="hl-comment" style="color: silver">// shutdown the first member</em>
    h1.shutdown();
    <em class="hl-comment" style="color: silver">// publish the second message, second member's topic should receive this</em>
    topic2.publish(<font font-style="normal" color="#008000">"Test1"</font>);
    <strong class="hl-keyword">try</strong> {
        <em class="hl-comment" style="color: silver">// assert that the first member's topic got the message</em>
        assertTrue(latch1.await(<span class="hl-number">5</span>, TimeUnit.SECONDS));
        <em class="hl-comment" style="color: silver">// assert that the second members' topic got two messages</em>
        assertTrue(latch2.await(<span class="hl-number">5</span>, TimeUnit.SECONDS));
    } <strong class="hl-keyword">catch</strong> (InterruptedException ignored) {
    }
}
</pre><p>
        Also remember to call
        <code class="literal">Hazelcast.shutdownAll()</code>
        after each test
        case to make sure that there is no other running member left from the previous tests.</p><pre class="programlisting"><em><span class="hl-annotation" style="color: gray">@After</span></em>
<strong class="hl-keyword">public</strong> <strong class="hl-keyword">void</strong> cleanup() <strong class="hl-keyword">throws</strong> Exception {
    Hazelcast.shutdownAll();
}
</pre><p>Need more info?
        <a class="link" href="https://github.com/hazelcast/hazelcast/tree/master/hazelcast/src/test/java/com/hazelcast/cluster" target="_top">
            Check out existing tests.
        </a>
    </p></div><div class="sect1" title="19.3.&nbsp;Planned Features"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="Todo"></a>19.3.&nbsp;Planned Features</h2></div></div></div><p>Random order of planned features.
        </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>Native C++ Client</p></li><li class="listitem"><p>Ready-to-go Hazelcast Cache Server Image for Amazon EC2</p></li><li class="listitem"><p>Symmetric Encryption for Java Client</p></li><li class="listitem"><p>Distributed
                    <code class="literal">java.util.concurrent.DelayQueue</code>
                    implementation.
                </p></li><li class="listitem"><p>Distributed Tree implementation.</p></li><li class="listitem"><p>Distributed Tuple implementation.</p></li><li class="listitem"><p>Built-in file based storage.</p></li></ul></div><p>
    </p></div></div></div></body></html>